<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>573 UVa, The Snail | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="Not based on fancy algorithms or data structures.">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/competitive-prog-post/the-snail/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/competitive-prog-post/the-snail/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="573 UVa, The Snail" />
<meta property="og:description" content="Not based on fancy algorithms or data structures." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/competitive-prog-post/the-snail/" /><meta property="article:section" content="competitive-prog-post" />
<meta property="article:published_time" content="2020-04-26T00:00:01+00:00" />
<meta property="article:modified_time" content="2020-04-26T00:00:01+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="573 UVa, The Snail"/>
<meta name="twitter:description" content="Not based on fancy algorithms or data structures."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Competitive Programming",
      "item": "https://www.mostafatouny.github.io/competitive-prog-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "573 UVa, The Snail",
      "item": "https://www.mostafatouny.github.io/competitive-prog-post/the-snail/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "573 UVa, The Snail",
  "name": "573 UVa, The Snail",
  "description": "Not based on fancy algorithms or data structures.",
  "keywords": [
    
  ],
  "articleBody": "My Proposed Solution Probably, You thought of the straight forward solution of just simulating the height reached by the snail day by day till some condition applies. So, your computation would look like $$ (u_1 - fatigue_1 - d_1) + (u_2 - fatigue_2 - d_2) + .. + (u_n - fatigue_n - d_n) $$In this solution I claim determining whether the snail succeeded or failed could be done in $O(1)$ !! (that discovery was a surprise for me, as well). In a nutshell, We shall derive a formula which computes the snail’s height on any given day. Then we find the day in which the snail’s height is at its peak. By plugging in that day in the formula, we compute the height peak of the snail. if that height peak is greater than $h$, the weight of the well, then we conclude the snail at some point exceeds the well. If the height peak is equal or less than $h$, Then we conclude the snail shall not exceed the well.\nLet’s begin by finding the formula. I noticed a pattern. That computation you probably first thought of is exactly like $$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - (fatigue_1 + fatigue_2 + .. + fatigue_n) $$$$ = (u \\times i) - (d \\times i) - (\\text{total fatigue up to day i})$$ So, instead of looping in a complexity of $\\omega(n)$, One equation could achieve the same result in a complexity of $O(1)$. The first and second parts are obvious, but how do we find the third one? First, Assume $f=1$, then $$fatigue_1=0.01 * u * 1, fatigue_2=0.01 * u * 2 , .. , fatigue_n=0.01 * u * i$$ As each day we increase fatigue by $f$, day number $i$ should be equal to $i$ times $f$. $0.01$ and $u$ are common factors, so we could re-write this as $$(0.01*u)(1 + 2 + .. + i)$$ the right part of the equation is where the magic happens. Friedrich Gauss, The legendary mathematician discovered that it is equal to $$\\frac{n(n+1)}{2}$$ He made it when he was a kid as his teacher tried to preoccupy his time with tedious math calculation! read his story here. So, the final pattern looks like this $$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - \\frac{n(n+1)}{2} $$ So far, that equation applies when $f=1$ but the The Snail - 573 problem asks for a general value of $f$. Let me get you through the proof of Guassian’s equation briefly, and see how could we generalize it to a general value of $f$. Assume we wish to calculate $2 \\times (1+2+ .. + n)$. That could be re-written as $$ 1 + 2 + .. + n $$$$ + $$$$ n + (n-1) + .. + 1 $$ Try to interpret both of these equations as $n$ columns of two rows. The first column is $1+n$, second is $2+(n-1)$, .. , nth day is $n+1$. All of the $n$ columns are equal to $n+1$. Therefore $$2 \\times (1+2+ .. + n) = n(n+1)$$ Divide both sides by two, and the proof of Guassian’s equation is done. QED. Now, instead of incrementing by one, the value of %f%, assume %f=x% where x is an arbitrary value. Let’s try to re-apply the proof again. This is time we calculate $2 \\times (x+2x+ .. + nx)$. We re-write it as $$ x + 2x + .. + nx $$$$ + $$$$ nx + (n-1)x + .. + x $$ Similarly, $(x+nx) + (2x+(n-1)x) + .. + (nx+x) = n(nx+x)$, As each term of the n terms is equal to $(x+nx)$. Dividing by two yields us the final magical equation as follows $$ (u \\times n) - (d \\times n) - \\frac{n(nx+x)}{2} $$ That justifies totalHeight and fOnDay functions in my source code (see them below). So now, we could find the height of the snail at any day by just plugging-in a formula in a complexity of $O(1)$.\nHow are we going to use the formula we just derived? Are we going to loop on each day, applying the formula then checking for some conditions? That would account for complexity of $\\omega(n)$ which saves us nearly nothing. As I promised you before, We find the day in which the snail reaches its peak. Then we plug-in that day in the formula we just derived to find the greatest possible height the snail ever reached. Finally, we compare that with $h$ to reach our conclusion of whether the snail succeeded.\nTake a look at the following equation. Recall that $u$, $d$ and $f$ are given in The Snail - 573 problem. $$ (i*f)*u = (u-d) $$ So, The only unknown is $i$ which could be easily computed. What we are trying to find out here is the day $i$ for which fatigue is equal to the total increment the snail achieves. in other words, we are looking for the day in which fatigue totally cancels out any upwards increment. The upwards increase of $u-d$ keeps decaying due to fatigue till no possible upwards increment is possible. Hence, day $i$ in the above equation is the day in which the snail reaches its peak! That justifies my function dayOfNonIncrease in the source code below. Now, we could find out the maximum possible height reached by the snail.\nAt this point, I delivered my promise that we could find out whether the snail failed or succeeded in $O(1)$. The Snail problem asks for more than that, namely, the day in which the snail succeeded or failed.\nThere is a catch in our approach. According to The Snail - 573 problem, the fatigue cannot result in negative upwards increment, As stated The snail never climbs a negative distance. Our formula does not take into its account that the max possible fatigue is 100%. Nonetheless, That would not disrupt we could find out whether the snail succeeded or failed in $O(1)$ as illustrated above. That could be clearly seen as we do not need to compute up to days in which fatigue exceeds 100%.\nHowever, We are going to rectify that limitation in order to complete solving The Snail problem. We divide the computation of total height in a given day by two parts. The first part is computed exactly as mentioned before and applies on a day $i$ which is equal or less than the day maxFatDay in which fatigue is 100%. the second part handles days in which fatigue exceeds 100%. For the second part, total height could be clearly found by $(i-maxFatDay) \\times d$, As fatigue would totally cancel out upwards climb. In other words, In these days, the snail would just be dropping down without any climb. By summing both of these parts we could find out the height of any given day, Even if that day is beyond maxFatDay in which fatigue reached its maximum. Note that maxFatDay might not be exactly 100% as $f$ might not divides 100. In this case, It would be the maximum fatigue equal or less than 100%. That justifies my function totalHeightAnyDay in source code below.\nSo far, We are still computing in a complexity of $O(1)$ !! The last scene is finding the day the snail first exceeded $h$ or dropped to a negative height. Unfortunately, I could not find a way but to keep looping, beginning from the day of snail reaching its peak, till its height is either below $h$ or negative. That is the last part of my source code below. Could you improve upon this solution to maintain a complexity of $\\omega(1)$?\nSource Code #include #include // total u's from day 1 to day i int uOnDay(int u, int i) { return u*i; } // total d's from day 1 to day i int dOnDay(int d, int i) { return d*i; } // total fatigue percentage from day 1 to day i // it is a generalization of gaussian's famous equation n(n+1)/2 = 1 + 2 + .. + n float fOnDay(float f, int i) { return (i*((i*f)+f))/2; } // we find day i such that // i * (fPercent*u) = u - d int dayOfNonIncrease(int u, int d, float fPercent) { float res = (float)(u-d)/(float)(fPercent*u); return std::max(int(res), 0); } // we find day i such that // i * fPercent = 1 int findDayOfMaxF(float fPercent) { int res = (float)1/fPercent; return res; } // height at day i, in case no fatigue is more than 100% from day 1 up to day i // totalF is total fatigue percentage from day 1 up to i float totalHeight(int u, int d, int i, float totalF) { return (float)uOnDay(u, i) - (float)dOnDay(d, i) - totalF; } // height at day i. no constraints here float totalHeightAnyDay(int u, int d, float fPercent, int peakHeightDay, int dayOfMaxFat, int i) { float totalF, tot; if (i \u003c= dayOfMaxFat) { totalF = (float)u*fOnDay(fPercent, i-1); tot = totalHeight(u, d, i, totalF); return tot; } else { totalF = (float)u*fOnDay(fPercent, dayOfMaxFat-1); tot = totalHeight(u, d, dayOfMaxFat, totalF); int daysRng = i - dayOfMaxFat; // after dayOfMaxFat, fatigue would be more than 100% if same function is applied // max fatigue possible is 100% totalF = ((float)u*1)*daysRng; tot += totalHeight(u, d, daysRng, totalF); return tot; } } int main() { int h, u, d, f; while(true) { scanf(\"%d %d %d %d\", \u0026h, \u0026u, \u0026d, \u0026f); if (h==0) break; // f as a percentage float fPercent = (float)f/(float)100; // day in which snail reached its peak int peakHeightDay = dayOfNonIncrease(u, d, fPercent); peakHeightDay += 1; // day in which snail fatigue reached its highest possible value int dayOfMaxFat = findDayOfMaxF(fPercent); dayOfMaxFat += 1; // calculate height at day of maximum possible height float peakHeight = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, peakHeightDay) + d; // if peak is greater than h, then the snail succeeded // if not, then the snail shall never exceed h float tot; if (peakHeight \u003e h) { int i=peakHeightDay; // keep moving days backwards till the snail's height is less than h do { i--; if (i\u003c1) break; tot = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, i) + d; } while(tot \u003e h); // the day after catched day above, is the one in which snail first exceeded h printf(\"success on day %d\\n\", i+1); } else { int i = peakHeightDay; // keep moving days upwards till the snail's height is negative do { tot = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, i); i++; } while(tot \u003e= 0); // the day catched above is greater than the day in which snail's height became negative by one printf(\"failure on day %d\\n\", i-1); } } return 0; } ",
  "wordCount" : "1790",
  "inLanguage": "en",
  "datePublished": "2020-04-26T00:00:01Z",
  "dateModified": "2020-04-26T00:00:01Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/competitive-prog-post/the-snail/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      573 UVa, The Snail
    </h1>
    <div class="post-meta"><span title='2020-04-26 00:00:01 +0000 UTC'>April 26, 2020</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#my-proposed-solution" aria-label="My Proposed Solution">My Proposed Solution</a></li>
                <li>
                    <a href="#source-code" aria-label="Source Code">Source Code</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="my-proposed-solution">My Proposed Solution<a hidden class="anchor" aria-hidden="true" href="#my-proposed-solution">#</a></h3>
<p>Probably, You thought of the straight forward solution of just simulating the height reached by the snail day by day till some condition applies. So, your computation would look like
</p>
$$ (u_1 - fatigue_1 - d_1) + (u_2 - fatigue_2 - d_2) + .. + (u_n - fatigue_n - d_n) $$<p>In this solution I claim determining whether the snail succeeded or failed could be done in $O(1)$ !! (that discovery was a surprise for me, as well). In a nutshell, We shall derive a formula which computes the snail&rsquo;s height on any given day. Then we find the day in which the snail&rsquo;s height is at its peak. By plugging in that day in the formula, we compute the height peak of the snail. if that height peak is greater than $h$, the weight of the well, then we conclude the snail at some point exceeds the well. If the height peak is equal or less than $h$, Then we conclude the snail shall not exceed the well.</p>
<p>Let&rsquo;s begin by finding the formula. I noticed a pattern. That computation you probably first thought of is exactly like
</p>
$$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - (fatigue_1 + fatigue_2 + .. + fatigue_n) $$$$ = (u \times i) - (d \times i) - (\text{total fatigue up to day i})$$<p>
So, instead of looping in a complexity of $\omega(n)$, One equation could achieve the same result in a complexity of $O(1)$. The first and second parts are obvious, but how do we find the third one? First, Assume $f=1$, then </p>
$$fatigue_1=0.01 * u * 1, fatigue_2=0.01 * u * 2 , .. , fatigue_n=0.01 * u * i$$<p>
As each day we increase fatigue by $f$, day number $i$ should be equal to $i$ times $f$. $0.01$ and $u$ are common factors, so we could re-write this as
</p>
$$(0.01*u)(1 + 2 + .. + i)$$<p>
the right part of the equation is where the magic happens. Friedrich Gauss, The legendary mathematician discovered that it is equal to
</p>
$$\frac{n(n+1)}{2}$$<p>
He made it when he was a kid as his teacher tried to preoccupy his time with tedious math calculation! read his story <a href="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss#Anecdotes">here</a>.
So, the final pattern looks like this
</p>
$$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - \frac{n(n+1)}{2} $$<p>
So far, that equation applies when $f=1$ but the The <em>Snail - 573</em> problem asks for a general value of $f$. Let me get you through the proof of Guassian&rsquo;s equation briefly, and see how could we generalize it to a general value of $f$. Assume we wish to calculate $2 \times (1+2+ .. + n)$. That could be re-written as
</p>
$$ 1 + 2 + .. + n $$$$ + $$$$ n + (n-1) + .. + 1 $$<p>
Try to interpret both of these equations as $n$ columns of two rows. The first column is $1+n$, second is $2+(n-1)$, .. , nth day is $n+1$. All of the $n$ columns are equal to $n+1$. Therefore
</p>
$$2 \times (1+2+ .. + n) = n(n+1)$$<p>
Divide both sides by two, and the proof of Guassian&rsquo;s equation is done. QED. Now, instead of incrementing by one, the value of %f%, assume %f=x% where x is an arbitrary value. Let&rsquo;s try to re-apply the proof again. This is time we calculate $2 \times (x+2x+ .. + nx)$. We re-write it as
</p>
$$ x + 2x + .. + nx $$$$ + $$$$ nx + (n-1)x + .. + x $$<p>
Similarly, $(x+nx) + (2x+(n-1)x) + .. + (nx+x) = n(nx+x)$, As each term of the n terms is equal to $(x+nx)$. Dividing by two yields us the final magical equation as follows
</p>
$$ (u \times n) - (d \times n) - \frac{n(nx+x)}{2} $$<p>
That justifies <em>totalHeight</em> and <em>fOnDay</em> functions in my source code (see them below). So now, we could find the height of the snail at any day by just plugging-in a formula in a complexity of $O(1)$.</p>
<p>How are we going to use the formula we just derived? Are we going to loop on each day, applying the formula then checking for some conditions? That would account for complexity of $\omega(n)$ which saves us nearly nothing. As I promised you before, We find the day in which the snail reaches its peak. Then we plug-in that day in the formula we just derived to find the greatest possible height the snail ever reached. Finally, we compare that with $h$ to reach our conclusion of whether the snail succeeded.</p>
<p>Take a look at the following equation. Recall that $u$, $d$ and $f$ are given in <em>The Snail - 573</em> problem.
</p>
$$ (i*f)*u = (u-d) $$<p>
So, The only unknown is $i$ which could be easily computed. What we are trying to find out here is the day $i$ for which <em>fatigue</em> is equal to the total increment the snail achieves. in other words, we are looking for the day in which fatigue totally cancels out any upwards increment. The upwards increase of $u-d$ keeps decaying due to fatigue till no possible upwards increment is possible. Hence, day $i$ in the above equation is the day in which the snail reaches its peak! That justifies my function <em>dayOfNonIncrease</em> in the source code below. Now, we could find out the maximum possible height reached by the snail.</p>
<p>At this point, I delivered my promise that we could find out whether the snail failed or succeeded in $O(1)$. <em>The Snail</em> problem asks for more than that, namely, the day in which the snail succeeded or failed.</p>
<p>There is a catch in our approach. According to <em>The Snail - 573</em> problem, the fatigue cannot result in negative upwards increment, As stated <em>The snail never climbs a negative distance</em>. Our formula does not take into its account that the max possible fatigue is 100%. Nonetheless, That would not disrupt we could find out whether the snail succeeded or failed in $O(1)$ as illustrated above. That could be clearly seen as we do not need to compute up to days in which fatigue exceeds 100%.</p>
<p>However, We are going to rectify that limitation in order to complete solving <em>The Snail</em> problem. We divide the computation of total height in a given day by two parts. The first part is computed exactly as mentioned before and applies on a day $i$ which is equal or less than the day <em>maxFatDay</em> in which fatigue is 100%. the second part handles days in which fatigue exceeds 100%. For the second part, total height could be clearly found by $(i-maxFatDay) \times d$, As fatigue would totally cancel out upwards climb. In other words, In these days, the snail would just be dropping down without any climb. By summing both of these parts we could find out the height of any given day, Even if that day is beyond maxFatDay in which fatigue reached its maximum. Note that <em>maxFatDay</em> might not be exactly 100% as $f$ might not divides 100. In this case, It would be the maximum fatigue equal or less than 100%. That justifies my function <em>totalHeightAnyDay</em> in source code below.</p>
<p>So far, We are still computing in a complexity of $O(1)$ !! The last scene is finding the day the snail first exceeded $h$ or dropped to a negative height. Unfortunately, I could not find a way but to keep looping, beginning from the day of snail reaching its peak, till its height is either below $h$ or negative. That is the last part of my source code below. Could you improve upon this solution to maintain a complexity of $\omega(1)$?</p>
<h3 id="source-code">Source Code<a hidden class="anchor" aria-hidden="true" href="#source-code">#</a></h3>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;

// total u&#39;s from day 1 to day i
int uOnDay(int u, int i) {
  return u*i;
}

// total d&#39;s from day 1 to day i
int dOnDay(int d, int i) {
  return d*i;
}

// total fatigue percentage from day 1 to day i
// it is a generalization of gaussian&#39;s famous equation n(n+1)/2 = 1 + 2 + .. + n
float fOnDay(float f, int i) {
  return (i*((i*f)+f))/2;
}

// we find day i such that
// i * (fPercent*u) = u - d
int dayOfNonIncrease(int u, int d, float fPercent) {
  float res = (float)(u-d)/(float)(fPercent*u);
  return std::max(int(res), 0);
}

// we find day i such that
// i * fPercent = 1
int findDayOfMaxF(float fPercent) {
  int res = (float)1/fPercent;
  return res;
}

// height at day i, in case no fatigue is more than 100% from day 1 up to day i
// totalF is total fatigue percentage from day 1 up to i
float totalHeight(int u, int d, int i, float totalF) {
  return (float)uOnDay(u, i) - (float)dOnDay(d, i) - totalF;
}

// height at day i. no constraints here
float totalHeightAnyDay(int u, int d, float fPercent, int peakHeightDay, int dayOfMaxFat, int i) {
  float totalF, tot;
  
  if (i &lt;= dayOfMaxFat) {
    totalF = (float)u*fOnDay(fPercent, i-1);
    tot = totalHeight(u, d, i, totalF);
    return tot;
  }
  else {
    totalF = (float)u*fOnDay(fPercent, dayOfMaxFat-1);
    tot = totalHeight(u, d, dayOfMaxFat, totalF);
    int daysRng = i - dayOfMaxFat;

    // after dayOfMaxFat, fatigue would be more than 100% if same function is applied
    // max fatigue possible is 100%
    totalF = ((float)u*1)*daysRng;
    tot += totalHeight(u, d, daysRng, totalF);
    
    return tot;
  }
}

int main() {
  int h, u, d, f;
  
  while(true) {

    scanf(&#34;%d %d %d %d&#34;, &amp;h, &amp;u, &amp;d, &amp;f);
    if (h==0)
      break;

    // f as a percentage
    float fPercent = (float)f/(float)100;
    // day in which snail reached its peak
    int peakHeightDay = dayOfNonIncrease(u, d, fPercent);
    peakHeightDay += 1;
    // day in which snail fatigue reached its highest possible value
    int dayOfMaxFat = findDayOfMaxF(fPercent);
    dayOfMaxFat += 1;

    // calculate height at day of maximum possible height
    float peakHeight =  totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, peakHeightDay) + d;


    // if peak is greater than h, then the snail succeeded
    // if not, then the snail shall never exceed h
    
    float tot;
    if (peakHeight &gt; h) {
      int i=peakHeightDay;
      // keep moving days backwards till the snail&#39;s height is less than h
      do {
	i--;
	if (i&lt;1)
	  break;
	tot = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, i) + d;
      }
      while(tot &gt; h);

      // the day after catched day above, is the one in which snail first exceeded h
      printf(&#34;success on day %d\n&#34;, i+1);
    }
    else {
      int i = peakHeightDay;
      // keep moving days upwards till the snail&#39;s height is negative
      do {
	tot = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, i);
	i++;
      }
      while(tot &gt;= 0);

      // the day catched above is greater than the day in which snail&#39;s height became negative by one
      printf(&#34;failure on day %d\n&#34;, i-1);
    }
    
  }
  
  return 0;
}
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
