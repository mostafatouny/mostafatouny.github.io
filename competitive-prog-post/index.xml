<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Competitive Programming | Mostafa Touny</title>
    <link>https://mostafatouny.github.io/competitive-prog-post/</link>
      <atom:link href="https://mostafatouny.github.io/competitive-prog-post/index.xml" rel="self" type="application/rss+xml" />
    <description>Competitive Programming</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Thu, 11 Jun 2020 00:00:01 +0000</lastBuildDate>
    <image>
      <url>https://mostafatouny.github.io/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_512x512_fill_lanczos_center_3.png</url>
      <title>Competitive Programming</title>
      <link>https://mostafatouny.github.io/competitive-prog-post/</link>
    </image>
    
    <item>
      <title>UVa 10940, Throwing Cards Away II</title>
      <link>https://mostafatouny.github.io/competitive-prog-post/throwing-cards-away/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:01 +0000</pubDate>
      <guid>https://mostafatouny.github.io/competitive-prog-post/throwing-cards-away/</guid>
      <description>&lt;h3 id=&#34;first-trial&#34;&gt;First Trial&lt;/h3&gt;
&lt;p&gt;At each step we discard a card away, and move the new card at the top to the bottom of the deck. That suggests we eliminate half of the deck for one iteration. Consider the following deck&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Here, We have a deck of eight cards whereby card number one is at the top of the deck. &lt;em&gt;x&lt;/em&gt; indicates the card is to be thrown away, while &lt;em&gt;-&amp;gt;&lt;/em&gt; indicates the card to be moved to the bottom. Note that in this case, None of the &lt;em&gt;-&amp;gt;&lt;/em&gt; cards are going to be thrown away due to later &lt;em&gt;x&lt;/em&gt;. It is easy to see that the result is as follows&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Similarly to the first iteration, the second one would be&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;yielding&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Finally, Getting &lt;em&gt;card eight&lt;/em&gt; as the answer.&lt;/p&gt;
&lt;p&gt;So, On each iteration, we divided the dick by half and still got an even number of cards. It is clear that is attributed to the fact that &lt;em&gt;eight&lt;/em&gt; is a power of two. Otherwise, On some iteration we would end-up with an odd number of cards. That iteration is not the last one in which we have the last remaining card. You could see if we have a deck whose cards number is some power of two, Then the answer would be the last card at the bottom. In other words, if our cards number is $n = 2^k$ for some &lt;em&gt;k&lt;/em&gt;, Then the correct answer of the problem, i.e the last remaining card after discarding cards and moving them to the bottom, is $2^k$.&lt;/p&gt;
&lt;h3 id=&#34;more-justification-of-first-trials-observation&#34;&gt;More Justification of First Trial&amp;rsquo;s Observation&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s try to take a deeper look at why do we always obtain the last bottom card as the remaining one in case the deck is some power of two, As illustrated earlier. Consider our $2^3 = 8$ deck but represented differently&lt;/p&gt;
&lt;p&gt;On &lt;strong&gt;First Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 1$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 2$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 3$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 4$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 5$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 6$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 7$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^0 \times 8$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;On &lt;strong&gt;Second Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$2^1 \times 1$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^1 \times 2$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^1 \times 3$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^1 \times 4$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;On &lt;strong&gt;Third Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$2^2 \times 1$&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$2^2 \times 2$&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Remarkably, Cards multiplied by an odd number gets thrown away, while cards multiplied by an even number gets moved to the bottom and survives to the next iteration. You could also see that $2^{k_0} \times (2k_1) = 2^{k_0+1}$. The even number increases the power of two by one. That correspoinds with our observation that each iteration&amp;rsquo;s power is increased by one than its predocessor&amp;rsquo;s power. Clearly, Continuing in this way ends us up with the greatest power of two in the whole deck, which is also the last bottom card.&lt;/p&gt;
&lt;h3 id=&#34;generalizing-for-none-power-of-two&#34;&gt;Generalizing for None Power of Two&lt;/h3&gt;
&lt;p&gt;Our solution for the generalized case is in fact an extension of the special case of deck&amp;rsquo;s whose number is a power of two. Let&amp;rsquo;s begin from where we ended up.&lt;/p&gt;
&lt;h4 id=&#34;a-deck-of-seven-cards&#34;&gt;A Deck of Seven Cards&lt;/h4&gt;
&lt;p&gt;On &lt;strong&gt;First Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note that I intentionally did not mark &lt;em&gt;card seven&lt;/em&gt;. Otherwise, The second iteration would have the first card marked as &lt;em&gt;-&amp;gt;&lt;/em&gt;, violating consistency of marking among iterations. In case cards number is odd, as in this case, We prefer to avoid marking the last card, and get the second iteration as&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We have got here cards of some power of two. Following our illustrated observation in the previous section, We could conclude the last remaining card is &lt;em&gt;card six&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For eight cards deck, The second iteration was &lt;em&gt;&amp;lt;2, 4, 6, 8&amp;gt;&lt;/em&gt;. Removing &lt;em&gt;card eight&lt;/em&gt; from the deck resulted in having &lt;em&gt;card seven&lt;/em&gt; as a remainder from the first iteration, and shifting &lt;em&gt;&amp;lt;2, 4, 6, 8&amp;gt;&lt;/em&gt; one position to the right. As a result, We have &lt;em&gt;card six&lt;/em&gt; as the last one in &lt;em&gt;second iteration&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For eight cards deck, The last remaining card was &lt;em&gt;eight&lt;/em&gt;. For seven cards deck, the last remaining card is &lt;em&gt;six&lt;/em&gt;. Removing one card from the &lt;em&gt;eight cards deck&lt;/em&gt; yielded the same remaining card but subtracted by two. In other words, $8 - 1$ cards deck yields the last remaining card &lt;em&gt;sevenCardsAnswer&lt;/em&gt; = &lt;em&gt;eightCardsAnswer&lt;/em&gt; - (2 * removedCards) = 8 - (2 * 1) = 6. Let&amp;rsquo;s try more trials and see how they relate with the case of &lt;em&gt;eight cards deck&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-deck-of-six-cards&#34;&gt;A Deck of Six Cards&lt;/h4&gt;
&lt;p&gt;On &lt;strong&gt;First Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;On &lt;strong&gt;Second Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;So, we end-up with &lt;em&gt;card four&lt;/em&gt;. Again, $8 - 2$ cards deck yields the last remaining card &lt;em&gt;sixCardsAnswer&lt;/em&gt; = &lt;em&gt;eightCardsAnswer&lt;/em&gt; - (2 * removedCards) = 8 - (2 * 2) = 4. Here, unlike the case of &lt;em&gt;seven cards deck&lt;/em&gt;, There is no remainder from the first iteration so that we end up with four cards in the second iteration. As two cards are removed from &lt;em&gt;eight cards deck&lt;/em&gt;, we have three cards in second iteration rather than four. &lt;em&gt;card six&lt;/em&gt; here is in an odd position, so it gets thrown away. The last remaining card is &lt;em&gt;card four&lt;/em&gt;. In other words, It seems removing two cards from &lt;em&gt;eight cards deck&lt;/em&gt; shifted our &lt;em&gt;&amp;lt;2, 4, 6, 8&amp;gt;&lt;/em&gt; a position to the right in addition to removing the last card.&lt;/p&gt;
&lt;h4 id=&#34;a-deck-of-five-cards&#34;&gt;A Deck of Five Cards&lt;/h4&gt;
&lt;p&gt;On &lt;strong&gt;First Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As in the case of &lt;em&gt;seven cards deck&lt;/em&gt;, We do not mark &lt;em&gt;card five&lt;/em&gt; in the first iteration. Recall the the last card is not marked whenever we have an odd number of cards in an interation.&lt;/p&gt;
&lt;p&gt;On &lt;strong&gt;Second Iteration&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Again, $8 - 3$ cards deck yields the last remaining card &lt;em&gt;fiveCardsAnswer&lt;/em&gt; = &lt;em&gt;eightCardsAnswer&lt;/em&gt; - (2 * removedCards) = 8 - (2 * 3) = 2. It seems removing two cards shifted &lt;em&gt;&amp;lt;2, 4, 6, 8&amp;gt;&lt;/em&gt; on position to the right, and removing an additional card shifted it another position to the right but with a remainder, namely &lt;em&gt;card five&lt;/em&gt;. So, we get &lt;em&gt;card two&lt;/em&gt; as the answer.&lt;/p&gt;
&lt;h3 id=&#34;magical-formula&#34;&gt;Magical Formula&lt;/h3&gt;
&lt;p&gt;The illustrated reasoning &lt;strong&gt;SEEMS&lt;/strong&gt; to work on not just $2^3 = 8$ but any power of two. For an arbitrary number of deck cards $n$, We find the power of two greater than or equal to $n$, Then compute the answer for $n$ by &lt;em&gt;nCardsAnswer&lt;/em&gt; = &lt;em&gt;Power2CardsAnswer&lt;/em&gt; - (2 * (Power2Cards - nCards)). So, How do find the power of two equal or greater than $n$? Here is a trick: $2^{ceil(log_2(n))}$. So, The final formula would be&lt;/p&gt;
&lt;p&gt;$$2^{ceil(log_2(n))} - (2 \times (2^{ceil(log_2(n))} - n)) = 2 \times (n-2^{ceil(log_2(n))-1})$$&lt;/p&gt;
&lt;h3 id=&#34;accepted-source-code-on-uva&#34;&gt;Accepted Source Code on UVa&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;amp;lt;cstdio&amp;amp;gt;
#include &amp;amp;lt;math.h&amp;amp;gt;

using namespace std;

int main() {
  int n, res;

  scanf(&amp;quot;%d&amp;quot;, &amp;amp;amp;n);

  res = 2*(n-pow(2, (ceil(log2(n))-1)));
  
  if (n == 1) printf(&amp;quot;1\n&amp;quot;);
  else printf(&amp;quot;%d\n&amp;quot;, res);
  
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UVa 120004, Bubble Sort</title>
      <link>https://mostafatouny.github.io/competitive-prog-post/bubble-sort/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:01 +0000</pubDate>
      <guid>https://mostafatouny.github.io/competitive-prog-post/bubble-sort/</guid>
      <description>&lt;h3 id=&#34;restructuring-the-problem-more-conveniently&#34;&gt;Restructuring The Problem, More Conveniently&lt;/h3&gt;
&lt;p&gt;Before tackling a solution, We need to reformulate the given problem. You might consider this a reduction to a form which is more convenient to solve. The problem states We are given an array of size &lt;em&gt;n&lt;/em&gt; whose elements are {1, 2, .., n} and are distinct. That concludes the given array &lt;em&gt;a&lt;/em&gt; is a permutation of {1, 2, .., n}. If we listed all these permuations and computed &lt;em&gt;bubbleCounts&lt;/em&gt; on each, Then taken their average, That would be the answer to UVa&amp;rsquo;s problem. &lt;em&gt;Running findSwaps() infinitely&lt;/em&gt; is just a fancy way of describing our&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: Average &lt;em&gt;bubble counts&lt;/em&gt; of all permutations.&lt;/p&gt;
&lt;h3 id=&#34;observations&#34;&gt;Observations&lt;/h3&gt;
&lt;p&gt;On &lt;strong&gt;n = 2&lt;/strong&gt;,&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;bubbleCount&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;average = $\frac{0+1}{2}$ = $\frac{1}{2}$&lt;/p&gt;
&lt;p&gt;On &lt;strong&gt;n = 3&lt;/strong&gt;,&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;bubbleCount&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;average = $\frac{0+1+1+2+2+6}{6}$ = 2&lt;/p&gt;
&lt;p&gt;On &lt;strong&gt;n = 4&lt;/strong&gt;,&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;bubbleCount&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;average = $\frac{0+1+1+2+2+3+1+2+2+3+3+4+2+3+3+4+4+5+3+4+4+5+5+6}{24}$ = 3&lt;/p&gt;
&lt;h3 id=&#34;symmetry&#34;&gt;Symmetry&lt;/h3&gt;
&lt;p&gt;Consider the case of $n=3$. Notice that the least &lt;em&gt;bubbleCount&lt;/em&gt; is the first one accounting for zero, and the greatest &lt;em&gt;bubbleCount&lt;/em&gt; is the last one accounting for 3. You could see that for each permutation of &lt;em&gt;bubbleCount&lt;/em&gt; 1, There is a corresponding permutation of &lt;em&gt;bubbleCount&lt;/em&gt; 2. The sum of 1 and 2 is also 3 !&lt;/p&gt;
&lt;p&gt;Note also that the corresponding permutation is exactly like the other one but inversed. For instance permutation &lt;em&gt;&amp;lt;3, 1, 2&amp;gt;&lt;/em&gt; is the inversed in order of &lt;em&gt;&amp;lt;2, 1, 3&amp;gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So, we could divide our list of permutations into two halves such that a pair&amp;rsquo;s sum equals $min(bubbleCount) + max(bubbleCount)$. Clearly, There are a total of $n!$ permutations. The number of those pairs is half of total permutations. Hence, total sum of bubble counts is $\frac{n!}{2} \times (min(bubbleCount) + max(bubbleCount))$. Now we divide that total sum on total number of permutations to get the average of all &lt;em&gt;bubbleCounts&lt;/em&gt;. So, The formula is now $\frac{(min(bubbleCount) + max(bubbleCount))}{2}$.  Clearly, least &lt;em&gt;bubbleCount&lt;/em&gt; is always zero, As we have the permutation which is already sorted. What about the greatest one? The worst case is the permutation sorted inversely. In such case, The first iteration, i.e outer loop, accounts for $(n-1)$ bubbles. The second itertaion accounts for $(n-2)$, and so on untill an iteration accounts for exactly one bubble. So, $max(bubbleCount)$ = (n-1) + (n-2) + .. + 1 = $\frac{n \times (n-1)}{2}$. Hence, Our &lt;strong&gt;conjectured&lt;/strong&gt; formula is&lt;/p&gt;
&lt;p&gt;$$\frac{0 + \frac{n(n-1)}{2} }{2} = \frac{n(n-1)}{4}$$&lt;/p&gt;
&lt;p&gt;Check &lt;a href=&#34;https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss#Anecdotes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; for more information about gaussian&amp;rsquo;s famous equation.&lt;/p&gt;
&lt;h3 id=&#34;more-justification-on-symmetry&#34;&gt;More Justification on Symmetry&lt;/h3&gt;
&lt;p&gt;We have shown that least &lt;em&gt;bubbleCount&lt;/em&gt; and greatest &lt;em&gt;bubbleCount&lt;/em&gt; among all permutations are equal to zero and (n-1) + (n-2) + .. + 1, respectively. Let&amp;rsquo;s take a deeper and more general look on why we could divide our permutations list into two halfs whereby each pair&amp;rsquo;s sum is equal to greatest &lt;em&gt;bubbleCount&lt;/em&gt;. That pair&amp;rsquo;s permutations are also inverse of each other.&lt;/p&gt;
&lt;p&gt;For the case of $n=3$, Pick up two permutations which are inverse of each other and try to run &lt;em&gt;bubbleSort&lt;/em&gt; algorithm on both of them. You shall find for a permutation, The bubble counted on some pair of numbers, is not counted in the other corresponding permutation. For instance, permutation &lt;em&gt;&amp;lt;1, 3, 2&amp;gt;&lt;/em&gt; needs one &lt;em&gt;bubble swap&lt;/em&gt; in &lt;em&gt;&amp;lt;3, 2&amp;gt;&lt;/em&gt; pair. For the permutation&amp;rsquo;s inverse &lt;em&gt;&amp;lt;2, 3, 1&amp;gt;&lt;/em&gt;, There&amp;rsquo;s no need to bubble swap &lt;em&gt;&amp;lt;2, 3&amp;gt;&lt;/em&gt; pair. That saves us one bubble swap out of three which is the maximum &lt;em&gt;bubbleCount&lt;/em&gt;. 3 - 1 = 2, The bubbleCount of &lt;em&gt;&amp;lt;2, 3, 1&amp;gt;&lt;/em&gt;. The same applies for any two pairs of permutations which are inverse of each other.&lt;/p&gt;
&lt;h3 id=&#34;accepted-source-code-on-uva&#34;&gt;Accepted Source Code on UVa&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;amp;lt;cstdio&amp;amp;gt;

#define ll long long
#define ull unsigned ll

using namespace std;

bool checkIthBit (int n, int i) {
  if( n &amp;amp;amp; (1 &amp;amp;lt;&amp;amp;lt; i) )
    return true;
  return false;
}


int main() {
  int t, cou = 1;

  scanf(&amp;quot;%d&amp;quot;, &amp;amp;amp;t);

  while (cou &amp;amp;lt;= t) {
    int n;
    ull numerator; int denominator;

    scanf(&amp;quot;%d&amp;quot;, &amp;amp;amp;n);

    numerator = ((ull)n*(ull)(n-1));
    denominator = 4;

    // check if nume is div by 2, and simplify rational form
    for (int i=0; i&amp;amp;lt;2; ++i) {
      if (!checkIthBit(numerator, 0)) {
	numerator = numerator/2;
	denominator = denominator/2;
      }
    }

    if (denominator == 1) printf(&amp;quot;Case %d: %llu\n&amp;quot;, cou, numerator);
    else printf(&amp;quot;Case %d: %llu/%d\n&amp;quot;, cou, numerator, denominator);

    cou++;
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;Many of those who do not appreciate math, think of it as a routine where you just follow a systematic order of operations on numbers. If you are one those, I hope this article changed, at least doubted, how you perceive it. There are a whole deep and elegant adventures still awaiting you if you delved more deeply.
&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>11683 UVa, Laser Sculpture</title>
      <link>https://mostafatouny.github.io/competitive-prog-post/laser-sclupture/</link>
      <pubDate>Fri, 01 May 2020 00:00:01 +0000</pubDate>
      <guid>https://mostafatouny.github.io/competitive-prog-post/laser-sclupture/</guid>
      <description>&lt;h2 id=&#34;proposed-solution-intuitively&#34;&gt;Proposed Solution, Intuitively&lt;/h2&gt;
&lt;p&gt;Before delving into mathematical rigour details, Let me give you an intuitive description of the solution and why it works.&lt;/p&gt;
&lt;p&gt;Note that the laser only sculpts a layer of height equal to one while it is still on. If we wish to sculpts a layer of height 2, Then the laser must be toggled on and off twice. That suggests each layer intended to be sculpted counts on the laser to be turned on after being on off state. What if there are more than one sculpture on the same layer, but separated by couple of unsculpted units? then each sculpture on this layer counts per se.&lt;/p&gt;
&lt;p&gt;Think of the following, where &lt;em&gt;b&lt;/em&gt; indicates a sculpted unit and &lt;em&gt;x&lt;/em&gt; indicates an unsculpted unit. A height equal to three is made here for a simple illustration.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;X_i&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;X_i+1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;if $X_i$ here is $X_1$, then certainly the blank unit counts as a laser is turned on. What about $X_1$, Would the two blank units count each on laser? Considering the fact that a laser could move horizontally while it is still being turned on allows two blanks crossing $X_0$ and $X_1$ to be sculpted on one count. What about the second blank of $X_1$? Clearly, The laser must sculp the blank above it first, So the second blank would be an additional count. Seemingly, We came across a condition here. if a blank in $X_i+1$ came after a blank in $X_i$, Then it should not count but if it came after an unsculpted unit, Then it counts.&lt;/p&gt;
&lt;p&gt;The observation suggests the following. A column which tracks counts on each layer, and the state of the last scanned unit, i.e whether it is sculpted or not. Initially, It would be&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;count&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;unit&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;x&lt;/em&gt; units initialized here are on behalf of the left most outer border. We proceed as follows, For a given &lt;em&gt;X_i&lt;/em&gt; determine units &lt;em&gt;b&lt;/em&gt; sculpted and units &lt;em&gt;x&lt;/em&gt; unsculpted. If a unit is &lt;em&gt;x&lt;/em&gt;, Then leave count as it is. If a unit is &lt;em&gt;b&lt;/em&gt;, Then check the unit before it, If it is &lt;em&gt;b&lt;/em&gt; leave count but if it is &lt;em&gt;x&lt;/em&gt; increment count by one. Afterward, Update unit column with the new unit. Do these steps on all vertical units. Repeat the procedure on each $X_i$. The correct result is the sum of all counts.&lt;/p&gt;
&lt;p&gt;We could furtherly improve. Why do we need to track each layer on a separated &lt;em&gt;count&lt;/em&gt; for it? Instead, We could define only one variable which gets incremented whenever any layer detects a new laser sculpture. In addition, For the unit column, We do not need to check every unit and compare it with the previous one in order to find blank units preceeded by unsculpted x units. max(0, $X_i$ - $X_{i+1}$) would do the trick of finding blank units b in $X_{i+1}$ preceeded by x unit.&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#define usi unsigned short int

int main() {
  usi h, w;
  int X_bef, X_cur, cou;

  while(true) {
    scanf(&amp;quot;%hu %hu&amp;quot;, &amp;amp;h, &amp;amp;w);

    if (h == 0)
      break;

    cou = 0;
    X_bef = h;
    
    for (usi i=0; i&amp;lt;w; ++i) {
      scanf(&amp;quot;%d&amp;quot;, &amp;amp;X_cur);
      cou = cou + std::max(0, X_bef-X_cur);
      X_bef = X_cur;
    }

    printf(&amp;quot;%d\n&amp;quot;, cou);
  }
  
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;formal-logic&#34;&gt;Formal Logic&lt;/h2&gt;
&lt;p&gt;Here comes the formal-logic based proof of our algorithm&amp;rsquo;s correctness. Kindly, note that it might still be flawed. However, If it is not, Then we guarantee the algorithm to yield the correct answer without any bugs or errors. Anyway, Before getting into the proof, We need to rigoursly model the problem of &lt;em&gt;Laser Sculpture - 11683&lt;/em&gt;. Those rigor definitions and constraints are derived from our understanding of the problem.&lt;/p&gt;
&lt;h3 id=&#34;definitions&#34;&gt;Definitions&lt;/h3&gt;
&lt;p&gt;For the following, We assume $h$, $w$ $\in \mathcal{N}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Board&lt;/strong&gt;: A 2d-array-alike corresponding to overall units. board is $b = (h \times w)$, units $u_{i,j}$ indexed (labeled) by a cartesian product of board&amp;rsquo;s height and width.&lt;/p&gt;
&lt;p&gt;$X_0$: We define an imaginary height equal to $h$ of a given board. It serves on behalf the left most outer border for the first iteration of our algorithm.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sculpture set on board&lt;/strong&gt;: A family of sets where each set is the set of units sculpted by the laser while it is still on. The sculpture set is $S = ${$ S_1, S_2, .., S_k$} such that $\cup S \subseteq b$, $S_i \cap S_j = \phi$ for any distinct i and j, $S_i \neq \phi$ for any i. That says sculptures are subset of the original board units, no two sculptures are intersecting, and there&amp;rsquo;s no empty sculpture. That conforms with our understanding that a unit cannot be shot twice by a laser, and a laser is not going to be turned on without sculpting some unit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Top-first&lt;/strong&gt;: That is a condition which ensures no sculpture occurs on some layer before the layer above it is sculptured. For any $S_q \in S$, $\forall u_{i,j} \in S_q( ${$ u_{x,j} \in b | x &amp;lt; i $}$ \subseteq S_{q-1} \cup S_{q-2} \cup .. \cup S_{1} )$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;One-row&lt;/strong&gt;: That is a condition which ensures a continuous row of units are sculptured at once, not sculptured on multiple times in which the laser is turned on and off multiple times as well. For any two distinct $S_k$ and $S_q$, $\neg( \exists j_0  \exists j_1, u_{i_0,j_0} \in S_q \wedge u_{i_1,j_1} \in S_k \wedge j_1=j_0+1)$ for some $u_{i_0,j_0}$ and $u_{i_1,j_1}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Uniqueness&lt;/strong&gt;: It is assumed that there is a unique number of times for the laser to be toggled on and off regardless of of the &lt;em&gt;sculpture set&lt;/em&gt;. In other words, Even if there are two possible different sculptures which achieve the desired X&amp;rsquo;s, The number of times the laser needs to be toggled on and off is the same.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Existince of a Solution&lt;/strong&gt;: It is assumed that given height $h$, and width $w$ of the whole board $b$, and given heights $X_1$, $X_2$, .., $X_w$ of position $i$ in the board, There exists a &lt;em&gt;sculpture set&lt;/em&gt; $S$ &lt;em&gt;on board&lt;/em&gt; $b$ such that $b - S = \cup_{p \in 1, 2, .., w }$ {$ u_{i,p} \in b $} whereby each set {$ u_{i,p_0} \in b $} has a cardinality of $X_{p_0}$. In other words, The set yielded from subtracting the board from sculpture set is composed of units conforming to desired $X$&amp;rsquo;s heights.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Principal Problem Statement&lt;/strong&gt; (finally): Given a board $b_{h \times w}$ of height $h$ and width $w \in \mathcal{Z}^+$, and given heights $X_1$, $X_2$, .., $X_w$, The cardinality of $\textit{sculpture set on board}$ $b$ is equal to $\Sigma_{i=0}^{w-1}min(0, X_i-X_{i+1})$&lt;/p&gt;
&lt;h3 id=&#34;proof&#34;&gt;Proof&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;: For $b-S$, where $b$ is a board of height $h$ and width $w \geq 2$ and $S$ is a &lt;em&gt;sculpture set on&lt;/em&gt; $b$ conforming to given heights of unsculpted units of last two board columns $X_{w-1}$ and $X_w$,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt; if $X_{w} &amp;lt; i \leq X_{w-1}$, a unit $u_{i, w}$ is contained in some $S_k$ and no other unit is in $S_k$. That is, for some $S_k \in S$, $S_k = ${$ u_{i, w} $}.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)&lt;/strong&gt; if $X_{w} \leq X_{w-1} &amp;lt; i$, a unit $u_{i, w}$ is contained in some $S_k$ which is per se contains an element of $\textit{board}$ $b^{&amp;rsquo;} = b_{h \times w-1}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) Solution&lt;/strong&gt;: Assume $X_{w} &amp;lt; i \leq X_{w-1}$. Clearly, unit $u_{i, w} \in \cup S$, As it is above height of column $X_w$. So, $u_{i, w} \in S_k$ for some $S_k \in S$. $S_k$ does not contain other units  which are above, below, or diagonal to $u_{i, w}$. Otherwise, $\textit{top first}$ or $\textit{one row}$ conditions shall be violated. Also, no other units are left to $u_{i, w}$ in $S_k$, As $i \leq X_{w-1}$. Hence, $S_k = ${$ u_{i, w} $}.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) Solution&lt;/strong&gt;: Assume $X_{w} \leq X_{w-1} &amp;lt; i$. Similar to $\textbf{(1) solution}$, unit $u_{i, w} \in \cup S$, As it is above height of column $X_w$. So, $u_{i, w} \in S_k$ for some $S_k \in S$. $S_k$ does not contain other units  which are above, below, or diagonal to $u_{i, w}$. Otherwise, $\textit{top first}$ or $\textit{one row}$ conditions shall be violated. However, unlike $\textbf{(1) solution}$, Nothing precludes a unit left to $u_{i, w}$ to be contained in $S_k$, As $X_{w-1} &amp;lt; i$. On the contrary, if $S_k = ${$ u_{i, w} $} then $\textit{one row}$ condition shall be violated as two sculptures are going to be on the same row without any non-blank separator between them. Through $\textit{proof by contradiction}$, $S_k \neq ${$ u_{i, w} $}. Hence, there are some units $u \in S_k$. Since units from all directions are excluded, except only the left direction, $u_{i, w-1} \in S_k$, which is clearly a unit of $\textit{board}$ $b^{&amp;rsquo;} = b_{h \times w-1}$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Corollary&lt;/strong&gt;: From &lt;strong&gt;Lemma (1)&lt;/strong&gt;, Obviously, $S_k$ is not an element of $\textit{sculpture set on board}$ $b^{&amp;rsquo;} = b_{h \times w-1}$ due to the fact that $S_k \not\subseteq b^{&amp;rsquo;}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem Statement&lt;/strong&gt; (main proof): First we re-write the statement defined above in a more convenient form for induction proof.&lt;/p&gt;
&lt;p&gt;for $w \in \mathcal{Z}^+$, &lt;br&gt;
Given $h \in \mathcal{N}$, and heights $X_1$, $X_2$, .., $X_w$, sculpture set on board $b_{h \times w}$ has a cardinality of $\Sigma_{i=0}^{w-1}min(0, X_i-X_{i+1})$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;: &lt;br&gt;
base, for $w = 1$, &lt;br&gt;
Assume we are given $h \in \mathcal{N}$, and heights $X_1$, $X_2$, .., $X_w$. A board $b_{h \times w}$ has a sculpture set on it, by assumption.
Assume $X_{1} &amp;lt; i$. By definition $X_0 = h$. So, $X_1 &amp;lt; i &amp;lt; X_0$. via $\textbf{Lemma (1)}$, each unit $u_{i, 1}$ is contained in some $S_k$ and no other unit is in $S_k$. In other words, cardinality of {$ u_{i, 1} | X_1 &amp;lt; i $} is equal to $S$, the sculpture set on board $b$. clearly, it is also equal to ($X_0$ - $X_1$). since $X_0 \geq X_1$, ($X_0$ - $X_1$) = min(0, $X_0$ - $X_1$) which justifies our problem statement.&lt;/p&gt;
&lt;p&gt;induction hypothesis, for $w^{&amp;rsquo;} \in \mathcal{Z}^+$ we assume problem statement&amp;rsquo;s validity.&lt;/p&gt;
&lt;p&gt;induction step, for $w = w^{&amp;rsquo;}+1$, &lt;br&gt;
Assume we are given $h \in \mathcal{N}$, and heights $X_1$, $X_2$, .., $X_w$. A board $b_{h \times w}$ has a sculpture set on it, by assumption.
Assume $X_{w} &amp;lt; i$. &lt;br&gt;
$\textbf{case 1}$: if it is the case the $i \leq X_{w-1}$, then similarly to base case, each unit $u_{i, w}$ counts a new element in $S$, the sculpture set on board $b$. Recall from $\textbf{corollary}$ that those are not in $S^{&amp;rsquo;}$, sculpture set on board $b^{&amp;rsquo;}&lt;em&gt;{h \times w-1}$. cardinality of units $u&lt;/em&gt;{i, w}$ are clearly equal to $X_{w-1} - X_{w}$. Also, It is clear that $X_{w-1} &amp;gt; X_{w}$, Hence, $X_{w-1} - X_{w}$ = $min(0, X_{w-1} - X_{w})$.&lt;/p&gt;
&lt;p&gt;$\textbf{case 2}$: But if $i &amp;gt; X_{w-1}$, then by $\textbf{lemma (1)}$ each unit $u_{i, w}$ is contained in some $S_k$ which is per se an element of $S^{&amp;rsquo;}$, the sculpture set on board $b^{&amp;rsquo;}&lt;em&gt;{h \times w-1}$. Hence, Those units do not contribute new counts to $S$, the sculpture set on board $b&lt;/em&gt;{h \times w}$ than counted in $S^{&amp;rsquo;}$. On the other hand, It is clear that $X_{w-1} \leq X_{w}$, So $X_{w-1} - X_{w} \leq 0$. So, $min(0, X_{w-1} - X_{w}) = 0$ which conforms with what we just proved that no new sculptures are added than those in board $b^{&amp;rsquo;}$.&lt;/p&gt;
&lt;p&gt;From &lt;strong&gt;case 1&lt;/strong&gt; and &lt;strong&gt;case 2&lt;/strong&gt;, $min(0, X_{w-1} - X_{w})$ is equal to new sculptures not in sculpture set $S^{&amp;rsquo;}$ on board $b^{&amp;rsquo;}&lt;em&gt;{h \times w-1}$. Therefore, cardinality of set $S$ is equal to cardinality set $S^{&amp;rsquo;}$ plus $min(0, X&lt;/em&gt;{w-1} - X_{w})$. via induction hypothesis, cardinality of $S^{&amp;rsquo;} = \Sigma_{i=0}^{w^{&amp;rsquo;}-1}min(0, X_i-X_{i+1})$. So, cardinality of $S = \Sigma_{i=0}^{w-2}min(0, X_i-X_{i+1}) + min(0, X_{w-1}-X_{w}) = \Sigma_{i=0}^{w-1}min(0, X_i-X_{i+1})$
QED&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>573 UVa, The Snail</title>
      <link>https://mostafatouny.github.io/competitive-prog-post/the-snail/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:01 +0000</pubDate>
      <guid>https://mostafatouny.github.io/competitive-prog-post/the-snail/</guid>
      <description>&lt;h3 id=&#34;my-proposed-solution&#34;&gt;My Proposed Solution&lt;/h3&gt;
&lt;p&gt;Probably, You thought of the straight forward solution of just simulating the height reached by the snail day by day till some condition applies. So, your computation would look like
$$ (u_1 - fatigue_1 - d_1) + (u_2 - fatigue_2 - d_2) + .. + (u_n - fatigue_n - d_n) $$&lt;/p&gt;
&lt;p&gt;In this solution I claim determining whether the snail succeeded or failed could be done in $O(1)$ !! (that discovery was a surprise for me, as well). In a nutshell, We shall derive a formula which computes the snail&amp;rsquo;s height on any given day. Then we find the day in which the snail&amp;rsquo;s height is at its peak. By plugging in that day in the formula, we compute the height peak of the snail. if that height peak is greater than $h$, the weight of the well, then we conclude the snail at some point exceeds the well. If the height peak is equal or less than $h$, Then we conclude the snail shall not exceed the well.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s begin by finding the formula. I noticed a pattern. That computation you probably first thought of is exactly like
$$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - (fatigue_1 + fatigue_2 + .. + fatigue_n) $$
$$ = (u \times i) - (d \times i) - (\text{total fatigue up to day i})$$
So, instead of looping in a complexity of $\omega(n)$, One equation could achieve the same result in a complexity of $O(1)$. The first and second parts are obvious, but how do we find the third one? First, Assume $f=1$, then $$fatigue_1=0.01 * u * 1, fatigue_2=0.01 * u * 2 , .. , fatigue_n=0.01 * u * i$$
As each day we increase fatigue by $f$, day number $i$ should be equal to $i$ times $f$. $0.01$ and $u$ are common factors, so we could re-write this as
$$(0.01*u)(1 + 2 + .. + i)$$
the right part of the equation is where the magic happens. Friedrich Gauss, The legendary mathematician discovered that it is equal to
$$\frac{n(n+1)}{2}$$
He made it when he was a kid as his teacher tried to preoccupy his time with tedious math calculation! read his story &lt;a href=&#34;https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss#Anecdotes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.
So, the final pattern looks like this
$$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - \frac{n(n+1)}{2} $$
So far, that equation applies when $f=1$ but the The &lt;em&gt;Snail - 573&lt;/em&gt; problem asks for a general value of $f$. Let me get you through the proof of Guassian&amp;rsquo;s equation briefly, and see how could we generalize it to a general value of $f$. Assume we wish to calculate $2 \times (1+2+ .. + n)$. That could be re-written as
$$ 1 + 2 + .. + n $$
$$ + $$
$$ n + (n-1) + .. + 1 $$
Try to interpret both of these equations as $n$ columns of two rows. The first column is $1+n$, second is $2+(n-1)$, .. , nth day is $n+1$. All of the $n$ columns are equal to $n+1$. Therefore
$$2 \times (1+2+ .. + n) = n(n+1)$$
Divide both sides by two, and the proof of Guassian&amp;rsquo;s equation is done. QED. Now, instead of incrementing by one, the value of %f%, assume %f=x% where x is an arbitrary value. Let&amp;rsquo;s try to re-apply the proof again. This is time we calculate $2 \times (x+2x+ .. + nx)$. We re-write it as
$$ x + 2x + .. + nx $$
$$ + $$
$$ nx + (n-1)x + .. + x $$
Similarly, $(x+nx) + (2x+(n-1)x) + .. + (nx+x) = n(nx+x)$, As each term of the n terms is equal to $(x+nx)$. Dividing by two yields us the final magical equation as follows
$$ (u \times n) - (d \times n) - \frac{n(nx+x)}{2} $$
That justifies &lt;em&gt;totalHeight&lt;/em&gt; and &lt;em&gt;fOnDay&lt;/em&gt; functions in my source code (see them below). So now, we could find the height of the snail at any day by just plugging-in a formula in a complexity of $O(1)$.&lt;/p&gt;
&lt;p&gt;How are we going to use the formula we just derived? Are we going to loop on each day, applying the formula then checking for some conditions? That would account for complexity of $\omega(n)$ which saves us nearly nothing. As I promised you before, We find the day in which the snail reaches its peak. Then we plug-in that day in the formula we just derived to find the greatest possible height the snail ever reached. Finally, we compare that with $h$ to reach our conclusion of whether the snail succeeded.&lt;/p&gt;
&lt;p&gt;Take a look at the following equation. Recall that $u$, $d$ and $f$ are given in &lt;em&gt;The Snail - 573&lt;/em&gt; problem.
$$ (i*f)*u = (u-d) $$
So, The only unknown is $i$ which could be easily computed. What we are trying to find out here is the day $i$ for which &lt;em&gt;fatigue&lt;/em&gt; is equal to the total increment the snail achieves. in other words, we are looking for the day in which fatigue totally cancels out any upwards increment. The upwards increase of $u-d$ keeps decaying due to fatigue till no possible upwards increment is possible. Hence, day $i$ in the above equation is the day in which the snail reaches its peak! That justifies my function &lt;em&gt;dayOfNonIncrease&lt;/em&gt; in the source code below. Now, we could find out the maximum possible height reached by the snail.&lt;/p&gt;
&lt;p&gt;At this point, I delivered my promise that we could find out whether the snail failed or succeeded in $O(1)$. &lt;em&gt;The Snail&lt;/em&gt; problem asks for more than that, namely, the day in which the snail succeeded or failed.&lt;/p&gt;
&lt;p&gt;There is a catch in our approach. According to &lt;em&gt;The Snail - 573&lt;/em&gt; problem, the fatigue cannot result in negative upwards increment, As stated &lt;em&gt;The snail never climbs a negative distance&lt;/em&gt;. Our formula does not take into its account that the max possible fatigue is 100%. Nonetheless, That would not disrupt we could find out whether the snail succeeded or failed in $O(1)$ as illustrated above. That could be clearly seen as we do not need to compute up to days in which fatigue exceeds 100%.&lt;/p&gt;
&lt;p&gt;However, We are going to rectify that limitation in order to complete solving &lt;em&gt;The Snail&lt;/em&gt; problem. We divide the computation of total height in a given day by two parts. The first part is computed exactly as mentioned before and applies on a day $i$ which is equal or less than the day &lt;em&gt;maxFatDay&lt;/em&gt; in which fatigue is 100%. the second part handles days in which fatigue exceeds 100%. For the second part, total height could be clearly found by $(i-maxFatDay) \times d$, As fatigue would totally cancel out upwards climb. In other words, In these days, the snail would just be dropping down without any climb. By summing both of these parts we could find out the height of any given day, Even if that day is beyond maxFatDay in which fatigue reached its maximum. Note that &lt;em&gt;maxFatDay&lt;/em&gt; might not be exactly 100% as $f$ might not divides 100. In this case, It would be the maximum fatigue equal or less than 100%. That justifies my function &lt;em&gt;totalHeightAnyDay&lt;/em&gt; in source code below.&lt;/p&gt;
&lt;p&gt;So far, We are still computing in a complexity of $O(1)$ !! The last scene is finding the day the snail first exceeded $h$ or dropped to a negative height. Unfortunately, I could not find a way but to keep looping, beginning from the day of snail reaching its peak, till its height is either below $h$ or negative. That is the last part of my source code below. Could you improve upon this solution to maintain a complexity of $\omega(1)$?&lt;/p&gt;
&lt;h3 id=&#34;source-code&#34;&gt;Source Code&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;

// total u&#39;s from day 1 to day i
int uOnDay(int u, int i) {
  return u*i;
}

// total d&#39;s from day 1 to day i
int dOnDay(int d, int i) {
  return d*i;
}

// total fatigue percentage from day 1 to day i
// it is a generalization of gaussian&#39;s famous equation n(n+1)/2 = 1 + 2 + .. + n
float fOnDay(float f, int i) {
  return (i*((i*f)+f))/2;
}

// we find day i such that
// i * (fPercent*u) = u - d
int dayOfNonIncrease(int u, int d, float fPercent) {
  float res = (float)(u-d)/(float)(fPercent*u);
  return std::max(int(res), 0);
}

// we find day i such that
// i * fPercent = 1
int findDayOfMaxF(float fPercent) {
  int res = (float)1/fPercent;
  return res;
}

// height at day i, in case no fatigue is more than 100% from day 1 up to day i
// totalF is total fatigue percentage from day 1 up to i
float totalHeight(int u, int d, int i, float totalF) {
  return (float)uOnDay(u, i) - (float)dOnDay(d, i) - totalF;
}

// height at day i. no constraints here
float totalHeightAnyDay(int u, int d, float fPercent, int peakHeightDay, int dayOfMaxFat, int i) {
  float totalF, tot;
  
  if (i &amp;lt;= dayOfMaxFat) {
    totalF = (float)u*fOnDay(fPercent, i-1);
    tot = totalHeight(u, d, i, totalF);
    return tot;
  }
  else {
    totalF = (float)u*fOnDay(fPercent, dayOfMaxFat-1);
    tot = totalHeight(u, d, dayOfMaxFat, totalF);
    int daysRng = i - dayOfMaxFat;

    // after dayOfMaxFat, fatigue would be more than 100% if same function is applied
    // max fatigue possible is 100%
    totalF = ((float)u*1)*daysRng;
    tot += totalHeight(u, d, daysRng, totalF);
    
    return tot;
  }
}

int main() {
  int h, u, d, f;
  
  while(true) {

    scanf(&amp;quot;%d %d %d %d&amp;quot;, &amp;amp;h, &amp;amp;u, &amp;amp;d, &amp;amp;f);
    if (h==0)
      break;

    // f as a percentage
    float fPercent = (float)f/(float)100;
    // day in which snail reached its peak
    int peakHeightDay = dayOfNonIncrease(u, d, fPercent);
    peakHeightDay += 1;
    // day in which snail fatigue reached its highest possible value
    int dayOfMaxFat = findDayOfMaxF(fPercent);
    dayOfMaxFat += 1;

    // calculate height at day of maximum possible height
    float peakHeight =  totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, peakHeightDay) + d;


    // if peak is greater than h, then the snail succeeded
    // if not, then the snail shall never exceed h
    
    float tot;
    if (peakHeight &amp;gt; h) {
      int i=peakHeightDay;
      // keep moving days backwards till the snail&#39;s height is less than h
      do {
	i--;
	if (i&amp;lt;1)
	  break;
	tot = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, i) + d;
      }
      while(tot &amp;gt; h);

      // the day after catched day above, is the one in which snail first exceeded h
      printf(&amp;quot;success on day %d\n&amp;quot;, i+1);
    }
    else {
      int i = peakHeightDay;
      // keep moving days upwards till the snail&#39;s height is negative
      do {
	tot = totalHeightAnyDay(u, d, fPercent, peakHeightDay, dayOfMaxFat, i);
	i++;
      }
      while(tot &amp;gt;= 0);

      // the day catched above is greater than the day in which snail&#39;s height became negative by one
      printf(&amp;quot;failure on day %d\n&amp;quot;, i-1);
    }
    
  }
  
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
