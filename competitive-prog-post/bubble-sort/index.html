<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UVa 120004, Bubble Sort | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="Math is not routine calculations at all."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/competitive-prog-post/bubble-sort/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/competitive-prog-post/bubble-sort/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="UVa 120004, Bubble Sort"><meta property="og:description" content="Math is not routine calculations at all."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/competitive-prog-post/bubble-sort/"><meta property="article:section" content="competitive-prog-post"><meta property="article:published_time" content="2020-06-11T00:00:01+00:00"><meta property="article:modified_time" content="2020-06-11T00:00:01+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="UVa 120004, Bubble Sort"><meta name=twitter:description content="Math is not routine calculations at all."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Competitive Programming","item":"https://mostafatouny.github.io/competitive-prog-post/"},{"@type":"ListItem","position":2,"name":"UVa 120004, Bubble Sort","item":"https://mostafatouny.github.io/competitive-prog-post/bubble-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UVa 120004, Bubble Sort","name":"UVa 120004, Bubble Sort","description":"Math is not routine calculations at all.","keywords":[],"articleBody":"Restructuring The Problem, More Conveniently Before tackling a solution, We need to reformulate the given problem. You might consider this a reduction to a form which is more convenient to solve. The problem states We are given an array of size n whose elements are {1, 2, .., n} and are distinct. That concludes the given array a is a permutation of {1, 2, .., n}. If we listed all these permuations and computed bubbleCounts on each, Then taken their average, That would be the answer to UVa’s problem. Running findSwaps() infinitely is just a fancy way of describing our\nDefinition: Average bubble counts of all permutations.\nObservations On n = 2,\nbubbleCount 1 2 0 2 1 1 average = $\\frac{0+1}{2}$ = $\\frac{1}{2}$\nOn n = 3,\nbubbleCount 1 2 3 0 1 3 2 1 2 1 3 1 2 3 1 2 3 1 2 2 3 2 1 3 average = $\\frac{0+1+1+2+2+6}{6}$ = 2\nOn n = 4,\nbubbleCount 1 2 3 4 0 1 2 4 3 1 1 3 2 4 1 1 3 4 2 2 1 4 2 3 2 1 4 3 2 3 2 1 3 4 1 2 1 4 3 2 2 3 1 4 2 2 3 4 1 3 2 4 1 3 3 2 4 3 1 4 3 1 2 4 2 3 1 4 2 3 3 2 1 4 3 3 2 4 1 4 3 4 1 2 4 3 4 2 1 5 4 1 2 3 3 4 1 3 2 4 4 2 1 3 4 4 2 3 1 5 4 3 1 2 5 4 3 2 1 6 average = $\\frac{0+1+1+2+2+3+1+2+2+3+3+4+2+3+3+4+4+5+3+4+4+5+5+6}{24}$ = 3\nSymmetry Consider the case of $n=3$. Notice that the least bubbleCount is the first one accounting for zero, and the greatest bubbleCount is the last one accounting for 3. You could see that for each permutation of bubbleCount 1, There is a corresponding permutation of bubbleCount 2. The sum of 1 and 2 is also 3 !\nNote also that the corresponding permutation is exactly like the other one but inversed. For instance permutation \u003c3, 1, 2\u003e is the inversed in order of \u003c2, 1, 3\u003e.\nSo, we could divide our list of permutations into two halves such that a pair’s sum equals $min(bubbleCount) + max(bubbleCount)$. Clearly, There are a total of $n!$ permutations. The number of those pairs is half of total permutations. Hence, total sum of bubble counts is $\\frac{n!}{2} \\times (min(bubbleCount) + max(bubbleCount))$. Now we divide that total sum on total number of permutations to get the average of all bubbleCounts. So, The formula is now $\\frac{(min(bubbleCount) + max(bubbleCount))}{2}$. Clearly, least bubbleCount is always zero, As we have the permutation which is already sorted. What about the greatest one? The worst case is the permutation sorted inversely. In such case, The first iteration, i.e outer loop, accounts for $(n-1)$ bubbles. The second itertaion accounts for $(n-2)$, and so on untill an iteration accounts for exactly one bubble. So, $max(bubbleCount)$ = (n-1) + (n-2) + .. + 1 = $\\frac{n \\times (n-1)}{2}$. Hence, Our conjectured formula is\n$$\\frac{0 + \\frac{n(n-1)}{2} }{2} = \\frac{n(n-1)}{4}$$Check this for more information about gaussian’s famous equation.\nMore Justification on Symmetry We have shown that least bubbleCount and greatest bubbleCount among all permutations are equal to zero and (n-1) + (n-2) + .. + 1, respectively. Let’s take a deeper and more general look on why we could divide our permutations list into two halfs whereby each pair’s sum is equal to greatest bubbleCount. That pair’s permutations are also inverse of each other.\nFor the case of $n=3$, Pick up two permutations which are inverse of each other and try to run bubbleSort algorithm on both of them. You shall find for a permutation, The bubble counted on some pair of numbers, is not counted in the other corresponding permutation. For instance, permutation \u003c1, 3, 2\u003e needs one bubble swap in \u003c3, 2\u003e pair. For the permutation’s inverse \u003c2, 3, 1\u003e, There’s no need to bubble swap \u003c2, 3\u003e pair. That saves us one bubble swap out of three which is the maximum bubbleCount. 3 - 1 = 2, The bubbleCount of \u003c2, 3, 1\u003e. The same applies for any two pairs of permutations which are inverse of each other.\nAccepted Source Code on UVa #include \u0026lt;cstdio\u0026gt; #define ll long long #define ull unsigned ll using namespace std; bool checkIthBit (int n, int i) { if( n \u0026amp; (1 \u0026lt;\u0026lt; i) ) return true; return false; } int main() { int t, cou = 1; scanf(\"%d\", \u0026amp;t); while (cou \u0026lt;= t) { int n; ull numerator; int denominator; scanf(\"%d\", \u0026amp;n); numerator = ((ull)n*(ull)(n-1)); denominator = 4; // check if nume is div by 2, and simplify rational form for (int i=0; i\u0026lt;2; ++i) { if (!checkIthBit(numerator, 0)) { numerator = numerator/2; denominator = denominator/2; } } if (denominator == 1) printf(\"Case %d: %llu\\n\", cou, numerator); else printf(\"Case %d: %llu/%d\\n\", cou, numerator, denominator); cou++; } return 0; } Many of those who do not appreciate math, think of it as a routine where you just follow a systematic order of operations on numbers. If you are one those, I hope this article changed, at least doubted, how you perceive it. There are a whole deep and elegant adventures still awaiting you if you delved more deeply. ","wordCount":"899","inLanguage":"en","datePublished":"2020-06-11T00:00:01Z","dateModified":"2020-06-11T00:00:01Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/competitive-prog-post/bubble-sort/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">UVa 120004, Bubble Sort</h1><div class=post-meta><span title='2020-06-11 00:00:01 +0000 UTC'>June 11, 2020</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#restructuring-the-problem-more-conveniently aria-label="Restructuring The Problem, More Conveniently">Restructuring The Problem, More Conveniently</a></li><li><a href=#observations aria-label=Observations>Observations</a></li><li><a href=#symmetry aria-label=Symmetry>Symmetry</a></li><li><a href=#more-justification-on-symmetry aria-label="More Justification on Symmetry">More Justification on Symmetry</a></li><li><a href=#accepted-source-code-on-uva aria-label="Accepted Source Code on UVa">Accepted Source Code on UVa</a></li></ul></div></details></div><div class=post-content><h3 id=restructuring-the-problem-more-conveniently>Restructuring The Problem, More Conveniently<a hidden class=anchor aria-hidden=true href=#restructuring-the-problem-more-conveniently>#</a></h3><p>Before tackling a solution, We need to reformulate the given problem. You might consider this a reduction to a form which is more convenient to solve. The problem states We are given an array of size <em>n</em> whose elements are {1, 2, .., n} and are distinct. That concludes the given array <em>a</em> is a permutation of {1, 2, .., n}. If we listed all these permuations and computed <em>bubbleCounts</em> on each, Then taken their average, That would be the answer to UVa&rsquo;s problem. <em>Running findSwaps() infinitely</em> is just a fancy way of describing our</p><p><strong>Definition</strong>: Average <em>bubble counts</em> of all permutations.</p><h3 id=observations>Observations<a hidden class=anchor aria-hidden=true href=#observations>#</a></h3><p>On <strong>n = 2</strong>,</p><table><thead><tr><th></th><th></th><th style=text-align:center>bubbleCount</th></tr></thead><tbody><tr><td>1</td><td>2</td><td style=text-align:center>0</td></tr><tr><td>2</td><td>1</td><td style=text-align:center>1</td></tr></tbody></table><p>average = $\frac{0+1}{2}$ = $\frac{1}{2}$</p><p>On <strong>n = 3</strong>,</p><table><thead><tr><th></th><th></th><th></th><th style=text-align:center>bubbleCount</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td style=text-align:center>0</td></tr><tr><td>1</td><td>3</td><td>2</td><td style=text-align:center>1</td></tr><tr><td>2</td><td>1</td><td>3</td><td style=text-align:center>1</td></tr><tr><td>2</td><td>3</td><td>1</td><td style=text-align:center>2</td></tr><tr><td>3</td><td>1</td><td>2</td><td style=text-align:center>2</td></tr><tr><td>3</td><td>2</td><td>1</td><td style=text-align:center>3</td></tr></tbody></table><p>average = $\frac{0+1+1+2+2+6}{6}$ = 2</p><p>On <strong>n = 4</strong>,</p><table><thead><tr><th></th><th></th><th></th><th></th><th style=text-align:center>bubbleCount</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td style=text-align:center>0</td></tr><tr><td>1</td><td>2</td><td>4</td><td>3</td><td style=text-align:center>1</td></tr><tr><td>1</td><td>3</td><td>2</td><td>4</td><td style=text-align:center>1</td></tr><tr><td>1</td><td>3</td><td>4</td><td>2</td><td style=text-align:center>2</td></tr><tr><td>1</td><td>4</td><td>2</td><td>3</td><td style=text-align:center>2</td></tr><tr><td>1</td><td>4</td><td>3</td><td>2</td><td style=text-align:center>3</td></tr><tr><td>2</td><td>1</td><td>3</td><td>4</td><td style=text-align:center>1</td></tr><tr><td>2</td><td>1</td><td>4</td><td>3</td><td style=text-align:center>2</td></tr><tr><td>2</td><td>3</td><td>1</td><td>4</td><td style=text-align:center>2</td></tr><tr><td>2</td><td>3</td><td>4</td><td>1</td><td style=text-align:center>3</td></tr><tr><td>2</td><td>4</td><td>1</td><td>3</td><td style=text-align:center>3</td></tr><tr><td>2</td><td>4</td><td>3</td><td>1</td><td style=text-align:center>4</td></tr><tr><td>3</td><td>1</td><td>2</td><td>4</td><td style=text-align:center>2</td></tr><tr><td>3</td><td>1</td><td>4</td><td>2</td><td style=text-align:center>3</td></tr><tr><td>3</td><td>2</td><td>1</td><td>4</td><td style=text-align:center>3</td></tr><tr><td>3</td><td>2</td><td>4</td><td>1</td><td style=text-align:center>4</td></tr><tr><td>3</td><td>4</td><td>1</td><td>2</td><td style=text-align:center>4</td></tr><tr><td>3</td><td>4</td><td>2</td><td>1</td><td style=text-align:center>5</td></tr><tr><td>4</td><td>1</td><td>2</td><td>3</td><td style=text-align:center>3</td></tr><tr><td>4</td><td>1</td><td>3</td><td>2</td><td style=text-align:center>4</td></tr><tr><td>4</td><td>2</td><td>1</td><td>3</td><td style=text-align:center>4</td></tr><tr><td>4</td><td>2</td><td>3</td><td>1</td><td style=text-align:center>5</td></tr><tr><td>4</td><td>3</td><td>1</td><td>2</td><td style=text-align:center>5</td></tr><tr><td>4</td><td>3</td><td>2</td><td>1</td><td style=text-align:center>6</td></tr></tbody></table><p>average = $\frac{0+1+1+2+2+3+1+2+2+3+3+4+2+3+3+4+4+5+3+4+4+5+5+6}{24}$ = 3</p><h3 id=symmetry>Symmetry<a hidden class=anchor aria-hidden=true href=#symmetry>#</a></h3><p>Consider the case of $n=3$. Notice that the least <em>bubbleCount</em> is the first one accounting for zero, and the greatest <em>bubbleCount</em> is the last one accounting for 3. You could see that for each permutation of <em>bubbleCount</em> 1, There is a corresponding permutation of <em>bubbleCount</em> 2. The sum of 1 and 2 is also 3 !</p><p>Note also that the corresponding permutation is exactly like the other one but inversed. For instance permutation <em>&lt;3, 1, 2></em> is the inversed in order of <em>&lt;2, 1, 3></em>.</p><p>So, we could divide our list of permutations into two halves such that a pair&rsquo;s sum equals $min(bubbleCount) + max(bubbleCount)$. Clearly, There are a total of $n!$ permutations. The number of those pairs is half of total permutations. Hence, total sum of bubble counts is $\frac{n!}{2} \times (min(bubbleCount) + max(bubbleCount))$. Now we divide that total sum on total number of permutations to get the average of all <em>bubbleCounts</em>. So, The formula is now $\frac{(min(bubbleCount) + max(bubbleCount))}{2}$. Clearly, least <em>bubbleCount</em> is always zero, As we have the permutation which is already sorted. What about the greatest one? The worst case is the permutation sorted inversely. In such case, The first iteration, i.e outer loop, accounts for $(n-1)$ bubbles. The second itertaion accounts for $(n-2)$, and so on untill an iteration accounts for exactly one bubble. So, $max(bubbleCount)$ = (n-1) + (n-2) + .. + 1 = $\frac{n \times (n-1)}{2}$. Hence, Our <strong>conjectured</strong> formula is</p>$$\frac{0 + \frac{n(n-1)}{2} }{2} = \frac{n(n-1)}{4}$$<p>Check <a href=https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss#Anecdotes>this</a> for more information about gaussian&rsquo;s famous equation.</p><h3 id=more-justification-on-symmetry>More Justification on Symmetry<a hidden class=anchor aria-hidden=true href=#more-justification-on-symmetry>#</a></h3><p>We have shown that least <em>bubbleCount</em> and greatest <em>bubbleCount</em> among all permutations are equal to zero and (n-1) + (n-2) + .. + 1, respectively. Let&rsquo;s take a deeper and more general look on why we could divide our permutations list into two halfs whereby each pair&rsquo;s sum is equal to greatest <em>bubbleCount</em>. That pair&rsquo;s permutations are also inverse of each other.</p><p>For the case of $n=3$, Pick up two permutations which are inverse of each other and try to run <em>bubbleSort</em> algorithm on both of them. You shall find for a permutation, The bubble counted on some pair of numbers, is not counted in the other corresponding permutation. For instance, permutation <em>&lt;1, 3, 2></em> needs one <em>bubble swap</em> in <em>&lt;3, 2></em> pair. For the permutation&rsquo;s inverse <em>&lt;2, 3, 1></em>, There&rsquo;s no need to bubble swap <em>&lt;2, 3></em> pair. That saves us one bubble swap out of three which is the maximum <em>bubbleCount</em>. 3 - 1 = 2, The bubbleCount of <em>&lt;2, 3, 1></em>. The same applies for any two pairs of permutations which are inverse of each other.</p><h3 id=accepted-source-code-on-uva>Accepted Source Code on UVa<a hidden class=anchor aria-hidden=true href=#accepted-source-code-on-uva>#</a></h3><pre tabindex=0><code>#include &amp;lt;cstdio&amp;gt;

#define ll long long
#define ull unsigned ll

using namespace std;

bool checkIthBit (int n, int i) {
  if( n &amp;amp; (1 &amp;lt;&amp;lt; i) )
    return true;
  return false;
}


int main() {
  int t, cou = 1;

  scanf(&#34;%d&#34;, &amp;amp;t);

  while (cou &amp;lt;= t) {
    int n;
    ull numerator; int denominator;

    scanf(&#34;%d&#34;, &amp;amp;n);

    numerator = ((ull)n*(ull)(n-1));
    denominator = 4;

    // check if nume is div by 2, and simplify rational form
    for (int i=0; i&amp;lt;2; ++i) {
      if (!checkIthBit(numerator, 0)) {
	numerator = numerator/2;
	denominator = denominator/2;
      }
    }

    if (denominator == 1) printf(&#34;Case %d: %llu\n&#34;, cou, numerator);
    else printf(&#34;Case %d: %llu/%d\n&#34;, cou, numerator, denominator);

    cou++;
  }
  return 0;
}
</code></pre><hr><p>Many of those who do not appreciate math, think of it as a routine where you just follow a systematic order of operations on numbers. If you are one those, I hope this article changed, at least doubted, how you perceive it. There are a whole deep and elegant adventures still awaiting you if you delved more deeply.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>