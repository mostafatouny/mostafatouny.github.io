<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lab 03 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
3.1.4
Hints

Observe we can derive $x^i$ from $x^{i-1}$, so we don&rsquo;t need to recompute

Solution
Same as manual:




3.1.14
Homework
3.2.8
Hints

Following the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z > i$, What can you infer?
Utilize that observation in algorithm design.
Consider a flag which stores whether character $A$ is read.
Generalize for a variable that counts how many $A$ was read.

Solution"><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/msa-levitin-post/lab03/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/msa-levitin-post/lab03/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Lab 03"><meta property="og:description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
3.1.4
Hints

Observe we can derive $x^i$ from $x^{i-1}$, so we don&rsquo;t need to recompute

Solution
Same as manual:




3.1.14
Homework
3.2.8
Hints

Following the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z > i$, What can you infer?
Utilize that observation in algorithm design.
Consider a flag which stores whether character $A$ is read.
Generalize for a variable that counts how many $A$ was read.

Solution"><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/msa-levitin-post/lab03/"><meta property="article:section" content="msa-levitin-post"><meta property="article:published_time" content="2023-11-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lab 03"><meta name=twitter:description content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
3.1.4
Hints

Observe we can derive $x^i$ from $x^{i-1}$, so we don&rsquo;t need to recompute

Solution
Same as manual:




3.1.14
Homework
3.2.8
Hints

Following the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z > i$, What can you infer?
Utilize that observation in algorithm design.
Consider a flag which stores whether character $A$ is read.
Generalize for a variable that counts how many $A$ was read.

Solution"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Levitin's Algorithms","item":"https://mostafatouny.github.io/msa-levitin-post/"},{"@type":"ListItem","position":2,"name":"Lab 03","item":"https://mostafatouny.github.io/msa-levitin-post/lab03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lab 03","name":"Lab 03","description":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 3.1.4 Hints\nObserve we can derive $x^i$ from $x^{i-1}$, so we don\u0026rsquo;t need to recompute Solution\nSame as manual:\n3.1.14 Homework\n3.2.8 Hints\nFollowing the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z \u003e i$, What can you infer? Utilize that observation in algorithm design. Consider a flag which stores whether character $A$ is read. Generalize for a variable that counts how many $A$ was read. Solution\n","keywords":[],"articleBody":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 3.1.4 Hints\nObserve we can derive $x^i$ from $x^{i-1}$, so we don’t need to recompute Solution\nSame as manual:\n3.1.14 Homework\n3.2.8 Hints\nFollowing the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z \u003e i$, What can you infer? Utilize that observation in algorithm design. Consider a flag which stores whether character $A$ is read. Generalize for a variable that counts how many $A$ was read. Solution\n(a)\ndef count_substrings_starting_with_a_ending_with_b(S[0..n-1]): count = 0 for i in 0..n-2 if S[i] == A for j in i+1..n-1 if S[j] == B count = count + 1 return count The number of basic operations is upperbounded by $\\sum_{i=0}^{n-2} \\sum_{j=i+1}^{n-1} 1 = \\mathcal{O}(n^2)$.\n(b)\ndef count_substrings_starting_with_a_ending_with_b(S[0..n-1]): count_a = 0 # Count of 'A' characters encountered so far count_ab = 0 # Count of substrings starting with 'A' and ending with 'B' for i in 0..n-2: if S[i] == A count_a = count_a + 1 else if S[i] == B count_ab = count_ab + count_a return count_ab $\\sum_{i=0}^{n-2} 1 = \\Theta(n)$. Observe count of basic operations is exactly 1 per iteration.\n3.2.9 Homework\n3.3.3 Homework\n3.3.9 Hints\nThink of a unique property about extreme points, in terms of coordinates. What can you conclude about the point of maximum $x$ or $y$ coordinates? Solution\n# input: array of points, each point is a tuple of x and y coordinates # output: a list of exactly two extreme points def find_extreme_points(P[0..n]) # given n \u003e= 2 # Initialize extreme points with the first point in the set min_x_point, min_y_point = P[0] max_x_point, max_y_point = P[0] # Iterate through the remaining points for i in P[1..n] x, y = i # Update max_x_point and max_y_point if needed if x \u003e max_x_point: max_x_point = x max_y_point = y else if x == max_x_point and y \u003e max_y_point: max_y_point = y # Update min_x_point and min_y_point if needed if x \u003c min_x_point: min_x_point = x min_y_point = y else if x == min_x_point and y \u003c min_y_point: min_y_point = y return [(min_x_point, min_y_point), (max_x_point, max_y_point)] 3.4.6 We assume the problem would always have a solution. We leave it as an exercise for students to detect the case of the non-existince of any solution.\nHints\nWhat can you conclude about the total sum of the whole set, given we have a partition of two subsets, each of total sum $p$? If we selected a subset whose sum is $k$, How do we compute the total sum of the remaining elements? Consider the special case of finding a single subset whose total sum is $p$. Design your algorithm to only rely upon searching through the domain of subsets. Solution\nThere is an elegant generator based on binary numbers. Since this is not the core focus of the question, We show an easier to understand code by recursion.\ndef generate_subsets(A[0..n-1]): if n == 0: return [ [] ] # Generate subsets without the last element subsets_without_last = generate_subsets( A[0..n-2] ) # Add the last element to each subset in subsets_without_last subsets_with_last = [ subset + [A[n-1]] for subset in subsets_without_last ] # Concatenate subsets with and without the last element return subsets_without_last + subsets_with_last 3.4.9 Homework.\n3.5.7 Homework\n3.5.8 Hints\nThe hinted picture of 2-colorable might be more useful. Try to construct a 2-colorable labeling on given graphs. Observe by symmetry you can start anywhere and with any colour. What if a vertex must be coloured with two different colours from two different vertices? Can we conclude colouring impossibility? Solution\n(a)\nmodify $dfs$ function in page 124 to maintain a two colours switching for each level, rather than $count$.\ndef switchColour(input_colour) if input_colour is white return black if input_colour is black return white def dfs(v, current_colour) if v.colour == NULL v.colour = current_colour else return v.colour == current_colour for each vertex w in V adjacent to v if not dfs( w, switchColour(current_colour) ) return False return True (b)\nmodify $bfs$ to maintain the depth alongside the vertex in the queue, and then colour according to whether the depth is even or odd.\ndef colourByDepth(depth_input) if depth_input is even return white if depth_input is odd return black def bfs(v) set v.depth = 0 v.colour = colourByDepth(v.depth) initialize a queue with v while the queue is not empty do for each vertex w in V adjacent to the front vertex f if w.colour == NULL w.depth = f.depth + 1 w.colour = colourByDepth(w.depth) add w to the queue else if w.colour != colourByDepth(f.depth+1) return False remove the front vertex from the queue return True ","wordCount":"758","inLanguage":"en","datePublished":"2023-11-16T00:00:00Z","dateModified":"2023-11-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/msa-levitin-post/lab03/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Lab 03</h1><div class=post-meta><span title='2023-11-16 00:00:00 +0000 UTC'>November 16, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exercises aria-label=Exercises>Exercises</a><ul><li><a href=#section aria-label=3.1.4>3.1.4</a></li><li><a href=#section-1 aria-label=3.1.14>3.1.14</a></li><li><a href=#section-2 aria-label=3.2.8>3.2.8</a></li><li><a href=#section-3 aria-label=3.2.9>3.2.9</a></li><li><a href=#section-4 aria-label=3.3.3>3.3.3</a></li><li><a href=#section-5 aria-label=3.3.9>3.3.9</a></li><li><a href=#section-6 aria-label=3.4.6>3.4.6</a></li><li><a href=#section-7 aria-label=3.4.9>3.4.9</a></li><li><a href=#section-8 aria-label=3.5.7>3.5.7</a></li><li><a href=#section-9 aria-label=3.5.8>3.5.8</a></li></ul></li></ul></div></details></div><div class=post-content><p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p><h2 id=exercises class=unnumbered>Exercises<a hidden class=anchor aria-hidden=true href=#exercises>#</a></h2><h3 id=section class=unnumbered>3.1.4<a hidden class=anchor aria-hidden=true href=#section>#</a></h3><p><em>Hints</em></p><ul><li>Observe we can derive $x^i$ from $x^{i-1}$, so we don&rsquo;t need to recompute</li></ul><p><em>Solution</em></p><p>Same as manual:</p><p><img loading=lazy src=./ex-3-1-4.png alt=image></p><p><img loading=lazy src=./ex-3-1-4_1.png alt=image></p><h3 id=section-1 class=unnumbered>3.1.14<a hidden class=anchor aria-hidden=true href=#section-1>#</a></h3><p><strong>Homework</strong></p><h3 id=section-2 class=unnumbered>3.2.8<a hidden class=anchor aria-hidden=true href=#section-2>#</a></h3><p><em>Hints</em></p><ul><li>Following the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z > i$, What can you infer?</li><li>Utilize that observation in algorithm design.</li><li>Consider a flag which stores whether character $A$ is read.</li><li>Generalize for a variable that counts how many $A$ was read.</li></ul><p><em>Solution</em></p><p><strong>(a)</strong></p><pre tabindex=0><code>    def count_substrings_starting_with_a_ending_with_b(S[0..n-1]):
      count = 0

      for i in 0..n-2
          if S[i] == A
              for j in i+1..n-1
                  if S[j] == B
                      count = count + 1

      return count
</code></pre><p>The number of basic operations is upperbounded by $\sum_{i=0}^{n-2} \sum_{j=i+1}^{n-1} 1 = \mathcal{O}(n^2)$.</p><p><strong>(b)</strong></p><pre tabindex=0><code>    def count_substrings_starting_with_a_ending_with_b(S[0..n-1]):
      count_a = 0  # Count of &#39;A&#39; characters encountered so far
      count_ab = 0  # Count of substrings starting with &#39;A&#39; and ending with &#39;B&#39;

      for i in 0..n-2:
          if S[i] == A
              count_a = count_a + 1
          else if S[i] == B
              count_ab = count_ab + count_a

      return count_ab
</code></pre><p>$\sum_{i=0}^{n-2} 1 = \Theta(n)$. Observe count of basic operations is exactly 1 per iteration.</p><h3 id=section-3 class=unnumbered>3.2.9<a hidden class=anchor aria-hidden=true href=#section-3>#</a></h3><p><strong>Homework</strong></p><h3 id=section-4 class=unnumbered>3.3.3<a hidden class=anchor aria-hidden=true href=#section-4>#</a></h3><p><strong>Homework</strong></p><h3 id=section-5 class=unnumbered>3.3.9<a hidden class=anchor aria-hidden=true href=#section-5>#</a></h3><p><em>Hints</em></p><ul><li>Think of a unique property about extreme points, in terms of coordinates.</li><li>What can you conclude about the point of maximum $x$ or $y$ coordinates?</li></ul><p><em>Solution</em></p><pre tabindex=0><code>    # input: array of points, each point is a tuple of x and y coordinates
    # output: a list of exactly two extreme points
    def find_extreme_points(P[0..n]) # given n &gt;= 2

      # Initialize extreme points with the first point in the set
      min_x_point, min_y_point = P[0]
      max_x_point, max_y_point = P[0]

      # Iterate through the remaining points
      for i in P[1..n]
          x, y = i

          # Update max_x_point and max_y_point if needed
          if x &gt; max_x_point:
              max_x_point = x
              max_y_point = y
          else if x == max_x_point and y &gt; max_y_point:
              max_y_point = y

          # Update min_x_point and min_y_point if needed
          if x &lt; min_x_point:
              min_x_point = x
              min_y_point = y
          else if x == min_x_point and y &lt; min_y_point:
              min_y_point = y

      return [(min_x_point, min_y_point), (max_x_point, max_y_point)]
</code></pre><h3 id=section-6 class=unnumbered>3.4.6<a hidden class=anchor aria-hidden=true href=#section-6>#</a></h3><p>We assume the problem would always have a solution. We leave it as an exercise for students to detect the case of the non-existince of any solution.</p><p><em>Hints</em></p><ul><li>What can you conclude about the total sum of the whole set, given we have a partition of two subsets, each of total sum $p$?</li><li>If we selected a subset whose sum is $k$, How do we compute the total sum of the remaining elements?</li><li>Consider the special case of finding a single subset whose total sum is $p$.</li><li>Design your algorithm to only rely upon searching through the domain of subsets.</li></ul><p><em>Solution</em></p><p>There is an elegant generator based on binary numbers. Since this is not the core focus of the question, We show an easier to understand code by recursion.</p><pre tabindex=0><code>    def generate_subsets(A[0..n-1]):
      if n == 0:
          return [ [] ]

      # Generate subsets without the last element
      subsets_without_last = generate_subsets( A[0..n-2] )

      # Add the last element to each subset in subsets_without_last
      subsets_with_last = [ subset + [A[n-1]] for subset in subsets_without_last ]

      # Concatenate subsets with and without the last element
      return subsets_without_last + subsets_with_last
</code></pre><h3 id=section-7 class=unnumbered>3.4.9<a hidden class=anchor aria-hidden=true href=#section-7>#</a></h3><p><strong>Homework.</strong></p><h3 id=section-8 class=unnumbered>3.5.7<a hidden class=anchor aria-hidden=true href=#section-8>#</a></h3><p><strong>Homework</strong></p><h3 id=section-9 class=unnumbered>3.5.8<a hidden class=anchor aria-hidden=true href=#section-9>#</a></h3><p><em>Hints</em></p><ul><li>The hinted picture of 2-colorable might be more useful.</li><li>Try to construct a 2-colorable labeling on given graphs. Observe by symmetry you can start anywhere and with any colour.</li><li>What if a vertex must be coloured with two different colours from two different vertices? Can we conclude colouring impossibility?</li></ul><p><em>Solution</em></p><p><strong>(a)</strong></p><p>modify $dfs$ function in page 124 to maintain a two colours switching for each level, rather than $count$.</p><pre tabindex=0><code>    def switchColour(input_colour)
      if input_colour is white
        return black
      if input_colour is black
        return white

    def dfs(v, current_colour)
      if v.colour == NULL
        v.colour = current_colour
      else
        return v.colour == current_colour

      for each vertex w in V adjacent to v
        if not dfs( w, switchColour(current_colour) )
          return False
      
      return True
</code></pre><p><strong>(b)</strong></p><p>modify $bfs$ to maintain the depth alongside the vertex in the queue, and then colour according to whether the depth is even or odd.</p><pre tabindex=0><code>    def colourByDepth(depth_input)
      if depth_input is even
        return white
      if depth_input is odd
        return black

    def bfs(v)
      set v.depth = 0
      v.colour = colourByDepth(v.depth)
      initialize a queue with v
      
      while the queue is not empty do
        for each vertex w in V adjacent to the front vertex f
          if w.colour == NULL
            w.depth = f.depth + 1
            w.colour = colourByDepth(w.depth)
            add w to the queue
          else
            if w.colour != colourByDepth(f.depth+1)
              return False

        remove the front vertex from the queue

      return True
</code></pre></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>