<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lab 08 | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="Exercises
8.1.3
Homework.
8.1.5
Homework.
8.1.6
Hints

Explain why is the formulation $F(n) = F(n-1) &#43; p_1$ is wrong. Derive a counter example.
The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k &lt; n$.
Generalize.

Solution
Recursive formulation.
\begin{aligned}
F(0) &amp;= 0 \\
F(n) &amp;= \underset{1 \leq j \leq n}{\max} {p_j &#43; F(n-j) }
\end{aligned}
Algorithm.
    # input: Length n, and values of pieces of length i, P[i]
    # output: Maximum value of all possible cuts on a rod of length n
    def dynamicRodCut(n, P[0..n])

        # a rod of length zero contributes nothing to revenue
        P[0] = 0

        # Initialize an array of size n
        F = [] * (n&#43;1)

        # Set the base case
        F[0] = 0

        # Compute bottom-up F[i]
        for i in 1..n

            maxVal = 0

            # Compute the maximum among all js
            for j in 0..i
                # call memoized subinstances
                # update if found a greater value
                maxVal = max( maxVal, P[j] &#43; F(i-j) )

            # memoize
            F[i] = maxVal

        # return max value of cuts, on given length n
        return F[n]
Complexity. Time is $1 &#43; \dots &#43; n = n(n&#43;1)/2$. Additional space is $n&#43;1$.">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/msa-levitin-post/lab08/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/msa-levitin-post/lab08/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Lab 08" />
<meta property="og:description" content="Exercises
8.1.3
Homework.
8.1.5
Homework.
8.1.6
Hints

Explain why is the formulation $F(n) = F(n-1) &#43; p_1$ is wrong. Derive a counter example.
The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k &lt; n$.
Generalize.

Solution
Recursive formulation.
\begin{aligned}
F(0) &amp;= 0 \\
F(n) &amp;= \underset{1 \leq j \leq n}{\max} {p_j &#43; F(n-j) }
\end{aligned}
Algorithm.
    # input: Length n, and values of pieces of length i, P[i]
    # output: Maximum value of all possible cuts on a rod of length n
    def dynamicRodCut(n, P[0..n])

        # a rod of length zero contributes nothing to revenue
        P[0] = 0

        # Initialize an array of size n
        F = [] * (n&#43;1)

        # Set the base case
        F[0] = 0

        # Compute bottom-up F[i]
        for i in 1..n

            maxVal = 0

            # Compute the maximum among all js
            for j in 0..i
                # call memoized subinstances
                # update if found a greater value
                maxVal = max( maxVal, P[j] &#43; F(i-j) )

            # memoize
            F[i] = maxVal

        # return max value of cuts, on given length n
        return F[n]
Complexity. Time is $1 &#43; \dots &#43; n = n(n&#43;1)/2$. Additional space is $n&#43;1$." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/msa-levitin-post/lab08/" /><meta property="article:section" content="msa-levitin-post" />
<meta property="article:published_time" content="2023-12-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Lab 08"/>
<meta name="twitter:description" content="Exercises
8.1.3
Homework.
8.1.5
Homework.
8.1.6
Hints

Explain why is the formulation $F(n) = F(n-1) &#43; p_1$ is wrong. Derive a counter example.
The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k &lt; n$.
Generalize.

Solution
Recursive formulation.
\begin{aligned}
F(0) &amp;= 0 \\
F(n) &amp;= \underset{1 \leq j \leq n}{\max} {p_j &#43; F(n-j) }
\end{aligned}
Algorithm.
    # input: Length n, and values of pieces of length i, P[i]
    # output: Maximum value of all possible cuts on a rod of length n
    def dynamicRodCut(n, P[0..n])

        # a rod of length zero contributes nothing to revenue
        P[0] = 0

        # Initialize an array of size n
        F = [] * (n&#43;1)

        # Set the base case
        F[0] = 0

        # Compute bottom-up F[i]
        for i in 1..n

            maxVal = 0

            # Compute the maximum among all js
            for j in 0..i
                # call memoized subinstances
                # update if found a greater value
                maxVal = max( maxVal, P[j] &#43; F(i-j) )

            # memoize
            F[i] = maxVal

        # return max value of cuts, on given length n
        return F[n]
Complexity. Time is $1 &#43; \dots &#43; n = n(n&#43;1)/2$. Additional space is $n&#43;1$."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Levitin's Algorithms",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Lab 08",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/lab08/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab 08",
  "name": "Lab 08",
  "description": "Exercises 8.1.3 Homework.\n8.1.5 Homework.\n8.1.6 Hints\nExplain why is the formulation $F(n) = F(n-1) + p_1$ is wrong. Derive a counter example. The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k \u003c n$. Generalize. Solution\nRecursive formulation. \\begin{aligned} F(0) \u0026amp;= 0 \\\\ F(n) \u0026amp;= \\underset{1 \\leq j \\leq n}{\\max} {p_j + F(n-j) } \\end{aligned}\nAlgorithm.\n# input: Length n, and values of pieces of length i, P[i] # output: Maximum value of all possible cuts on a rod of length n def dynamicRodCut(n, P[0..n]) # a rod of length zero contributes nothing to revenue P[0] = 0 # Initialize an array of size n F = [] * (n+1) # Set the base case F[0] = 0 # Compute bottom-up F[i] for i in 1..n maxVal = 0 # Compute the maximum among all js for j in 0..i # call memoized subinstances # update if found a greater value maxVal = max( maxVal, P[j] + F(i-j) ) # memoize F[i] = maxVal # return max value of cuts, on given length n return F[n] Complexity. Time is $1 + \\dots + n = n(n+1)/2$. Additional space is $n+1$.\n",
  "keywords": [
    
  ],
  "articleBody": "Exercises 8.1.3 Homework.\n8.1.5 Homework.\n8.1.6 Hints\nExplain why is the formulation $F(n) = F(n-1) + p_1$ is wrong. Derive a counter example. The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k \u003c n$. Generalize. Solution\nRecursive formulation. \\begin{aligned} F(0) \u0026= 0 \\\\ F(n) \u0026= \\underset{1 \\leq j \\leq n}{\\max} {p_j + F(n-j) } \\end{aligned}\nAlgorithm.\n# input: Length n, and values of pieces of length i, P[i] # output: Maximum value of all possible cuts on a rod of length n def dynamicRodCut(n, P[0..n]) # a rod of length zero contributes nothing to revenue P[0] = 0 # Initialize an array of size n F = [] * (n+1) # Set the base case F[0] = 0 # Compute bottom-up F[i] for i in 1..n maxVal = 0 # Compute the maximum among all js for j in 0..i # call memoized subinstances # update if found a greater value maxVal = max( maxVal, P[j] + F(i-j) ) # memoize F[i] = maxVal # return max value of cuts, on given length n return F[n] Complexity. Time is $1 + \\dots + n = n(n+1)/2$. Additional space is $n+1$.\n8.2.2 Homework.\n8.2.3 Homework.\n8.2.5 Hints\nRecall for the algorithm given in the book, at each step, either we take or leave the ith item. For our case what if we at each step, either leave all items, or take 1st item, or take 2nd item, .., or nth item. Modify the formulation. Solution\nRecursive Formulation. \\begin{aligned} F(W) \u0026= 0 \\qquad \u0026\\text{if } W \u003c w_j, ; 1 \\leq j \\leq n \\\\ F(W) \u0026= \\underset{j: W \\geq w_j}{\\max} F(W - w_j) + v_j \u0026\\text{otherwise} \\end{aligned}\nAlgorithm\n# memory function # input: i indicating selecting a multiset of item 1, item 2, .., item i j capacity # output: optimal value of a feasible multiset from item 1, item 2, .., item i def MFKnapsack(i, j, weight, value, F) # only if not memoized, compute and cache it if F[i,j] \u003c 0 # find the maximum value among all cases # item i added 0, 1, 2, .. times constrained by capacity count = 0 while (count * weight[i]) \u003c j maxVal = max( maxVal, (count * value[i]) + MFKnapsack( i-1, j - (count * weight[i]) ) ) # memoize F[i,j] = maxVal return F[i,j] # input: weight of ith item, value of ith item, total capacity W # output: max value of a multiset of all given n items # constrained by capacity W def dynamicKnapsack(weight[1..n], value[1..n], W) # memoization table # all cells -1, indicating no value is computed F[0..n, 0..W] = -1 # except row 0 and column 0, values are 0, by definition of base case for i in 0..n, F[i,0] = 0 for i in 0..W, F[0,i] = 0 # compute memoization table F, and read F[n, W] sol = MFKnapsack(n, W, weight, value, F) # problem solution is F[n, W] return sol 8.3.4 Homework.\n8.3.8 Hints.\nRecall you have table $R$, where $R[i,j]$ contains the root of the tree of nodes $i, \\dots, j$. Recall how the optimal solution of knapsack was constructed. Solution.\n# global variables: table R of roots indices keys A # input: root node of a tree, and indices i and j of keys covered # output: None. Tree is modified so the root points to its children # initialize with i = 1 and j = n # def optimalBST(root, i, j) # base case if root = NULL return # index of the root of subtree of keys A_i, .., A_j k = R[i,j] # left child root.left = A[ R[i, k-1] ] # right child root.right = A[ R[k+1, j] ] # Recursively, Call the child optimalBST(root.left, i, k-1) optimalBST(root.right, k+1, j) P.S. Anything by Donald Knuth is worthwhile studying, however for our pragmatic purposes we omit the analysis bounding $\\mathcal{O}(n^2)$.\n",
  "wordCount" : "656",
  "inLanguage": "en",
  "datePublished": "2023-12-11T00:00:00Z",
  "dateModified": "2023-12-11T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/msa-levitin-post/lab08/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Lab 08
    </h1>
    <div class="post-meta"><span title='2023-12-11 00:00:00 +0000 UTC'>December 11, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#exercises" aria-label="Exercises">Exercises</a><ul>
                        
                <li>
                    <a href="#section" aria-label="8.1.3">8.1.3</a></li>
                <li>
                    <a href="#section-1" aria-label="8.1.5">8.1.5</a></li>
                <li>
                    <a href="#section-2" aria-label="8.1.6">8.1.6</a></li>
                <li>
                    <a href="#section-3" aria-label="8.2.2">8.2.2</a></li>
                <li>
                    <a href="#section-4" aria-label="8.2.3">8.2.3</a></li>
                <li>
                    <a href="#section-5" aria-label="8.2.5">8.2.5</a></li>
                <li>
                    <a href="#section-6" aria-label="8.3.4">8.3.4</a></li>
                <li>
                    <a href="#section-7" aria-label="8.3.8">8.3.8</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="exercises" class="unnumbered">Exercises<a hidden class="anchor" aria-hidden="true" href="#exercises">#</a></h2>
<h3 id="section" class="unnumbered">8.1.3<a hidden class="anchor" aria-hidden="true" href="#section">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-1" class="unnumbered">8.1.5<a hidden class="anchor" aria-hidden="true" href="#section-1">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-2" class="unnumbered">8.1.6<a hidden class="anchor" aria-hidden="true" href="#section-2">#</a></h3>
<p><strong>Hints</strong></p>
<ul>
<li>Explain why is the formulation $F(n) = F(n-1) + p_1$ is wrong. Derive a counter example.</li>
<li>The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k < n$.</li>
<li>Generalize.</li>
</ul>
<p><strong>Solution</strong></p>
<p>Recursive formulation.
\begin{aligned}
F(0) &amp;= 0 \\
F(n) &amp;= \underset{1 \leq j \leq n}{\max} {p_j + F(n-j) }
\end{aligned}</p>
<p>Algorithm.</p>
<pre tabindex="0"><code>    # input: Length n, and values of pieces of length i, P[i]
    # output: Maximum value of all possible cuts on a rod of length n
    def dynamicRodCut(n, P[0..n])

        # a rod of length zero contributes nothing to revenue
        P[0] = 0

        # Initialize an array of size n
        F = [] * (n+1)

        # Set the base case
        F[0] = 0

        # Compute bottom-up F[i]
        for i in 1..n

            maxVal = 0

            # Compute the maximum among all js
            for j in 0..i
                # call memoized subinstances
                # update if found a greater value
                maxVal = max( maxVal, P[j] + F(i-j) )

            # memoize
            F[i] = maxVal

        # return max value of cuts, on given length n
        return F[n]
</code></pre><p>Complexity. Time is $1 + \dots + n = n(n+1)/2$. Additional space is $n+1$.</p>
<h3 id="section-3" class="unnumbered">8.2.2<a hidden class="anchor" aria-hidden="true" href="#section-3">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-4" class="unnumbered">8.2.3<a hidden class="anchor" aria-hidden="true" href="#section-4">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-5" class="unnumbered">8.2.5<a hidden class="anchor" aria-hidden="true" href="#section-5">#</a></h3>
<p><strong>Hints</strong></p>
<ul>
<li>Recall for the algorithm given in the book, at each step, either we take or leave the ith item.</li>
<li>For our case what if we at each step, either leave all items, or take 1st item, or take 2nd item, .., or nth item. Modify the formulation.</li>
</ul>
<p><strong>Solution</strong></p>
<p>Recursive Formulation.
\begin{aligned}
F(W) &amp;= 0 \qquad &amp;\text{if } W &lt; w_j, ; 1 \leq j \leq n \\
F(W) &amp;= \underset{j: W \geq w_j}{\max} F(W - w_j) + v_j &amp;\text{otherwise}
\end{aligned}</p>
<p>Algorithm</p>
<pre tabindex="0"><code>    # memory function
    # input: i indicating selecting a multiset of item 1, item 2, .., item i
             j capacity
    # output: optimal value of a feasible multiset from item 1, item 2, .., item i
    def MFKnapsack(i, j, weight, value, F)
        
        # only if not memoized, compute and cache it
        if F[i,j] &lt; 0

            # find the maximum value among all cases
            # item i added 0, 1, 2, .. times constrained by capacity
            count = 0
            while (count * weight[i]) &lt; j
                maxVal = max( 
                            maxVal, 
                            (count * value[i]) + MFKnapsack( i-1, j - (count * weight[i]) )                     
                        )
            
            # memoize
            F[i,j] = maxVal

        return F[i,j]

    # input: weight of ith item, value of ith item, total capacity W
    # output: max value of a multiset of all given n items
    #         constrained by capacity W
    def dynamicKnapsack(weight[1..n], value[1..n], W)

        # memoization table
        # all cells -1, indicating no value is computed
        F[0..n, 0..W] = -1
        # except row 0 and column 0, values are 0, by definition of base case
        for i in 0..n, F[i,0] = 0
        for i in 0..W, F[0,i] = 0

        # compute memoization table F, and read F[n, W]
        sol = MFKnapsack(n, W, weight, value, F)

        # problem solution is F[n, W]
        return sol
</code></pre><h3 id="section-6" class="unnumbered">8.3.4<a hidden class="anchor" aria-hidden="true" href="#section-6">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-7" class="unnumbered">8.3.8<a hidden class="anchor" aria-hidden="true" href="#section-7">#</a></h3>
<p><strong>Hints.</strong></p>
<ul>
<li>Recall you have table $R$, where $R[i,j]$ contains the root of the tree of nodes $i, \dots, j$.</li>
<li>Recall how the optimal solution of knapsack was constructed.</li>
</ul>
<p><strong>Solution.</strong></p>
<pre tabindex="0"><code>    # global variables: table R of roots indices
                        keys A
    # input: root node of a tree, and indices i and j of keys covered
    # output: None. Tree is modified so the root points to its children
    # initialize with i = 1 and j = n
    # def optimalBST(root, i, j)

        # base case
        if root = NULL
            return

        # index of the root of subtree of keys A_i, .., A_j
        k = R[i,j]

        # left child
        root.left = A[ R[i, k-1] ]
        # right child
        root.right = A[ R[k+1, j] ]

        # Recursively, Call the child
        optimalBST(root.left, i, k-1)
        optimalBST(root.right, k+1, j)
</code></pre><p>P.S. Anything by Donald Knuth is worthwhile studying, however for our
pragmatic purposes we omit the analysis bounding $\mathcal{O}(n^2)$.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
