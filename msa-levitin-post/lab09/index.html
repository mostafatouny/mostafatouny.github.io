<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lab 09 | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="Exercises
9.1.1
Hints.

Use quotient and mod operations.
Observe why the quotient yields the maximum possible count of some coin.

Solution.
      # input: non negative amount n, and a decreasing array of coins D
      # output: array C where C[i] is number of coins of ith denomination D[i]
      def greedyCoins(integer n, D[1..m])
        # for each coin
        for i in 1..m

            # take max possible number of it
            C[i] = floor( n/D[i] )

            # remaining amount for next iteration
            n = n \mod D[i]
        
        # if there is still a remaining amount
        if n != 0 return &#34;no solution&#34;

        # otherwise given n is partitioned by coins
        return C
9.1.15
Homework.">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/msa-levitin-post/lab09/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/msa-levitin-post/lab09/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Lab 09" />
<meta property="og:description" content="Exercises
9.1.1
Hints.

Use quotient and mod operations.
Observe why the quotient yields the maximum possible count of some coin.

Solution.
      # input: non negative amount n, and a decreasing array of coins D
      # output: array C where C[i] is number of coins of ith denomination D[i]
      def greedyCoins(integer n, D[1..m])
        # for each coin
        for i in 1..m

            # take max possible number of it
            C[i] = floor( n/D[i] )

            # remaining amount for next iteration
            n = n \mod D[i]
        
        # if there is still a remaining amount
        if n != 0 return &#34;no solution&#34;

        # otherwise given n is partitioned by coins
        return C
9.1.15
Homework." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/msa-levitin-post/lab09/" /><meta property="article:section" content="msa-levitin-post" />
<meta property="article:published_time" content="2023-12-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-18T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Lab 09"/>
<meta name="twitter:description" content="Exercises
9.1.1
Hints.

Use quotient and mod operations.
Observe why the quotient yields the maximum possible count of some coin.

Solution.
      # input: non negative amount n, and a decreasing array of coins D
      # output: array C where C[i] is number of coins of ith denomination D[i]
      def greedyCoins(integer n, D[1..m])
        # for each coin
        for i in 1..m

            # take max possible number of it
            C[i] = floor( n/D[i] )

            # remaining amount for next iteration
            n = n \mod D[i]
        
        # if there is still a remaining amount
        if n != 0 return &#34;no solution&#34;

        # otherwise given n is partitioned by coins
        return C
9.1.15
Homework."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Levitin's Algorithms",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Lab 09",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/lab09/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab 09",
  "name": "Lab 09",
  "description": "Exercises 9.1.1 Hints.\nUse quotient and mod operations. Observe why the quotient yields the maximum possible count of some coin. Solution.\n# input: non negative amount n, and a decreasing array of coins D # output: array C where C[i] is number of coins of ith denomination D[i] def greedyCoins(integer n, D[1..m]) # for each coin for i in 1..m # take max possible number of it C[i] = floor( n/D[i] ) # remaining amount for next iteration n = n \\mod D[i] # if there is still a remaining amount if n != 0 return \u0026#34;no solution\u0026#34; # otherwise given n is partitioned by coins return C 9.1.15 Homework.\n",
  "keywords": [
    
  ],
  "articleBody": "Exercises 9.1.1 Hints.\nUse quotient and mod operations. Observe why the quotient yields the maximum possible count of some coin. Solution.\n# input: non negative amount n, and a decreasing array of coins D # output: array C where C[i] is number of coins of ith denomination D[i] def greedyCoins(integer n, D[1..m]) # for each coin for i in 1..m # take max possible number of it C[i] = floor( n/D[i] ) # remaining amount for next iteration n = n \\mod D[i] # if there is still a remaining amount if n != 0 return \"no solution\" # otherwise given n is partitioned by coins return C 9.1.15 Homework.\n9.2.3 Hints.\nObserve Kruskal works with global edges, unlike Prim which searches within local neighbour edges. What is error you think we will encounter upon running Kruskal on a a tree with more than one component? Why does looping on $|V| - 1$ works in Kruskal? Modify the while condition to accommodate any forest. Solution.\nModify the while condition in Kruskal to be ecounter \u003c |E|, So it terminates if there are no more edges.\nBonus. Modify Prim then use it as a subroutine to solve the general forest case.\n9.2.5 Homework.\n9.3.1 Hints.\n\\(c\\) Use Transform-and-conquer strategy. \\(c\\) Fixing vertices, What kind of modification is required on edges? \\(d\\) Use Transform-and-conquer strategy. \\(d\\) We will use Dijkstra as a subroutine, So the graph will be transformed to the usual form given in the book. Solution.\n(a)\nA data structure which considers directed edges.\n(b)\nSame algorithm. You may terminate once you find the destination.\n(d)\nEach vertex $v_i$ is mapped to $v_i^{st}$ and $v_i^{en}$, with directed edge $( v_i^{st}, v_i^{en} )$ whose weight is the number labeled on $v_i$. Any vertex in $G$ neighbour to $v_i$, can travel to $v_i^{st}$ but not $v_i^{en}$ in $G'$. Only vertices $v_i^{en}$ but not $v_i^{st}$ can travel to other vertices. Those edges in $G'$ are assigned zero weights.\n# input: graph G with weighted vertices # output: graph G with weighted edges and no weighted vertices def vertexWeightToEdgeWeight(G) construct empty graph G' for each vertex v in G(V) add vertex v_st to G' add vertex v_en to G' set (v_st, v_en).weight to v.weight add edge (v_st, v_en) to G' for each edge e = {a,b} in G(E) set (a_en, b_st).weight = 0 add edge (a_en, b_st) to G' set (b_en, a_st).weight = 0 add edge (b_en, a_st) to G' return G' (c)\nSet the destination as source then reverse paths. If graph is directed reverse paths before running the algorithm also.\n# input: graph G # output: same graph but whose edges are reversed def reverseEdges(G) construct empty graph G' clone vertices G'(V) = G(V) for every vertex v in G(V) for every edge e = (v,t) in G(E) add edge (t,v) to G' return G' # input: undirected graph G, destination d # output: shortest-paths of given d def undirectedGraphSingleDistination(G, d) compute Dijkstra(G, d) in graph G return reverseEdges(G) # input: directed graph G, destination d # output: shortest-paths of given d def directedGraphSingleDestination(G, d) G = reverseEdges(G) compute Dijkstra(G, d) in graph G return reverseEdges(G) Homework.\nA data-structure based implementation is left to students. In fact this is an excellent illustration of abstraction in algorithm design.\n9.3.7 Homework.\n9.4.5 Homework.\n9.4.7 Hints.\nA basic recursive algorithm traversal works. Solution.\ndef allHuffmanCodes(root) if root is NULL return [ ] # if root is a leaf if root.rightChild is NULL and root.leftChild is NULL return [ root.character ] # if exactly one child is NULL, Concatenating an empty list does no harm childCodes = allHuffmanCodes(root.leftChild) + allHuffmanCodes(root.rightChild) # prefix each code in child with root's character return [ root.character + code for code in childCodes ] We leave it to students to modify the algorithm so that it generates a 2d-array of symbols-codes as a homework.\n",
  "wordCount" : "643",
  "inLanguage": "en",
  "datePublished": "2023-12-18T00:00:00Z",
  "dateModified": "2023-12-18T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/msa-levitin-post/lab09/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Lab 09
    </h1>
    <div class="post-meta"><span title='2023-12-18 00:00:00 +0000 UTC'>December 18, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#exercises" aria-label="Exercises">Exercises</a><ul>
                        
                <li>
                    <a href="#section" aria-label="9.1.1">9.1.1</a></li>
                <li>
                    <a href="#section-1" aria-label="9.1.15">9.1.15</a></li>
                <li>
                    <a href="#section-2" aria-label="9.2.3">9.2.3</a></li>
                <li>
                    <a href="#section-3" aria-label="9.2.5">9.2.5</a></li>
                <li>
                    <a href="#section-4" aria-label="9.3.1">9.3.1</a></li>
                <li>
                    <a href="#section-5" aria-label="9.3.7">9.3.7</a></li>
                <li>
                    <a href="#section-6" aria-label="9.4.5">9.4.5</a></li>
                <li>
                    <a href="#section-7" aria-label="9.4.7">9.4.7</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="exercises" class="unnumbered">Exercises<a hidden class="anchor" aria-hidden="true" href="#exercises">#</a></h2>
<h3 id="section" class="unnumbered">9.1.1<a hidden class="anchor" aria-hidden="true" href="#section">#</a></h3>
<p><strong>Hints.</strong></p>
<ul>
<li>Use quotient and mod operations.</li>
<li>Observe why the quotient yields the maximum possible count of some coin.</li>
</ul>
<p><strong>Solution.</strong></p>
<pre tabindex="0"><code>      # input: non negative amount n, and a decreasing array of coins D
      # output: array C where C[i] is number of coins of ith denomination D[i]
      def greedyCoins(integer n, D[1..m])
        # for each coin
        for i in 1..m

            # take max possible number of it
            C[i] = floor( n/D[i] )

            # remaining amount for next iteration
            n = n \mod D[i]
        
        # if there is still a remaining amount
        if n != 0 return &#34;no solution&#34;

        # otherwise given n is partitioned by coins
        return C
</code></pre><h3 id="section-1" class="unnumbered">9.1.15<a hidden class="anchor" aria-hidden="true" href="#section-1">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-2" class="unnumbered">9.2.3<a hidden class="anchor" aria-hidden="true" href="#section-2">#</a></h3>
<p><strong>Hints.</strong></p>
<ul>
<li>Observe <code>Kruskal</code> works with global edges, unlike <code>Prim</code> which searches within local neighbour edges.</li>
<li>What is error you think we will encounter upon running <code>Kruskal</code> on a a tree with more than one component?</li>
<li>Why does looping on $|V| - 1$ works in <code>Kruskal</code>?</li>
<li>Modify the <code>while</code> condition to accommodate any forest.</li>
</ul>
<p><strong>Solution.</strong></p>
<p>Modify the <code>while</code> condition in <code>Kruskal</code> to be <code>ecounter &lt; |E|</code>, So it terminates if there are no more edges.</p>
<p><em>Bonus.</em> Modify <code>Prim</code> then use it as a subroutine to solve the general forest case.</p>
<h3 id="section-3" class="unnumbered">9.2.5<a hidden class="anchor" aria-hidden="true" href="#section-3">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-4" class="unnumbered">9.3.1<a hidden class="anchor" aria-hidden="true" href="#section-4">#</a></h3>
<p><strong>Hints.</strong></p>
<ul>
<li>\(c\) Use <em>Transform-and-conquer</em> strategy.</li>
<li>\(c\) Fixing vertices, What kind of modification is required on edges?</li>
<li>\(d\) Use <em>Transform-and-conquer</em> strategy.</li>
<li>\(d\) We will use <em>Dijkstra</em> as a subroutine, So the graph will be transformed to the usual form given in the book.</li>
</ul>
<p><strong>Solution.</strong></p>
<p><strong>(a)</strong></p>
<p>A data structure which considers directed edges.</p>
<p><strong>(b)</strong></p>
<p>Same algorithm. You may terminate once you find the destination.</p>
<p><strong>(d)</strong></p>
<p>Each vertex $v_i$ is mapped to $v_i^{st}$ and $v_i^{en}$, with directed edge $( v_i^{st}, v_i^{en} )$ whose weight is the number labeled on $v_i$. Any vertex in $G$ neighbour to $v_i$, can travel to $v_i^{st}$ but not $v_i^{en}$ in $G'$. Only vertices $v_i^{en}$ but not $v_i^{st}$ can travel to other vertices. Those edges in $G'$ are assigned zero weights.</p>
<pre tabindex="0"><code>        # input: graph G with weighted vertices
        # output: graph G with weighted edges and no weighted vertices
        def vertexWeightToEdgeWeight(G)

            construct empty graph G&#39;

            for each vertex v in G(V)
                add vertex v_st to G&#39;
                add vertex v_en to G&#39;
                set (v_st, v_en).weight to v.weight
                add edge (v_st, v_en) to G&#39;
            
            for each edge e = {a,b} in G(E)
                set (a_en, b_st).weight = 0
                add edge (a_en, b_st) to G&#39;
                set (b_en, a_st).weight = 0
                add edge (b_en, a_st) to G&#39;

            return G&#39;
</code></pre><p><strong>(c)</strong></p>
<p>Set the destination as source then reverse paths. If graph is directed reverse paths before running the algorithm also.</p>
<pre tabindex="0"><code>        # input: graph G
        # output: same graph but whose edges are reversed
        def reverseEdges(G)
            construct empty graph G&#39;
            clone vertices G&#39;(V) = G(V)

            for every vertex v in G(V)
                for every edge e = (v,t) in G(E)
                    add edge (t,v) to G&#39;

            return G&#39;

        # input: undirected graph G, destination d
        # output: shortest-paths of given d
        def undirectedGraphSingleDistination(G, d)
            compute Dijkstra(G, d) in graph G
            return reverseEdges(G)
        
        # input: directed graph G, destination d
        # output: shortest-paths of given d
        def directedGraphSingleDestination(G, d)
            G = reverseEdges(G)
            compute Dijkstra(G, d) in graph G
            return reverseEdges(G)
</code></pre><p><strong>Homework.</strong></p>
<p>A data-structure based implementation is left to students. In fact this is an excellent illustration of abstraction in algorithm design.</p>
<h3 id="section-5" class="unnumbered">9.3.7<a hidden class="anchor" aria-hidden="true" href="#section-5">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-6" class="unnumbered">9.4.5<a hidden class="anchor" aria-hidden="true" href="#section-6">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-7" class="unnumbered">9.4.7<a hidden class="anchor" aria-hidden="true" href="#section-7">#</a></h3>
<p><strong>Hints.</strong></p>
<ul>
<li>A basic recursive algorithm traversal works.</li>
</ul>
<p><strong>Solution.</strong></p>
<pre tabindex="0"><code>        def allHuffmanCodes(root)
            if root is NULL
                return [ ]
            
            # if root is a leaf
            if root.rightChild is NULL and root.leftChild is NULL
                return [ root.character ]

            # if exactly one child is NULL, Concatenating an empty list does no harm
            childCodes = allHuffmanCodes(root.leftChild) + allHuffmanCodes(root.rightChild)

            # prefix each code in child with root&#39;s character
            return [ root.character + code for code in childCodes ]
</code></pre><p>We leave it to students to modify the algorithm so that it generates a 2d-array of symbols-codes as a <strong>homework.</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
