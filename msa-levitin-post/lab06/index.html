<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lab 06 | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
6.1.1
(a).
Hints

Sort the array as a preprocessing step.
Given a sorted array, and an adjacent pair $A[i],A[i&#43;1]$, Could the distance between $A[i]$ and $A[j]$ where $j &gt; i&#43;1$, be strictly less?
Use that to design your algorithm.

Solution
    # input: Array of integers
    # output: minimum distance between any pairs
    def ClosestDistance(A[0..n-1])

        # Transformation: Sort the array
        A.sort()

        # Initialize minimum distance to | A[0] - A[1] |
        minDistance = abs( A[0] - A[1] )

        # Iterate and compute the distance between adjacent elements
        for i in 1..n-1:
            currentDistance = | arr[i] - arr[i &#43; 1] )

            # Update the minimum distance if the current distance is smaller
            if currentDistance &lt; minDistance:
                minDistance = currentDistance

        # Return the minimum distance
        return minDistance
(b). Homework.">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/msa-levitin-post/lab06/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/msa-levitin-post/lab06/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Lab 06" />
<meta property="og:description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
6.1.1
(a).
Hints

Sort the array as a preprocessing step.
Given a sorted array, and an adjacent pair $A[i],A[i&#43;1]$, Could the distance between $A[i]$ and $A[j]$ where $j &gt; i&#43;1$, be strictly less?
Use that to design your algorithm.

Solution
    # input: Array of integers
    # output: minimum distance between any pairs
    def ClosestDistance(A[0..n-1])

        # Transformation: Sort the array
        A.sort()

        # Initialize minimum distance to | A[0] - A[1] |
        minDistance = abs( A[0] - A[1] )

        # Iterate and compute the distance between adjacent elements
        for i in 1..n-1:
            currentDistance = | arr[i] - arr[i &#43; 1] )

            # Update the minimum distance if the current distance is smaller
            if currentDistance &lt; minDistance:
                minDistance = currentDistance

        # Return the minimum distance
        return minDistance
(b). Homework." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/msa-levitin-post/lab06/" /><meta property="article:section" content="msa-levitin-post" />
<meta property="article:published_time" content="2023-11-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-16T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Lab 06"/>
<meta name="twitter:description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
6.1.1
(a).
Hints

Sort the array as a preprocessing step.
Given a sorted array, and an adjacent pair $A[i],A[i&#43;1]$, Could the distance between $A[i]$ and $A[j]$ where $j &gt; i&#43;1$, be strictly less?
Use that to design your algorithm.

Solution
    # input: Array of integers
    # output: minimum distance between any pairs
    def ClosestDistance(A[0..n-1])

        # Transformation: Sort the array
        A.sort()

        # Initialize minimum distance to | A[0] - A[1] |
        minDistance = abs( A[0] - A[1] )

        # Iterate and compute the distance between adjacent elements
        for i in 1..n-1:
            currentDistance = | arr[i] - arr[i &#43; 1] )

            # Update the minimum distance if the current distance is smaller
            if currentDistance &lt; minDistance:
                minDistance = currentDistance

        # Return the minimum distance
        return minDistance
(b). Homework."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Levitin's Algorithms",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Lab 06",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/lab06/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab 06",
  "name": "Lab 06",
  "description": "$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 6.1.1 (a).\nHints\nSort the array as a preprocessing step. Given a sorted array, and an adjacent pair $A[i],A[i+1]$, Could the distance between $A[i]$ and $A[j]$ where $j \u003e i+1$, be strictly less? Use that to design your algorithm. Solution\n# input: Array of integers # output: minimum distance between any pairs def ClosestDistance(A[0..n-1]) # Transformation: Sort the array A.sort() # Initialize minimum distance to | A[0] - A[1] | minDistance = abs( A[0] - A[1] ) # Iterate and compute the distance between adjacent elements for i in 1..n-1: currentDistance = | arr[i] - arr[i + 1] ) # Update the minimum distance if the current distance is smaller if currentDistance \u0026lt; minDistance: minDistance = currentDistance # Return the minimum distance return minDistance (b). Homework.\n",
  "keywords": [
    
  ],
  "articleBody": "$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 6.1.1 (a).\nHints\nSort the array as a preprocessing step. Given a sorted array, and an adjacent pair $A[i],A[i+1]$, Could the distance between $A[i]$ and $A[j]$ where $j \u003e i+1$, be strictly less? Use that to design your algorithm. Solution\n# input: Array of integers # output: minimum distance between any pairs def ClosestDistance(A[0..n-1]) # Transformation: Sort the array A.sort() # Initialize minimum distance to | A[0] - A[1] | minDistance = abs( A[0] - A[1] ) # Iterate and compute the distance between adjacent elements for i in 1..n-1: currentDistance = | arr[i] - arr[i + 1] ) # Update the minimum distance if the current distance is smaller if currentDistance \u003c minDistance: minDistance = currentDistance # Return the minimum distance return minDistance (b). Homework.\n6.1.2 Homework.\n6.2.4 We ask students whether $\\Theta(n^3) - \\Theta(n^3) + \\Theta(n^3) = \\Theta(n^3)$.\nHints\nTry to given a counter example where coefficients cancel each other. Solution\nWe show it is not true in general true by the counter example $T_1(n) = n^3$, $T_2(n) = 2 n^3$, and $T_3(n) = n^3$.\nAnalysis of the algorithm is left as a homework.\n6.2.5 Homework.\n6.3.5 (a)\nHints\nThe idea is similar to binary search tree Solution\n# input: non-empty graph, by its root # output: smallest element def find_smallestKey(root): node = root while node.left is not None current = current.left return current.key # input: non-empty graph, by its root # output: largest element def find_largestKey(root): node = root while node.right is not None: node = node.right return current.key # input: non-empty graph, by its root # output: difference between largest and smallest elements def range(root) return find_largestKey(root) - find_smallestKey(root) Complexity is $2 \\log n = \\Theta( \\log n )$\n(b)\nHints\nFor the largest, Note we can step down on left children. Similarly for the smallest, we can step down on right children. Solution\nFalse. Counter example from the solution manual.\n6.3.9 Hints\nVery similar to binary search tree Solution\nLike the previous previous exercise we traverse left-most and right-most nodes. The difference is we consider left key and right key of these nodes, respectively.\ndef range(root) leftMost = find_leftMostNode(root) rightMost = find_rightMostNode(root) return rightMost.rightKey - leftMost.leftKey 6.4.2 Homework.\n6.4.5 Students will be given the following subroutines.\n# input: heap as an array, node by its index # output: None. Given heap is modified in-place def siftUp(heap, index): # cannot sift-up root node while index \u003e 0: # parent of the node parentIndex = (index - 1) // 2 # parental dominance is satisfied if heap[index] \u003c= heap[parentIndex] break # if not satisfied, swap with parent swap(heap[index], heap[parentIndex]) # set the cursor to the parent, and repeat index = parentIndex # input: heap as an array, node by its index # output: None. Given heap is modified in-place def siftDown(heap, index): # Children indices leftChild_index = (2 * index) + 1 rightChild_index = (2 * index) + 2 # Find the largest out of index, leftChild_index, and rightChild_index # Initially set largest = index # Check if the left child exists. if larger, update largest if leftChild_index \u003c len(heap) and heap[leftChild_index] \u003e heap[largest] largest = leftChild_index # Check if the right child exists. if larger, update largest if rightChild_index \u003c len(heap) and heap[rightChild_index] \u003e heap[largest]: largest = rightChild_index # If the largest element is one of the children. if largest != index: # swap the child with parent swap( heap[index], heap[largest] ) # recursively heapify the smaller tree siftDown(heap, largest) # parental dominance is satisfied here, whether recursion is called or not, so we are done return (a). Homework.\nHints\nThe approach is very similar to Maximum Key Deletion in Levitin. Hint. Same logic of b but notably restrict search of the min element on leaves, $H[ \\lfloor n/2 \\rfloor + 1 ], \\dots H[n]$. Also since the minimum is in leaves, we will only call \\verb#siftUp#.\ndef delMin(heap H) # find the minimum node's index in leaves minElIndex = min(H[n/2 .. n]) # swap the minimum with last node swapWithLast(minElIndex) # remove the last node removeLast() # sift-up the node in the index, previously containing the minimum siftUp(minElIndex ) (b).\nHints\nUse the element removal subroutine, given in the book. Call it removeLast. Use the swap with last indexed node trick, given in the book. Call it swapWithLast. Solution\ndef findElementIndex(heap, target) for each element i of heap if i == target return i.index def removeIndexNode(heap, index) # swap the indexed node with the last node swapWithLast(heap, index) # remove the last node removeLast(heap) # One of them must terminate in constant time siftDown(heap, index) # swapping downwards siftUp(heap, index) # swapping upwards def removeElementNode(heap, target) # get the index of target by a linear scan index = findElementIndex(heap, target) # remove the element at found index removeIndexNode(heap, index) It is easy to verify, that one of siftDown and siftUp must terminate in $\\mathcal{O}(1)$, given the structure properties of the heap.\nComplexity is $\\mathcal{O}(n) + \\mathcal{O}(1) + \\mathcal{O}(1) + \\mathcal{O}(\\log n) = \\mathcal{O}(n)$, respectively, of findElementIndex and removeIndexNode.\n6.5.1 Homework.\n6.5.9 We ask students how to compute the binary representation of a given number n.\ndef binaryRepresentation(n) # list storing binary representation # b[i] corresponds to ith digit binRep = [] # by definition we know left-most digit is not 0 # n becomes 0, only when last digit is computed while n != 0 # fetch right-most digit b = n mod 2 # eliminate right-most digit n = floor( n/2 ) binRep.append(b) return binRep Finally we hint to them, algorithm RightToLeftBinaryExponentiation in page 238 can be modified, so that it does not require list b(n) as an input.\n6.6.5 Homework.\n6.6.6 Homework.\n6.6.+ You are given an array of positive integers. Find the maximum element but without using \u003e operator.\nHints\nThink of a related algorithm that uses \u003c operator Is the knowledge of minimum element useful in anyway? What if we transformed all elements to their negation? Solution\ndef negationOfArray(A[0..n-1]) for i in 0..n-1 A[i] = -(A[i]) def minElement(A[0..n-1]) minElement = A[0] for i in 1..n-1 if A[i] \u003c minElement minElement = A[i] return minElement def maxElementByReduction(A[0..n-1]) # transform negationOfArray(A) # conquer min = minElement(A) # solve the main problem return -(min) ",
  "wordCount" : "1032",
  "inLanguage": "en",
  "datePublished": "2023-11-16T00:00:00Z",
  "dateModified": "2023-11-16T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/msa-levitin-post/lab06/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Lab 06
    </h1>
    <div class="post-meta"><span title='2023-11-16 00:00:00 +0000 UTC'>November 16, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#exercises" aria-label="Exercises">Exercises</a><ul>
                        
                <li>
                    <a href="#section" aria-label="6.1.1">6.1.1</a></li>
                <li>
                    <a href="#section-1" aria-label="6.1.2">6.1.2</a></li>
                <li>
                    <a href="#section-2" aria-label="6.2.4">6.2.4</a></li>
                <li>
                    <a href="#section-3" aria-label="6.2.5">6.2.5</a></li>
                <li>
                    <a href="#section-4" aria-label="6.3.5">6.3.5</a></li>
                <li>
                    <a href="#section-5" aria-label="6.3.9">6.3.9</a></li>
                <li>
                    <a href="#section-6" aria-label="6.4.2">6.4.2</a></li>
                <li>
                    <a href="#section-7" aria-label="6.4.5">6.4.5</a></li>
                <li>
                    <a href="#section-8" aria-label="6.5.1">6.5.1</a></li>
                <li>
                    <a href="#section-9" aria-label="6.5.9">6.5.9</a></li>
                <li>
                    <a href="#section-10" aria-label="6.6.5">6.6.5</a></li>
                <li>
                    <a href="#section-11" aria-label="6.6.6">6.6.6</a></li>
                <li>
                    <a href="#section-12" aria-label="6.6.&#43;">6.6.+</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p>
<h2 id="exercises" class="unnumbered">Exercises<a hidden class="anchor" aria-hidden="true" href="#exercises">#</a></h2>
<h3 id="section" class="unnumbered">6.1.1<a hidden class="anchor" aria-hidden="true" href="#section">#</a></h3>
<p><strong>(a).</strong></p>
<p><em>Hints</em></p>
<ul>
<li>Sort the array as a preprocessing step.</li>
<li>Given a sorted array, and an adjacent pair $A[i],A[i+1]$, Could the distance between $A[i]$ and $A[j]$ where $j > i+1$, be strictly less?</li>
<li>Use that to design your algorithm.</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>    # input: Array of integers
    # output: minimum distance between any pairs
    def ClosestDistance(A[0..n-1])

        # Transformation: Sort the array
        A.sort()

        # Initialize minimum distance to | A[0] - A[1] |
        minDistance = abs( A[0] - A[1] )

        # Iterate and compute the distance between adjacent elements
        for i in 1..n-1:
            currentDistance = | arr[i] - arr[i + 1] )

            # Update the minimum distance if the current distance is smaller
            if currentDistance &lt; minDistance:
                minDistance = currentDistance

        # Return the minimum distance
        return minDistance
</code></pre><p><strong>(b). Homework</strong>.</p>
<h3 id="section-1" class="unnumbered">6.1.2<a hidden class="anchor" aria-hidden="true" href="#section-1">#</a></h3>
<p><strong>Homework</strong>.</p>
<h3 id="section-2" class="unnumbered">6.2.4<a hidden class="anchor" aria-hidden="true" href="#section-2">#</a></h3>
<p>We ask students whether $\Theta(n^3) - \Theta(n^3) + \Theta(n^3) = \Theta(n^3)$.</p>
<p><em>Hints</em></p>
<ul>
<li>Try to given a counter example where coefficients cancel each other.</li>
</ul>
<p><em>Solution</em></p>
<p>We show it is not true in general true by the counter example $T_1(n) = n^3$, $T_2(n) = 2 n^3$, and $T_3(n) = n^3$.</p>
<p>Analysis of the algorithm is left as a <strong>homework</strong>.</p>
<h3 id="section-3" class="unnumbered">6.2.5<a hidden class="anchor" aria-hidden="true" href="#section-3">#</a></h3>
<p><strong>Homework</strong>.</p>
<h3 id="section-4" class="unnumbered">6.3.5<a hidden class="anchor" aria-hidden="true" href="#section-4">#</a></h3>
<p><strong>(a)</strong></p>
<p><em>Hints</em></p>
<ul>
<li>The idea is similar to binary search tree</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>    # input: non-empty graph, by its root
    # output: smallest element
    def find_smallestKey(root):
        node = root

        while node.left is not None
            current = current.left

        return current.key

    # input: non-empty graph, by its root
    # output: largest element
    def find_largestKey(root):
        node = root

        while node.right is not None:
            node = node.right

        return current.key

    # input: non-empty graph, by its root
    # output: difference between largest and smallest elements
    def range(root)
        return find_largestKey(root) - find_smallestKey(root)
</code></pre><p>Complexity is $2 \log n = \Theta( \log n )$</p>
<p><strong>(b)</strong></p>
<p><em>Hints</em></p>
<ul>
<li>For the largest, Note we can step down on left children. Similarly for the smallest, we can step down on right children.</li>
</ul>
<p><em>Solution</em></p>
<p>False. Counter example from the solution manual.</p>
<p><img loading="lazy" src="ex-6.3.5.jpg" alt="image"  />
</p>
<h3 id="section-5" class="unnumbered">6.3.9<a hidden class="anchor" aria-hidden="true" href="#section-5">#</a></h3>
<p><em>Hints</em></p>
<ul>
<li>Very similar to binary search tree</li>
</ul>
<p><em>Solution</em></p>
<p>Like the previous previous exercise we traverse left-most and right-most nodes. The difference is we consider left key and right key of these nodes, respectively.</p>
<pre tabindex="0"><code>    def range(root)
        leftMost = find_leftMostNode(root)
        rightMost = find_rightMostNode(root)

        return rightMost.rightKey - leftMost.leftKey
</code></pre><h3 id="section-6" class="unnumbered">6.4.2<a hidden class="anchor" aria-hidden="true" href="#section-6">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-7" class="unnumbered">6.4.5<a hidden class="anchor" aria-hidden="true" href="#section-7">#</a></h3>
<p>Students will be given the following subroutines.</p>
<pre tabindex="0"><code>    # input: heap as an array, node by its index
    # output: None. Given heap is modified in-place
    def siftUp(heap, index):

        # cannot sift-up root node
        while index &gt; 0:

            # parent of the node
            parentIndex = (index - 1) // 2
          
            # parental dominance is satisfied
            if heap[index] &lt;= heap[parentIndex]
                break

            # if not satisfied, swap with parent
            swap(heap[index], heap[parentIndex])

            # set the cursor to the parent, and repeat
            index = parentIndex

    # input: heap as an array, node by its index
    # output: None. Given heap is modified in-place
    def siftDown(heap, index):

        # Children indices
        leftChild_index = (2 * index) + 1
        rightChild_index = (2 * index) + 2


        # Find the largest out of index, leftChild_index, and rightChild_index

        # Initially set
        largest = index

        # Check if the left child exists. if larger, update largest
        if leftChild_index &lt; len(heap) and heap[leftChild_index] &gt; heap[largest]
            largest = leftChild_index

        # Check if the right child exists. if larger, update largest
        if rightChild_index &lt; len(heap) and heap[rightChild_index] &gt; heap[largest]:
            largest = rightChild_index


        # If the largest element is one of the children.
        if largest != index:

            # swap the child with parent
            swap( heap[index], heap[largest] )

            # recursively heapify the smaller tree
            siftDown(heap, largest)


        # parental dominance is satisfied here, whether recursion is called or not, so we are done
        return
</code></pre><p><strong>(a). Homework</strong>.</p>
<p><em>Hints</em></p>
<ul>
<li>The approach is very similar to <em>Maximum Key Deletion</em> in Levitin.</li>
</ul>
<p>Hint. Same logic of <em>b</em> but notably restrict search of the min element on leaves, $H[ \lfloor n/2 \rfloor + 1 ], \dots H[n]$. Also since the minimum is in leaves, we will only call \verb#siftUp#.</p>
<pre tabindex="0"><code>  def delMin(heap H)
    # find the minimum node&#39;s index in leaves
    minElIndex = min(H[n/2 .. n])

    # swap the minimum with last node
    swapWithLast(minElIndex)

    # remove the last node
    removeLast()

    # sift-up the node in the index, previously containing the minimum
    siftUp(minElIndex )
</code></pre><p><strong>(b).</strong></p>
<p><em>Hints</em></p>
<ul>
<li>Use the element removal subroutine, given in the book. Call it <code>removeLast</code>.</li>
<li>Use the swap with last indexed node trick, given in the book. Call it <code>swapWithLast</code>.</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>def findElementIndex(heap, target)
    for each element i of heap
        if i == target
            return i.index

def removeIndexNode(heap, index)

    # swap the indexed node with the last node
    swapWithLast(heap, index)

    # remove the last node
    removeLast(heap)

    # One of them must terminate in constant time
    siftDown(heap, index) # swapping downwards
    siftUp(heap, index) # swapping upwards

def removeElementNode(heap, target)

    # get the index of target by a linear scan
    index = findElementIndex(heap, target)

    # remove the element at found index
    removeIndexNode(heap, index)
</code></pre><p>It is easy to verify, that one of <code>siftDown</code> and <code>siftUp</code> must terminate in $\mathcal{O}(1)$, given the structure properties of the heap.</p>
<p>Complexity is $\mathcal{O}(n) + \mathcal{O}(1) + \mathcal{O}(1) + \mathcal{O}(\log n) = \mathcal{O}(n)$, respectively, of <code>findElementIndex</code> and <code>removeIndexNode</code>.</p>
<h3 id="section-8" class="unnumbered">6.5.1<a hidden class="anchor" aria-hidden="true" href="#section-8">#</a></h3>
<p><strong>Homework</strong>.</p>
<h3 id="section-9" class="unnumbered">6.5.9<a hidden class="anchor" aria-hidden="true" href="#section-9">#</a></h3>
<p>We ask students how to compute the binary representation of a given number n.</p>
<pre tabindex="0"><code>    def binaryRepresentation(n)
      
        # list storing binary representation
        # b[i] corresponds to ith digit
        binRep = []

        # by definition we know left-most digit is not 0
        # n becomes 0, only when last digit is computed
        while n != 0
          # fetch right-most digit
          b = n mod 2
          # eliminate right-most digit
          n = floor( n/2 )

          binRep.append(b)

        return binRep
</code></pre><p>Finally we hint to them, algorithm <code>RightToLeftBinaryExponentiation</code> in page 238 can be modified, so that it does not require list b(n) as an input.</p>
<h3 id="section-10" class="unnumbered">6.6.5<a hidden class="anchor" aria-hidden="true" href="#section-10">#</a></h3>
<p><strong>Homework</strong>.</p>
<h3 id="section-11" class="unnumbered">6.6.6<a hidden class="anchor" aria-hidden="true" href="#section-11">#</a></h3>
<p><strong>Homework</strong>.</p>
<h3 id="section-12" class="unnumbered">6.6.+<a hidden class="anchor" aria-hidden="true" href="#section-12">#</a></h3>
<p>You are given an array of positive integers. Find the maximum element but without using &gt; operator.</p>
<p><em>Hints</em></p>
<ul>
<li>Think of a related algorithm that uses &lt; operator</li>
<li>Is the knowledge of minimum element useful in anyway?</li>
<li>What if we transformed all elements to their negation?</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>    def negationOfArray(A[0..n-1])
        for i in 0..n-1
            A[i] = -(A[i])

    def minElement(A[0..n-1])
        minElement = A[0]
        
        for i in 1..n-1
            if A[i] &lt; minElement
                minElement = A[i]

        return minElement

    def maxElementByReduction(A[0..n-1])
        # transform
        negationOfArray(A)

        # conquer
        min = minElement(A)

        # solve the main problem
        return -(min)
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
