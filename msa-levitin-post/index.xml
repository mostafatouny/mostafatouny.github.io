<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Levitin's Algorithms on Mostafa Touny</title><link>https://mostafatouny.github.io/msa-levitin-post/</link><description>Recent content in Levitin's Algorithms on Mostafa Touny</description><generator>Hugo -- 0.136.5</generator><language>en-us</language><lastBuildDate>Mon, 18 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://mostafatouny.github.io/msa-levitin-post/index.xml" rel="self" type="application/rss+xml"/><item><title>Lab 09</title><link>https://mostafatouny.github.io/msa-levitin-post/lab09/</link><pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab09/</guid><description>&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">9.1.1&lt;/h3>
&lt;p>&lt;strong>Hints.&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Use quotient and mod operations.&lt;/li>
&lt;li>Observe why the quotient yields the maximum possible count of some coin.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Solution.&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code> # input: non negative amount n, and a decreasing array of coins D
# output: array C where C[i] is number of coins of ith denomination D[i]
def greedyCoins(integer n, D[1..m])
# for each coin
for i in 1..m
# take max possible number of it
C[i] = floor( n/D[i] )
# remaining amount for next iteration
n = n \mod D[i]
# if there is still a remaining amount
if n != 0 return &amp;#34;no solution&amp;#34;
# otherwise given n is partitioned by coins
return C
&lt;/code>&lt;/pre>&lt;h3 id="section-1" class="unnumbered">9.1.15&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p></description></item><item><title>Lab 08</title><link>https://mostafatouny.github.io/msa-levitin-post/lab08/</link><pubDate>Mon, 11 Dec 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab08/</guid><description>&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">8.1.3&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p>
&lt;h3 id="section-1" class="unnumbered">8.1.5&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p>
&lt;h3 id="section-2" class="unnumbered">8.1.6&lt;/h3>
&lt;p>&lt;strong>Hints&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Explain why is the formulation $F(n) = F(n-1) + p_1$ is wrong. Derive a counter example.&lt;/li>
&lt;li>The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k &lt; n$.&lt;/li>
&lt;li>Generalize.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Solution&lt;/strong>&lt;/p>
&lt;p>Recursive formulation.
\begin{aligned}
F(0) &amp;amp;= 0 \\
F(n) &amp;amp;= \underset{1 \leq j \leq n}{\max} {p_j + F(n-j) }
\end{aligned}&lt;/p>
&lt;p>Algorithm.&lt;/p>
&lt;pre tabindex="0">&lt;code> # input: Length n, and values of pieces of length i, P[i]
# output: Maximum value of all possible cuts on a rod of length n
def dynamicRodCut(n, P[0..n])
# a rod of length zero contributes nothing to revenue
P[0] = 0
# Initialize an array of size n
F = [] * (n+1)
# Set the base case
F[0] = 0
# Compute bottom-up F[i]
for i in 1..n
maxVal = 0
# Compute the maximum among all js
for j in 0..i
# call memoized subinstances
# update if found a greater value
maxVal = max( maxVal, P[j] + F(i-j) )
# memoize
F[i] = maxVal
# return max value of cuts, on given length n
return F[n]
&lt;/code>&lt;/pre>&lt;p>Complexity. Time is $1 + \dots + n = n(n+1)/2$. Additional space is $n+1$.&lt;/p></description></item><item><title>Lab 07</title><link>https://mostafatouny.github.io/msa-levitin-post/lab07/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab07/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">7.1.2&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p>
&lt;h3 id="section-1" class="unnumbered">7.1.5&lt;/h3>
&lt;p>We tell students sort by a single loop rather than a single-line.&lt;/p>
&lt;pre tabindex="0">&lt;code> def sortBySingleLoop(A[0..n-1])
# initialize a zeros list of size n
S = [0] * n
# loop on A values, Convert to corresponding index, Set that index
for i in 0..n-1
S[ A[i]-1 ] = A[i]
# S is A but sorted
return S
&lt;/code>&lt;/pre>&lt;h3 id="section-2" class="unnumbered">7.1.10&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p>
&lt;h3 id="section-3" class="unnumbered">7.2.2&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p>
&lt;h3 id="section-4" class="unnumbered">7.2.3&lt;/h3>
&lt;p>&lt;strong>Homework.&lt;/strong>&lt;/p>
&lt;h3 id="section-5" class="unnumbered">7.2.11&lt;/h3>
&lt;h4 id="a" class="unnumbered">a&lt;/h4>
&lt;p>&lt;strong>Hints&lt;/strong>&lt;/p></description></item><item><title>Lab 03</title><link>https://mostafatouny.github.io/msa-levitin-post/lab03/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab03/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">3.1.4&lt;/h3>
&lt;p>&lt;em>Hints&lt;/em>&lt;/p>
&lt;ul>
&lt;li>Observe we can derive $x^i$ from $x^{i-1}$, so we don&amp;rsquo;t need to recompute&lt;/li>
&lt;/ul>
&lt;p>&lt;em>Solution&lt;/em>&lt;/p>
&lt;p>Same as manual:&lt;/p>
&lt;p>&lt;img loading="lazy" src="./ex-3-1-4.png" alt="image" />
&lt;/p>
&lt;p>&lt;img loading="lazy" src="./ex-3-1-4_1.png" alt="image" />
&lt;/p>
&lt;h3 id="section-1" class="unnumbered">3.1.14&lt;/h3>
&lt;p>&lt;strong>Homework&lt;/strong>&lt;/p>
&lt;h3 id="section-2" class="unnumbered">3.2.8&lt;/h3>
&lt;p>&lt;em>Hints&lt;/em>&lt;/p>
&lt;ul>
&lt;li>Following the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z > i$, What can you infer?&lt;/li>
&lt;li>Utilize that observation in algorithm design.&lt;/li>
&lt;li>Consider a flag which stores whether character $A$ is read.&lt;/li>
&lt;li>Generalize for a variable that counts how many $A$ was read.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>Solution&lt;/em>&lt;/p></description></item><item><title>Lab 04</title><link>https://mostafatouny.github.io/msa-levitin-post/lab04/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab04/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="instructor-notes" class="unnumbered">Instructor Notes&lt;/h2>
&lt;p>&lt;strong>Lemma.&lt;/strong> $\lfloor \log n \rfloor + 1 = \lceil \log (n+1) \rceil$.&lt;/p>
&lt;p>We know $n = 2^k + r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, By&lt;em>Euclid&amp;rsquo;s Theorem&lt;/em> and &lt;em>Archimedean Property&lt;/em>. Then
\begin{aligned}
k + 1 = \log 2^{k+1} \geq \log (2^k + r + 1) &amp;gt; \log (2^k + r) \geq \log 2^k = k
\end{aligned}&lt;/p>
&lt;p>Thus, $\lceil \log(n + 1) \rceil = \lceil \log (2^k + r + 1) \rceil = k + 1$ and $\lfloor \log (n+1) \rfloor = \lfloor \log(2^k + 1) \rfloor = k$.&lt;/p></description></item><item><title>Lab 05</title><link>https://mostafatouny.github.io/msa-levitin-post/lab05/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab05/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">5.1.3&lt;/h3>
&lt;p>&lt;em>Hints&lt;/em>&lt;/p>
&lt;ul>
&lt;li>you can use floors and ceils as subroutines.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>Solution&lt;/em>&lt;/p>
&lt;p>&lt;strong>(a)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code> def divConqPower(a,n)
if n = 1
return a
return divConqPower(a, floor(n/2)) * divConqPower(a, ceil(n/2))
&lt;/code>&lt;/pre>&lt;p>&lt;strong>(b)&lt;/strong>&lt;/p>
&lt;p>Time of basic operations $T(n)$ are $T(n) = T( \lfloor n/2 \rfloor ) + T( \lceil n/2 \rceil) + 1$. Assuming $n = 2^k$, We get $T(n) = 2T(n/2) + 1$. By master theorem,
$T(n) = \Theta(n)$.&lt;/p>
&lt;p>For general cases of $n$, Observe $n = 2^{\log n} \leq 2^{\lceil \log n \rceil}$, So by master theorem $T(n) \leq \mathcal{O}(2^{\lceil \log n \rceil}) \leq \mathcal{O}(2^{\log n + 1}) = \mathcal{O}(n)$. Similarly $T(n) \geq \Omega(2^{\lfloor \log n \rfloor}) = \Omega(n)$. That concludes $T(n) = \Theta(n)$ for any $n$.&lt;/p></description></item><item><title>Lab 06</title><link>https://mostafatouny.github.io/msa-levitin-post/lab06/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab06/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">6.1.1&lt;/h3>
&lt;p>&lt;strong>(a).&lt;/strong>&lt;/p>
&lt;p>&lt;em>Hints&lt;/em>&lt;/p>
&lt;ul>
&lt;li>Sort the array as a preprocessing step.&lt;/li>
&lt;li>Given a sorted array, and an adjacent pair $A[i],A[i+1]$, Could the distance between $A[i]$ and $A[j]$ where $j > i+1$, be strictly less?&lt;/li>
&lt;li>Use that to design your algorithm.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>Solution&lt;/em>&lt;/p>
&lt;pre tabindex="0">&lt;code> # input: Array of integers
# output: minimum distance between any pairs
def ClosestDistance(A[0..n-1])
# Transformation: Sort the array
A.sort()
# Initialize minimum distance to | A[0] - A[1] |
minDistance = abs( A[0] - A[1] )
# Iterate and compute the distance between adjacent elements
for i in 1..n-1:
currentDistance = | arr[i] - arr[i + 1] )
# Update the minimum distance if the current distance is smaller
if currentDistance &amp;lt; minDistance:
minDistance = currentDistance
# Return the minimum distance
return minDistance
&lt;/code>&lt;/pre>&lt;p>&lt;strong>(b). Homework&lt;/strong>.&lt;/p></description></item><item><title>Lab 01</title><link>https://mostafatouny.github.io/msa-levitin-post/lab01/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab01/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">1.1.4&lt;/h3>
&lt;p>&lt;em>Hints&lt;/em>&lt;/p>
&lt;ul>
&lt;li>You are given a square number $n$. Given some integer $k$, How can we verify it is the root?&lt;/li>
&lt;li>Follow the exhaustive search strategy, to find the root of $n$.&lt;/li>
&lt;li>You are given a real number $r$. Given some integer $k$, How can we verify it is the floor of $r$?&lt;/li>
&lt;li>Follow the exhaustive search strategy, to find the floor of $n$.&lt;/li>
&lt;li>Combine all previous hints to find a unique definition of $\lfloor \sqrt{n} \rfloor$.&lt;/li>
&lt;li>Follow the exhaustive search strategy, to solve the main problem.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>Solution&lt;/em>&lt;/p></description></item><item><title>Lab 02</title><link>https://mostafatouny.github.io/msa-levitin-post/lab02/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/msa-levitin-post/lab02/</guid><description>&lt;p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises" class="unnumbered">Exercises&lt;/h2>
&lt;h3 id="section" class="unnumbered">2.1.1&lt;/h3>
&lt;p>&lt;strong>(a)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code> def sumOfArrayNumbers(A[0 .. n-1])
sum = 0
for i in 0..n-1
sum = sum + A[i]
return sum
&lt;/code>&lt;/pre>&lt;p>n; Summation; no.&lt;/p>
&lt;p>&lt;strong>(b)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code> def factorial(n)
res = 1
for i in n..1
res = res * i
return res
&lt;/code>&lt;/pre>&lt;p>1; Multiplication; yes.&lt;/p>
&lt;p>&lt;strong>(c)&lt;/strong>&lt;/p>
&lt;p>Algorithm is in page 61.&lt;/p>
&lt;pre tabindex="0">&lt;code> def maxElementInArray(A[0..n-1])
max = A[0]
for i in 1..n-1
if A[i] &amp;gt; max
max = A[i]
return max
&lt;/code>&lt;/pre>&lt;p>n; Comparison; no.&lt;/p></description></item></channel></rss>