<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lab 04 | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Instructor Notes
Lemma. $\lfloor \log n \rfloor &#43; 1 = \lceil \log (n&#43;1) \rceil$.
We know $n = 2^k &#43; r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, ByEuclid&rsquo;s Theorem and Archimedean Property. Then
\begin{aligned}
k &#43; 1 = \log 2^{k&#43;1} \geq \log (2^k &#43; r &#43; 1) &gt; \log (2^k &#43; r) \geq \log 2^k = k
\end{aligned}
Thus, $\lceil \log(n &#43; 1) \rceil = \lceil \log (2^k &#43; r &#43; 1) \rceil = k &#43; 1$ and $\lfloor \log (n&#43;1) \rfloor  = \lfloor \log(2^k &#43; 1) \rfloor = k$.">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/msa-levitin-post/lab04/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/msa-levitin-post/lab04/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Lab 04" />
<meta property="og:description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Instructor Notes
Lemma. $\lfloor \log n \rfloor &#43; 1 = \lceil \log (n&#43;1) \rceil$.
We know $n = 2^k &#43; r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, ByEuclid&rsquo;s Theorem and Archimedean Property. Then
\begin{aligned}
k &#43; 1 = \log 2^{k&#43;1} \geq \log (2^k &#43; r &#43; 1) &gt; \log (2^k &#43; r) \geq \log 2^k = k
\end{aligned}
Thus, $\lceil \log(n &#43; 1) \rceil = \lceil \log (2^k &#43; r &#43; 1) \rceil = k &#43; 1$ and $\lfloor \log (n&#43;1) \rfloor  = \lfloor \log(2^k &#43; 1) \rfloor = k$." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/msa-levitin-post/lab04/" /><meta property="article:section" content="msa-levitin-post" />
<meta property="article:published_time" content="2023-11-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-16T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Lab 04"/>
<meta name="twitter:description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Instructor Notes
Lemma. $\lfloor \log n \rfloor &#43; 1 = \lceil \log (n&#43;1) \rceil$.
We know $n = 2^k &#43; r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, ByEuclid&rsquo;s Theorem and Archimedean Property. Then
\begin{aligned}
k &#43; 1 = \log 2^{k&#43;1} \geq \log (2^k &#43; r &#43; 1) &gt; \log (2^k &#43; r) \geq \log 2^k = k
\end{aligned}
Thus, $\lceil \log(n &#43; 1) \rceil = \lceil \log (2^k &#43; r &#43; 1) \rceil = k &#43; 1$ and $\lfloor \log (n&#43;1) \rfloor  = \lfloor \log(2^k &#43; 1) \rfloor = k$."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Levitin's Algorithms",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Lab 04",
      "item": "https://www.mostafatouny.github.io/msa-levitin-post/lab04/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lab 04",
  "name": "Lab 04",
  "description": "$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nInstructor Notes Lemma. $\\lfloor \\log n \\rfloor + 1 = \\lceil \\log (n+1) \\rceil$.\nWe know $n = 2^k + r$ for some $k \\geq 0$ and $0 \\leq r \u003c 2^k$, ByEuclid\u0026rsquo;s Theorem and Archimedean Property. Then \\begin{aligned} k + 1 = \\log 2^{k+1} \\geq \\log (2^k + r + 1) \u0026gt; \\log (2^k + r) \\geq \\log 2^k = k \\end{aligned}\nThus, $\\lceil \\log(n + 1) \\rceil = \\lceil \\log (2^k + r + 1) \\rceil = k + 1$ and $\\lfloor \\log (n+1) \\rfloor = \\lfloor \\log(2^k + 1) \\rfloor = k$.\n",
  "keywords": [
    
  ],
  "articleBody": "$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nInstructor Notes Lemma. $\\lfloor \\log n \\rfloor + 1 = \\lceil \\log (n+1) \\rceil$.\nWe know $n = 2^k + r$ for some $k \\geq 0$ and $0 \\leq r \u003c 2^k$, ByEuclid’s Theorem and Archimedean Property. Then \\begin{aligned} k + 1 = \\log 2^{k+1} \\geq \\log (2^k + r + 1) \u003e \\log (2^k + r) \\geq \\log 2^k = k \\end{aligned}\nThus, $\\lceil \\log(n + 1) \\rceil = \\lceil \\log (2^k + r + 1) \\rceil = k + 1$ and $\\lfloor \\log (n+1) \\rfloor = \\lfloor \\log(2^k + 1) \\rfloor = k$.\nLemma. Given $n$, If we repeatedly apply the operation $\\lfloor n/2 \\rfloor$ Then we reach $1$ after exactly $\\lfloor \\log n \\rfloor + 1$.\nConsider $n$ but in binary representation $(d_1 d_2 \\dots d_k)_2$, where $d_1 = 1$. Then by definition $(d_1 d_2 \\dots d_k)_2 / 2$\nyields a quotient $(d_1 \\dots d_{k-1})$ and remainder $d_k$. Since we are taking floor, We can safely ignore $d_k$. It is easy to we reach $d_1 = 1$ after exactly $k-1$ operations. But we know $k = \\lfloor \\log n \\rfloor$.\nExercises 4.1.4 Hints\nConsider the fact, for a fixed element $k$, All subsets either contain $k$, or does not contain $k$. Given all subsets not containing $k$, What do we generate when we append $k$ to each subset? Solution\nTop-down\ndef generateSubsets(A[0..n-1]) # base case, empty subset if A.length == 0 return [ [ ] ] lastElement = A[n-1] # smaller instance solution subsetsWithNoLast = generateSubsets(A[0..n-2]) # generate new solutions from smaller instance subsetsWithLast = [] for subset in subsetsWithNoLast subsetsWithLast.append( subset + [lastElement] ) # concatenate solutions return subsetsWithNoLast + subsetsWithLast Bottom-up (Iterative Improvement)\ndef generateSubsets(A[0..n-1]): n = A.length allSubsets = [ [ ] ] for i in 0..n-1: newSubsets = [] for subset in allSubsets: newSubsets.append( subset + [ A[i] ] ) allSubsets = allSubsets + newSubsets return allSubsets 4.1.10 Homework.\n4.2.3 (a) In matrix implementation $\\Theta(|V|^2)$, and in adjacency list implementation $\\Theta(|V| + |E|)$. Careful analysis won’t be shown as it is outside the scope of the lab, especially that students lack data structures foundations.\n(b)\nHints\nConsider a stack data structure Think in terms of recursion, Given a solved smaller instance, How do we augment it to reach a greater instance? Solution\n# a node is inserted in stack, only after calling its subgraph # Input: node, visited nodes list, stack # Output: NULL def dfs(node, visited, stack): visited.add( node ) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, stack) stack.insert(node) # Input: directed graph in adjacency list implementation # Output: Topological order of the graph def topologicalSortDfs(graph G): visited = set() # no multiple occurences in sets stack = [] # can be omitted if we assumed graph's connectivity # and given a unique root (tree) for node in G(V): if node not in visited: dfs(node) return stack Another simpler implementation not based on DFS as a bonus answer. Preferred to students over DFS based implementation.\n# Input: directed graph in adjacency list implementation # Output: Topological order of the graph def topologicalsortRecursive(graph G): visited = set() # multiple occurences in sets stack = [] for node in G(V): if node not in visited: visited.add(node) topologicalSortRecursive(graph[node], visited, stack) stack.insert(0, node) return stack 4.2.8 Homework.\n4.3.7 Hints\nFor each bit string of size $n-1$, If we added $0$, What do we generate? Combine adding $0$ and $1$. Solution\n# Input: Positive integer n # Output All bit strings of length n def generateAllBitStrings(n): # base case if n == 1: return [\"0\", \"1\"] else # smaller instance solution smallerInstanceStrings = generateAllBitsStrings(n-1) # generate n instance from smaller instance nInstanceWithZero = [] for bitString in smallerInstanceStrings nInstanceWithZero.append(bitString + \"0\") nInstanceWithOne = [] for bitString in smallerInstanceStrings nInstanceWithOne.append(bitString + \"1\") return nInstanceWithZero + nInstanceWithOne 4.3.10 Homework.\n4.4.2 Hints\nConsider n separation, in case it is odd, and in case it is even. If odd, subtract from it only 1, to get an even number Since we are taking floor, We only need to care about the new even number. I.e we won’t count. Solution\ndef floorLog2Recursive(n): # Base case # log2(1) = 0 if n == 1: return 0 # n is even if n % 2 == 0: return 1 + floorLog2Recursive(n/2) # n is odd else return 0 + floorLog2Recursive( (n-1)/2 ) # Since we consider floor, the remainder does not count 4.4.9 Homework.\n4.5.12 Homework.\n4.5.13 Hints\nGiven the target $t \u003e$ cell $c$, for some cell in the matrix. Which elements of the matrix can we exclude from the search? Consider the case if the cell $c$ is at the corner. Try to reduce the problem size by $1$. Solution\nRecursive implementation\n# Input: n x n Matrix, and target value t # Output: tuple (row, column) of the element found, or -1 if not found def searchMatrixRecursive(matrix M[0..n-1, 0..n-1], target t, row, col): if row \u003e= n or col \u003c 0: return -1 # Base case if M[row][col] == t: return (row, col) # Call smaller instances else M[row][col] \u003c t: return searchMatrixRecursive(M, t, row + 1, col) else: return searchMatrixRecursive(M, t, row, col - 1) def searchMatrix(Matrix M[0..n-1, 0..n-1], target t) # initialize with row = 0 and column = n-1 return searchMatrixRecursive(M, t, 0, n-1) Upperbounded by $2n = \\mathcal{O}(n)$ by the recurrence $T(q) = T(q-1) + 1$, where $q = n + n$, the sum of columns and rows number.\nBottom-up implementation (iterative improvement)\n# Input: n x n matrix and target value t # Output: tuple (row, column) of the element found, or -1 if not found def searchMatrixBottomUp(matrix M[0..n-1, 0..n-1] , target t): row = 0 col = n-1 while row \u003c n and col \u003e= 0: if M[row][col] == t: return (row, col) if M[row][col] \u003c t: row = row + 1 else: col = col - 1 return -1 Upperbounded by $\\sum_{i=1}^{2n} 2 = 2(2n) = \\mathcal{O}(n)$, the sum of columns and row numbers.\nP.S. It might be more elegant to consider three-comparison as a single operation. For our students we omit this discussion.\n",
  "wordCount" : "1015",
  "inLanguage": "en",
  "datePublished": "2023-11-16T00:00:00Z",
  "dateModified": "2023-11-16T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/msa-levitin-post/lab04/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Lab 04
    </h1>
    <div class="post-meta"><span title='2023-11-16 00:00:00 +0000 UTC'>November 16, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#instructor-notes" aria-label="Instructor Notes">Instructor Notes</a></li>
                <li>
                    <a href="#exercises" aria-label="Exercises">Exercises</a><ul>
                        
                <li>
                    <a href="#section" aria-label="4.1.4">4.1.4</a></li>
                <li>
                    <a href="#section-1" aria-label="4.1.10">4.1.10</a></li>
                <li>
                    <a href="#section-2" aria-label="4.2.3">4.2.3</a></li>
                <li>
                    <a href="#section-3" aria-label="4.2.8">4.2.8</a></li>
                <li>
                    <a href="#section-4" aria-label="4.3.7">4.3.7</a></li>
                <li>
                    <a href="#section-5" aria-label="4.3.10">4.3.10</a></li>
                <li>
                    <a href="#section-6" aria-label="4.4.2">4.4.2</a></li>
                <li>
                    <a href="#section-7" aria-label="4.4.9">4.4.9</a></li>
                <li>
                    <a href="#section-8" aria-label="4.5.12">4.5.12</a></li>
                <li>
                    <a href="#section-9" aria-label="4.5.13">4.5.13</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p>
<h2 id="instructor-notes" class="unnumbered">Instructor Notes<a hidden class="anchor" aria-hidden="true" href="#instructor-notes">#</a></h2>
<p><strong>Lemma.</strong> $\lfloor \log n \rfloor + 1 = \lceil \log (n+1) \rceil$.</p>
<p>We know $n = 2^k + r$ for some $k \geq 0$ and $0 \leq r < 2^k$, By<em>Euclid&rsquo;s Theorem</em> and <em>Archimedean Property</em>. Then
\begin{aligned}
k + 1 = \log 2^{k+1} \geq \log (2^k + r + 1) &gt; \log (2^k + r) \geq \log 2^k = k
\end{aligned}</p>
<p>Thus, $\lceil \log(n + 1) \rceil = \lceil \log (2^k + r + 1) \rceil = k + 1$ and $\lfloor \log (n+1) \rfloor  = \lfloor \log(2^k + 1) \rfloor = k$.</p>
<p><strong>Lemma.</strong> Given $n$, If we repeatedly apply the operation $\lfloor n/2 \rfloor$ Then we reach $1$ after exactly $\lfloor \log n \rfloor + 1$.</p>
<p>Consider $n$ but in binary representation $(d_1 d_2 \dots d_k)_2$, where $d_1 = 1$. Then by definition $(d_1 d_2 \dots d_k)_2 / 2$</p>
<p>yields a quotient $(d_1 \dots d_{k-1})$ and remainder $d_k$. Since we are taking floor, We can safely ignore $d_k$. It is easy to we reach $d_1 = 1$ after exactly $k-1$ operations. But we know $k = \lfloor \log n \rfloor$.</p>
<h2 id="exercises" class="unnumbered">Exercises<a hidden class="anchor" aria-hidden="true" href="#exercises">#</a></h2>
<h3 id="section" class="unnumbered">4.1.4<a hidden class="anchor" aria-hidden="true" href="#section">#</a></h3>
<p><em>Hints</em></p>
<ul>
<li>Consider the fact, for a fixed element $k$, All subsets either contain $k$, or does not contain $k$.</li>
<li>Given all subsets not containing $k$, What do we generate when we append $k$ to each subset?</li>
</ul>
<p><em>Solution</em></p>
<p>Top-down</p>
<pre tabindex="0"><code>      def generateSubsets(A[0..n-1])
        # base case, empty subset
        if A.length == 0
          return [ [ ] ]
        
        lastElement = A[n-1]

        # smaller instance solution
        subsetsWithNoLast = generateSubsets(A[0..n-2])

        # generate new solutions from smaller instance
        subsetsWithLast = []
        for subset in subsetsWithNoLast
          subsetsWithLast.append( subset + [lastElement] )

        # concatenate solutions
        return subsetsWithNoLast + subsetsWithLast
</code></pre><p>Bottom-up (Iterative Improvement)</p>
<pre tabindex="0"><code>    def generateSubsets(A[0..n-1]):
        n = A.length
        allSubsets = [ [ ] ]

        for i in 0..n-1:
            newSubsets = []
            for subset in allSubsets:
                newSubsets.append( subset + [ A[i] ] )
            allSubsets = allSubsets + newSubsets

        return allSubsets
</code></pre><h3 id="section-1" class="unnumbered">4.1.10<a hidden class="anchor" aria-hidden="true" href="#section-1">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-2" class="unnumbered">4.2.3<a hidden class="anchor" aria-hidden="true" href="#section-2">#</a></h3>
<p><strong>(a)</strong> In matrix implementation $\Theta(|V|^2)$, and in adjacency list implementation $\Theta(|V| + |E|)$. Careful analysis won&rsquo;t be shown as it is outside the scope of the lab, especially that students lack data structures foundations.</p>
<p><strong>(b)</strong></p>
<p><em>Hints</em></p>
<ul>
<li>Consider a stack data structure</li>
<li>Think in terms of recursion, Given a solved smaller instance, How do we augment it to reach a greater instance?</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>    # a node is inserted in stack, only after calling its subgraph
    # Input: node, visited nodes list, stack
    # Output: NULL
    def dfs(node, visited, stack):
      visited.add( node )

      for neighbor in graph[node]:
        if neighbor not in visited:
          dfs(neighbor, visited, stack)
      
      stack.insert(node)

    # Input: directed graph in adjacency list implementation
    # Output: Topological order of the graph
    def topologicalSortDfs(graph G):
      visited = set() # no multiple occurences in sets
      stack = []

      # can be omitted if we assumed graph&#39;s connectivity
      # and given a unique root (tree)
      for node in G(V):
        if node not in visited:
          dfs(node)

      return stack
</code></pre><p>Another simpler implementation not based on DFS as a bonus answer. Preferred to students over DFS based implementation.</p>
<pre tabindex="0"><code>    # Input: directed graph in adjacency list implementation
    # Output: Topological order of the graph
    def topologicalsortRecursive(graph G):
      visited = set() # multiple occurences in sets
      stack = []

      for node in G(V):
        if node not in visited:
          visited.add(node)
          topologicalSortRecursive(graph[node], visited, stack)
          stack.insert(0, node)

      return stack
</code></pre><h3 id="section-3" class="unnumbered">4.2.8<a hidden class="anchor" aria-hidden="true" href="#section-3">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-4" class="unnumbered">4.3.7<a hidden class="anchor" aria-hidden="true" href="#section-4">#</a></h3>
<p><em>Hints</em></p>
<ul>
<li>For each bit string of size $n-1$, If we added $0$, What do we generate?</li>
<li>Combine adding $0$ and $1$.</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>    # Input: Positive integer n
    # Output All bit strings of length n
    def generateAllBitStrings(n):
      # base case
      if n == 1:
        return [&#34;0&#34;, &#34;1&#34;]
      else
        # smaller instance solution
        smallerInstanceStrings = generateAllBitsStrings(n-1)

        # generate n instance from smaller instance

        nInstanceWithZero = []
        for bitString in smallerInstanceStrings
          nInstanceWithZero.append(bitString + &#34;0&#34;)

        nInstanceWithOne = []
        for bitString in smallerInstanceStrings
          nInstanceWithOne.append(bitString + &#34;1&#34;)

        return nInstanceWithZero + nInstanceWithOne
</code></pre><h3 id="section-5" class="unnumbered">4.3.10<a hidden class="anchor" aria-hidden="true" href="#section-5">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-6" class="unnumbered">4.4.2<a hidden class="anchor" aria-hidden="true" href="#section-6">#</a></h3>
<p><em>Hints</em></p>
<ul>
<li>Consider n separation, in case it is odd, and in case it is even.</li>
<li>If odd, subtract from it only 1, to get an even number</li>
<li>Since we are taking floor, We only need to care about the new even number. I.e we won&rsquo;t count.</li>
</ul>
<p><em>Solution</em></p>
<pre tabindex="0"><code>    def floorLog2Recursive(n):
      
      # Base case
      # log2(1) = 0
      if n == 1:
        return 0

      # n is even
      if n % 2 == 0:
        return 1 + floorLog2Recursive(n/2)
      
      # n is odd
      else
        return 0 + floorLog2Recursive( (n-1)/2 )
        # Since we consider floor, the remainder does not count
</code></pre><h3 id="section-7" class="unnumbered">4.4.9<a hidden class="anchor" aria-hidden="true" href="#section-7">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-8" class="unnumbered">4.5.12<a hidden class="anchor" aria-hidden="true" href="#section-8">#</a></h3>
<p><strong>Homework.</strong></p>
<h3 id="section-9" class="unnumbered">4.5.13<a hidden class="anchor" aria-hidden="true" href="#section-9">#</a></h3>
<p><em>Hints</em></p>
<ul>
<li>Given the target $t >$ cell $c$, for some cell in the matrix. Which elements of the matrix can we exclude from the search?</li>
<li>Consider the case if the cell $c$ is at the corner.</li>
<li>Try to reduce the problem size by $1$.</li>
</ul>
<p><em>Solution</em></p>
<p>Recursive implementation</p>
<pre tabindex="0"><code>    # Input: n x n Matrix, and target value t
    # Output: tuple (row, column) of the element found, or -1 if not found
    def searchMatrixRecursive(matrix M[0..n-1, 0..n-1], target t, row, col):
      if row &gt;= n or col &lt; 0:
        return -1

      # Base case
      if M[row][col] == t:
        return (row, col)

      # Call smaller instances
      else M[row][col] &lt; t:
        return searchMatrixRecursive(M, t, row + 1, col)
      else:
        return searchMatrixRecursive(M, t, row, col - 1)

    def searchMatrix(Matrix M[0..n-1, 0..n-1], target t)
      # initialize with row = 0 and column = n-1
      return searchMatrixRecursive(M, t, 0, n-1)
</code></pre><p>Upperbounded by $2n = \mathcal{O}(n)$ by the recurrence $T(q) = T(q-1) + 1$, where $q = n + n$, the sum of columns and rows number.</p>
<p>Bottom-up implementation (iterative improvement)</p>
<pre tabindex="0"><code>    # Input: n x n matrix and target value t
    # Output: tuple (row, column) of the element found, or -1 if not found
    def searchMatrixBottomUp(matrix M[0..n-1, 0..n-1] , target t):
      row = 0
      col = n-1

      while row &lt; n and col &gt;= 0:
        if M[row][col] == t:
          return (row, col)
        
        if M[row][col] &lt; t:
          row = row + 1
        else:
          col = col - 1

      return -1
</code></pre><p>Upperbounded by $\sum_{i=1}^{2n} 2 = 2(2n) = \mathcal{O}(n)$, the sum of columns and row numbers.</p>
<p>P.S. It might be more elegant to consider three-comparison as a single operation. For our students we omit this discussion.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
