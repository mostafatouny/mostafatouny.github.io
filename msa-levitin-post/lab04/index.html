<!DOCTYPE html>
<!-- This site was created with Hugo Blox. https://hugoblox.com -->
<!-- Last Published: July 9, 2024 --><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Hugo Blox Builder 5.9.7" />
  

  
  












  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  

  
  
    
    <script src="/js/mathjax-config.js"></script>
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.26c458e6907dc03073573976b7f4044e.css" media="print" onload="this.media='all'">

  
  
  
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.4/css/academicons.min.css" integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    
    
    
    
      
      
    
    
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.08764d393984928e0719bd53b26ed27a.css" />

  
  
  

  
  
  
  
  
  
  
    
    
    <link rel="stylesheet" href="/css/libs/chroma/github-light.min.css" title="hl-light" media="print" onload="this.media='all'" disabled>
    <link rel="stylesheet" href="/css/libs/chroma/dracula.min.css" title="hl-dark" media="print" onload="this.media='all'" >
  

  
  



























  
  
  






  <meta name="author" content="Mostafa Touny" />





  

<meta name="description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Instructor Notes Lemma. $\lfloor \log n \rfloor &#43; 1 = \lceil \log (n&#43;1) \rceil$.
We know $n = 2^k &#43; r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, ByEuclid&rsquo;s Theorem and Archimedean Property." />



<link rel="alternate" hreflang="en-us" href="https://mostafatouny.github.io/msa-levitin-post/lab04/" />
<link rel="canonical" href="https://mostafatouny.github.io/msa-levitin-post/lab04/" />



  <link rel="manifest" href="/manifest.webmanifest" />



<link rel="icon" type="image/png" href="/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_32x32_fill_lanczos_center_3.png" />
<link rel="apple-touch-icon" type="image/png" href="/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_180x180_fill_lanczos_center_3.png" />

<meta name="theme-color" content="#bbdefb" />










  
  






<meta property="twitter:card" content="summary" />
<meta property="twitter:image" content="https://mostafatouny.github.io/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_512x512_fill_lanczos_center_3.png" />



  

<meta property="og:type" content="website" />
<meta property="og:site_name" content="Mostafa Touny" />
<meta property="og:url" content="https://mostafatouny.github.io/msa-levitin-post/lab04/" />
<meta property="og:title" content="Lab 04 | Mostafa Touny" />
<meta property="og:description" content="$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Instructor Notes Lemma. $\lfloor \log n \rfloor &#43; 1 = \lceil \log (n&#43;1) \rceil$.
We know $n = 2^k &#43; r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, ByEuclid&rsquo;s Theorem and Archimedean Property." /><meta property="og:image" content="https://mostafatouny.github.io/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_512x512_fill_lanczos_center_3.png" /><meta property="og:locale" content="en-us" />

  
    <meta
      property="article:published_time"
      content="2023-11-16T00:00:00&#43;00:00"
    />
  
  
    <meta property="article:modified_time" content="2023-11-16T00:00:00&#43;00:00">
  







  




  
  
  

  
  

  


  
  <title>Lab 04 | Mostafa Touny</title>

  
  
  
  











</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper  dark " data-wc-page-id="b7656e3028e9785fa5ee4b28837b6189" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.db21e13b9b5c4f4b947717750ec8b3cc.js"></script>

  




  <div class="page-header header--fixed">
  
  
  
  
  












<header>
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Mostafa Touny</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Mostafa Touny</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          

          

          
          
          
          

          
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/"><span>About</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/post/"><span>Blog</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        
          
        

        
        
        

        
        
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <article class="article">

  













  

  
  
  
<div class="article-container pt-3">
  <h1>Lab 04</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Nov 16, 2023
  </span>
  

  

  

  
  
  
  

  
  

</div>

    





  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>$\newcommand{\nfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p>
<h2 id="instructor-notes" class="unnumbered">Instructor Notes</h2>
<p><strong>Lemma.</strong> $\lfloor \log n \rfloor + 1 = \lceil \log (n+1) \rceil$.</p>
<p>We know $n = 2^k + r$ for some $k \geq 0$ and $0 \leq r &lt; 2^k$, By<em>Euclid&rsquo;s Theorem</em> and <em>Archimedean Property</em>. Then
\begin{aligned}
k + 1 = \log 2^{k+1} \geq \log (2^k + r + 1) &gt; \log (2^k + r) \geq \log 2^k = k
\end{aligned}</p>
<p>Thus, $\lceil \log(n + 1) \rceil = \lceil \log (2^k + r + 1) \rceil = k + 1$ and $\lfloor \log (n+1) \rfloor  = \lfloor \log(2^k + 1) \rfloor = k$.</p>
<p><strong>Lemma.</strong> Given $n$, If we repeatedly apply the operation $\lfloor n/2 \rfloor$ Then we reach $1$ after exactly $\lfloor \log n \rfloor + 1$.</p>
<p>Consider $n$ but in binary representation $(d_1 d_2 \dots d_k)_2$, where $d_1 = 1$. Then by definition $(d_1 d_2 \dots d_k)_2 / 2$</p>
<p>yields a quotient $(d_1 \dots d_{k-1})$ and remainder $d_k$. Since we are taking floor, We can safely ignore $d_k$. It is easy to we reach $d_1 = 1$ after exactly $k-1$ operations. But we know $k = \lfloor \log n \rfloor$.</p>
<h2 id="exercises" class="unnumbered">Exercises</h2>
<h3 id="section" class="unnumbered">4.1.4</h3>
<p><em>Hints</em></p>
<ul>
<li>Consider the fact, for a fixed element $k$, All subsets either contain $k$, or does not contain $k$.</li>
<li>Given all subsets not containing $k$, What do we generate when we append $k$ to each subset?</li>
</ul>
<p><em>Solution</em></p>
<p>Top-down</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">      def generateSubsets(A[0..n-1])
</span></span><span class="line"><span class="cl">        # base case, empty subset
</span></span><span class="line"><span class="cl">        if A.length == 0
</span></span><span class="line"><span class="cl">          return [ [ ] ]
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        lastElement = A[n-1]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # smaller instance solution
</span></span><span class="line"><span class="cl">        subsetsWithNoLast = generateSubsets(A[0..n-2])
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # generate new solutions from smaller instance
</span></span><span class="line"><span class="cl">        subsetsWithLast = []
</span></span><span class="line"><span class="cl">        for subset in subsetsWithNoLast
</span></span><span class="line"><span class="cl">          subsetsWithLast.append( subset + [lastElement] )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # concatenate solutions
</span></span><span class="line"><span class="cl">        return subsetsWithNoLast + subsetsWithLast
</span></span></code></pre></div><p>Bottom-up (Iterative Improvement)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    def generateSubsets(A[0..n-1]):
</span></span><span class="line"><span class="cl">        n = A.length
</span></span><span class="line"><span class="cl">        allSubsets = [ [ ] ]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for i in 0..n-1:
</span></span><span class="line"><span class="cl">            newSubsets = []
</span></span><span class="line"><span class="cl">            for subset in allSubsets:
</span></span><span class="line"><span class="cl">                newSubsets.append( subset + [ A[i] ] )
</span></span><span class="line"><span class="cl">            allSubsets = allSubsets + newSubsets
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return allSubsets
</span></span></code></pre></div><h3 id="section-1" class="unnumbered">4.1.10</h3>
<p><strong>Homework.</strong></p>
<h3 id="section-2" class="unnumbered">4.2.3</h3>
<p><strong>(a)</strong> In matrix implementation $\Theta(|V|^2)$, and in adjacency list implementation $\Theta(|V| + |E|)$. Careful analysis won&rsquo;t be shown as it is outside the scope of the lab, especially that students lack data structures foundations.</p>
<p><strong>(b)</strong></p>
<p><em>Hints</em></p>
<ul>
<li>Consider a stack data structure</li>
<li>Think in terms of recursion, Given a solved smaller instance, How do we augment it to reach a greater instance?</li>
</ul>
<p><em>Solution</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # a node is inserted in stack, only after calling its subgraph
</span></span><span class="line"><span class="cl">    # Input: node, visited nodes list, stack
</span></span><span class="line"><span class="cl">    # Output: NULL
</span></span><span class="line"><span class="cl">    def dfs(node, visited, stack):
</span></span><span class="line"><span class="cl">      visited.add( node )
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      for neighbor in graph[node]:
</span></span><span class="line"><span class="cl">        if neighbor not in visited:
</span></span><span class="line"><span class="cl">          dfs(neighbor, visited, stack)
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      stack.insert(node)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Input: directed graph in adjacency list implementation
</span></span><span class="line"><span class="cl">    # Output: Topological order of the graph
</span></span><span class="line"><span class="cl">    def topologicalSortDfs(graph G):
</span></span><span class="line"><span class="cl">      visited = set() # no multiple occurences in sets
</span></span><span class="line"><span class="cl">      stack = []
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      # can be omitted if we assumed graph&#39;s connectivity
</span></span><span class="line"><span class="cl">      # and given a unique root (tree)
</span></span><span class="line"><span class="cl">      for node in G(V):
</span></span><span class="line"><span class="cl">        if node not in visited:
</span></span><span class="line"><span class="cl">          dfs(node)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      return stack
</span></span></code></pre></div><p>Another simpler implementation not based on DFS as a bonus answer. Preferred to students over DFS based implementation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Input: directed graph in adjacency list implementation
</span></span><span class="line"><span class="cl">    # Output: Topological order of the graph
</span></span><span class="line"><span class="cl">    def topologicalsortRecursive(graph G):
</span></span><span class="line"><span class="cl">      visited = set() # multiple occurences in sets
</span></span><span class="line"><span class="cl">      stack = []
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      for node in G(V):
</span></span><span class="line"><span class="cl">        if node not in visited:
</span></span><span class="line"><span class="cl">          visited.add(node)
</span></span><span class="line"><span class="cl">          topologicalSortRecursive(graph[node], visited, stack)
</span></span><span class="line"><span class="cl">          stack.insert(0, node)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      return stack
</span></span></code></pre></div><h3 id="section-3" class="unnumbered">4.2.8</h3>
<p><strong>Homework.</strong></p>
<h3 id="section-4" class="unnumbered">4.3.7</h3>
<p><em>Hints</em></p>
<ul>
<li>For each bit string of size $n-1$, If we added $0$, What do we generate?</li>
<li>Combine adding $0$ and $1$.</li>
</ul>
<p><em>Solution</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Input: Positive integer n
</span></span><span class="line"><span class="cl">    # Output All bit strings of length n
</span></span><span class="line"><span class="cl">    def generateAllBitStrings(n):
</span></span><span class="line"><span class="cl">      # base case
</span></span><span class="line"><span class="cl">      if n == 1:
</span></span><span class="line"><span class="cl">        return [&#34;0&#34;, &#34;1&#34;]
</span></span><span class="line"><span class="cl">      else
</span></span><span class="line"><span class="cl">        # smaller instance solution
</span></span><span class="line"><span class="cl">        smallerInstanceStrings = generateAllBitsStrings(n-1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        # generate n instance from smaller instance
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        nInstanceWithZero = []
</span></span><span class="line"><span class="cl">        for bitString in smallerInstanceStrings
</span></span><span class="line"><span class="cl">          nInstanceWithZero.append(bitString + &#34;0&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        nInstanceWithOne = []
</span></span><span class="line"><span class="cl">        for bitString in smallerInstanceStrings
</span></span><span class="line"><span class="cl">          nInstanceWithOne.append(bitString + &#34;1&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        return nInstanceWithZero + nInstanceWithOne
</span></span></code></pre></div><h3 id="section-5" class="unnumbered">4.3.10</h3>
<p><strong>Homework.</strong></p>
<h3 id="section-6" class="unnumbered">4.4.2</h3>
<p><em>Hints</em></p>
<ul>
<li>Consider n separation, in case it is odd, and in case it is even.</li>
<li>If odd, subtract from it only 1, to get an even number</li>
<li>Since we are taking floor, We only need to care about the new even number. I.e we won&rsquo;t count.</li>
</ul>
<p><em>Solution</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    def floorLog2Recursive(n):
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      # Base case
</span></span><span class="line"><span class="cl">      # log2(1) = 0
</span></span><span class="line"><span class="cl">      if n == 1:
</span></span><span class="line"><span class="cl">        return 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      # n is even
</span></span><span class="line"><span class="cl">      if n % 2 == 0:
</span></span><span class="line"><span class="cl">        return 1 + floorLog2Recursive(n/2)
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      # n is odd
</span></span><span class="line"><span class="cl">      else
</span></span><span class="line"><span class="cl">        return 0 + floorLog2Recursive( (n-1)/2 )
</span></span><span class="line"><span class="cl">        # Since we consider floor, the remainder does not count
</span></span></code></pre></div><h3 id="section-7" class="unnumbered">4.4.9</h3>
<p><strong>Homework.</strong></p>
<h3 id="section-8" class="unnumbered">4.5.12</h3>
<p><strong>Homework.</strong></p>
<h3 id="section-9" class="unnumbered">4.5.13</h3>
<p><em>Hints</em></p>
<ul>
<li>Given the target $t &gt;$ cell $c$, for some cell in the matrix. Which elements of the matrix can we exclude from the search?</li>
<li>Consider the case if the cell $c$ is at the corner.</li>
<li>Try to reduce the problem size by $1$.</li>
</ul>
<p><em>Solution</em></p>
<p>Recursive implementation</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Input: n x n Matrix, and target value t
</span></span><span class="line"><span class="cl">    # Output: tuple (row, column) of the element found, or -1 if not found
</span></span><span class="line"><span class="cl">    def searchMatrixRecursive(matrix M[0..n-1, 0..n-1], target t, row, col):
</span></span><span class="line"><span class="cl">      if row &gt;= n or col &lt; 0:
</span></span><span class="line"><span class="cl">        return -1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      # Base case
</span></span><span class="line"><span class="cl">      if M[row][col] == t:
</span></span><span class="line"><span class="cl">        return (row, col)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      # Call smaller instances
</span></span><span class="line"><span class="cl">      else M[row][col] &lt; t:
</span></span><span class="line"><span class="cl">        return searchMatrixRecursive(M, t, row + 1, col)
</span></span><span class="line"><span class="cl">      else:
</span></span><span class="line"><span class="cl">        return searchMatrixRecursive(M, t, row, col - 1)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    def searchMatrix(Matrix M[0..n-1, 0..n-1], target t)
</span></span><span class="line"><span class="cl">      # initialize with row = 0 and column = n-1
</span></span><span class="line"><span class="cl">      return searchMatrixRecursive(M, t, 0, n-1)
</span></span></code></pre></div><p>Upperbounded by $2n = \mathcal{O}(n)$ by the recurrence $T(q) = T(q-1) + 1$, where $q = n + n$, the sum of columns and rows number.</p>
<p>Bottom-up implementation (iterative improvement)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Input: n x n matrix and target value t
</span></span><span class="line"><span class="cl">    # Output: tuple (row, column) of the element found, or -1 if not found
</span></span><span class="line"><span class="cl">    def searchMatrixBottomUp(matrix M[0..n-1, 0..n-1] , target t):
</span></span><span class="line"><span class="cl">      row = 0
</span></span><span class="line"><span class="cl">      col = n-1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      while row &lt; n and col &gt;= 0:
</span></span><span class="line"><span class="cl">        if M[row][col] == t:
</span></span><span class="line"><span class="cl">          return (row, col)
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        if M[row][col] &lt; t:
</span></span><span class="line"><span class="cl">          row = row + 1
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">          col = col - 1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      return -1
</span></span></code></pre></div><p>Upperbounded by $\sum_{i=1}^{2n} 2 = 2(2n) = \mathcal{O}(n)$, the sum of columns and row numbers.</p>
<p>P.S. It might be more elegant to consider three-comparison as a single operation. For our students we omit this discussion.</p>

    </div>

    







<div class="share-box">
  <ul class="share">
    
  </ul>
</div>



















  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  












  
  
  
  
  













  





  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      Published with <a href="https://hugoblox.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Hugo Blox Builder</a> — the free, <a href="https://github.com/HugoBlox/hugo-blox-builder" target="_blank" rel="noopener">open source</a> website builder that empowers creators.
    
  </p>
</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.938a3a7554cd9f6602290411f64d2617.js"></script>




  

  
  

  








































<script id="page-data" type="application/json">{"use_headroom":true}</script>


  <script src="/js/wowchemy-headroom.db4755770454eb63685f8de785c0a172.js" type="module"></script>










<script src="/en/js/wowchemy.min.dddc448a63b69628e8b50b98438b6866.js"></script>

























</body>
</html>
