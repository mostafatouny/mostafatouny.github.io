<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Proving a Space Lower-bound on a Contrived Automata | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth"><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/post/automata-lower-bound/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/post/automata-lower-bound/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Proving a Space Lower-bound on a Contrived Automata"><meta property="og:description" content="The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth"><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/post/automata-lower-bound/"><meta property="og:image" content="https://mostafatouny.github.io/featured.jpg"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-30T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mostafatouny.github.io/featured.jpg"><meta name=twitter:title content="Proving a Space Lower-bound on a Contrived Automata"><meta name=twitter:description content="The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://mostafatouny.github.io/post/"},{"@type":"ListItem","position":2,"name":"Proving a Space Lower-bound on a Contrived Automata","item":"https://mostafatouny.github.io/post/automata-lower-bound/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Proving a Space Lower-bound on a Contrived Automata","name":"Proving a Space Lower-bound on a Contrived Automata","description":"The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth","keywords":[],"articleBody":"Overview In this post we contrive a new kind of Automata, Then prove a space lower-bound on it, for a contrived problem. We begin with an example which shall motivate our whole approach, Then we imagine a thought experiment which is the basis of the proof, Finally we present the formal proof itself. The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth. This is why I wrote a separate section called Thought Experiment. In addition, We strongly recommend the reader not to miss $appendix, fun facts$ section.\nTable of Contents Overview Motivating Example Usual DFA A New Definition For A New Problem First Remark On Solving The New Problem Thought Experiment Information-reserving Definition? Surprise Moment Interpreting Derived Proof Informal Proof Formal Proof Definitions Proof References Appendix Fun Facts Paper Notes of Surprise Moment Motivating Example Usual DFA The problem the above $\\textit{deterministic finite automata}$ ($\\textit{DFA})$ solves is finding whether the number of ones in the input binary string is even or odd. The $\\textit{DFA}$ is defined in the usual straight-forward way.\nA New Definition For A New Problem Now, Let’s think of a different problem for the $\\textit{DFA}$ which shall motivate a different definition. Namely, Finding the length of the longest 1-bit sequence. For instance, the string’s 0111011 longest 1-bit sequence is 3. But the usual $\\textit{DFA}$ outputs either $\\textit{accept}$ or $\\textit{reject}$, So how could it accommodate outputting a number? We tune its construction/definition as follows: We define a labeled set of states $\\textit{F}$ such that if the machine halted on any of them, The output is the label of the state the machine halted on. In our case, We designate a labeled state for each possible longest-length solution.\nFor the above diagram of $\\textit{usual DFA}$ section, We could ignore $q_{even}$ as an $\\textit{acceptance state}$, and think of the labels $\\textit{even}$ and $\\textit{odd}$ as the output of the machine.\nFirst Remark On Solving The New Problem Given $n$ is the length of the input string, An initial thought might be settling states $q_0, q_1, \\dots, q_n$ where state $q_i$ transitions to $q_{i+1}$ if bit 1 is read, and stays the same if bit 0 is read.\nAccordingly, On $w = 10110$, and after reading $10$ the machine is supposed to be at $q_1$ indicating it counted a sequence of length one. But what about counting the other ones? If the machine started counting again, It forgets the sequence of length one it counted before. If it reserved saving the first sequence length, and did not count other sequences, Then certainly the machine fails.\nThis discussion somehow suggests a state must reserve both the count of longest sequence length and the count of the sequence the machine is running on. This is the central key element our space lower-bound proof is based on.\nThought Experiment Information-reserving Definition? Personally, My first reaction was: If I proved a state must reserve two these informations, Then a $\\Omega(n^2)$ lower-bound straight-forwardly follows. That as you need $n+1$ states for each possible 1-bit sequence length, and for each of these states, You need $n+1$ states for counting a sequence the machine is running on. So, $(n+1)(n+1)$ states are needed.\nBut how on earth I shall develop a definition of information reserving? No answer. Also, I did not explore $\\textit{information theory}$ enough to figure a clue. At this point, I was skeptic whether the problem is going to solved at all.\nSurprisingly for me, Eventhough I did not define $\\textit{information-reserving}$, Via the intuition captured from it, I formulated a conjecture which worked at the end!\nSurprise Moment We desginate two strings and conjecture a counter-example yielded from each of both. Namely, Either the machine fails to remember previous counted sequences length, or fails to consider new sequences.\nFor the sake of brevity and this post’s proof readability, We omit the left string 110111. After reading the other string 1101, The machine must yield $q_{2}'$, An output state whose label indicates the automata’s output is $2$, When the machine halts on it.\nBut on the input string 110, The machine outputs also $q_{2}'$. So on input 1101, after reading 110 and while the machine is pointing on last 1 bit, it is on state $q_{2}'$.\nIt is clear now before and after reading the last 1-bit of 1101, The machine is on state $q_{2}'$. As a result, We conclude the machine state’s stays the same if it is on $q_{2}'$ and read 1.\nNow, on string 110111, It is very easy to prove the automata outputs $q_{2}'$ after reading it, and a contradiction occurs as the machine outputs the false answer!\nInterpreting Derived Proof I must admit, For the proof I have just outlined, It was not intuitive for me why does it work! In this section, I try to interpret the proof in terms of the remark I mentioned before in $\\textit{Information-reserving Definition?}$ section.\nOn input string 110, What the machine could learn is only the longest sequence of 1s is 2. As the machine halts on $q_{2}'$ upon reading it, We might like to think of the state’s information content as indicating only the longest sequence of 1s is 2.\nOn input string 1101, The machine halts on $q_{2}'$. However, Reading this string should yield more information content than the one we specified and restricted $q_{2}'$ on. Namely, The $\\textbf{last}$ counter of 1s sequence is one. As the machine ignores the information of counting 1s sequence it is running on, It failed!\nInformal Proof We give informal proofs of concrete examples, Then we show how clear and easy is it to generalize them.\nThe approach is as follows: We show the existince of n+1 $q_{i,0}$ states. For each state, the label $i$ indicates output $i$ in case the machine halted on its corresponding state. We pick-up each state of those $q_{i,0}$, and prove the existince of more states. That is proved by picking-up a designated string, Then show a contradiction occurs in case we had a less number of states $q_{i,j}.$ Finally, We show those states’ uniqueness.\nOn the following, We assume $M$ to be an arbitrary automata which solves longest 1s sequence problem.\nNotations Special states $q_{i,j}$ also indicate output $i$ in case a machine halted on them, Even if $j \\neq 0$. Also, For convenience, We just say $q_{i,j}$ outputs $i$. We say also machine $M$ output $q_{i,j}$ to mean it output $i$, halting on state $q_{i,j}$. We pinpoint configuration $w_0^*qw_1^*$ if the machine read string $w_0^*$ and is pointing at the first bit of $w_1^*$. if $w_1^*$ is null, Then implicitly the machine completed reading.\nn+1 $q_{i,0}$ States Clearly, We need n+1 distinct states for each possible solution of longest sequence of 1s. Given an input string $\\textit{w}$ of size $\\textit{n}$, It is clear there are $\\textit{n+1}$ possible solutions. Namely, $0, 1, \\dots, n$. Exemplary strings include $0^n, 10^{n-1}, 110^{n-2}, \\dots, 1^n$, respectively. So, the automata must include n+1 distinct labeled states, Covering all possible solutions. We call them $q_{0,0}, q_{1,0}, \\dots, q_{n,0}$.\nState $q_{1,1}$ We already know there is a state $q_{1,0}$ which outputs $1$. Let’s assume for the sake of contradiction there is no state other than $q_{1,0}$ which outputs $1$. Consider the string $1011$. Clearly the machine reaches configuration $\\textbf{(1)}$ $101q_{1,0}1$. That is attributed to the fact $M$ must output $q_{1,0}$ on reading input string $101$, By definition of $M$. Note also $q_{1,0}$ is the only state which outputs $1$. A similar reasoning leads to configuration $\\textbf{(2)}$ $10q_{1,0}11$. From $\\textbf{(1)}$ and $\\textbf{(2)}$ we conclude $\\delta(q_{1,0}, 1) = q_{1,0}$. As a result, $M$ outputs $1$ on string $1011$, which in turn is a contradiction. It contradicts our assumption, or $M$’s definition, That it solves longest 1s sequence problem correctly. Hence, there is a state other than $q_{1,0}$ which outputs $1$. We call it $q_{1,1}$.\nState $q_{2,1}$ An exact reasoning to proof of state $q_{1,1}$, but on string $110111$, Concludes there is a state other than $q_{2,0}$ which outputs $1$. We call it $q_{2,1}$\nState $q_{2,2}$ We already know there are two distinct states $q_{2,0}$ and $q_{2,1}$ which output $2$. Let’s assume for the sake of contradiction there is no state other than $q_{2,0}$ and $q_{2,1}$ which outputs $2$. On input string $110111$, It is clear after the discussion of State $q_{1,1}$, Machine $M$ reaches configuration $110q_{2,0}111$. state $q_{2,0}$ is selected here without the loss of generality. $M$ reaches also configuration $1101q_{2,1}11$. The state here must be different from $q_{2,0}$. Otherwise, A contradiction occurs. So, state $q_{2,1}$ is concluded. On configuration $11011q_{k}1$, It is clear the state $q_{k}$ must output $2$, i.e $q_{k} = q_{2,i}$ for some $i$, As $M$ outputs $2$ upon reading string 11011. As we assumed there are only two states which output $2$, Then $q_{k} = q_{2,0}$ or $q_{k} = q_{2,1}$. In either cases, A contradiction occurs, whereby $M$ outputs $2$ upon reading $110111$.\nOther States in Same Manner It is clear we could continue in this manner untill state $q_{n,n}$ is proved to exist, in the arbitrary machine $M$. There is only one remaining caveat we must fulfill. It is proving the uniqueness of states $q_{i,j}$.\nUniqueness Let $q_{i,j}$ and $q_{i',j'}$ be any two arbitrary states, such that it is not the case $i=i' \\wedge j=j'$. So, Either $i \\neq i'$ or $j \\neq j'$. For the former, It is obvious $q_{i,j} \\neq q_{i',j'}$. Otherwise, A sole state would output both $i$ and $i'$. That does not conform with our notion of a state outputting a unique label. Let’s consider the latter, $j \\neq j'$. It is safe to assume $i = i'$ as we handled the case $i \\neq i'$. If $q_{i,j} = q_{i,j'}$, Then the number of states which output $i$ is less than $i+1$. From the discussion above, It is clear that leads to a contradiction.\nSpace Bounds At this point, We have shown there are $1+2+3+\\dots+(n+1) = \\frac{(n+2)(n+1)}{2} = \\Omega(n^2)$ distinct states. It is easy to see that it is possible to construct a machine of $\\frac{(n+2)(n+1)}{2} = \\mathcal{O}(n^2)$ states, As shown in this section’s diagram, That solves finding longest 1s sequence problem. Hence, A space tight-bound $\\Theta(n^2)$ is proved.\nFormal Proof Instead of proving concrete examples as we did before, We present here a general proof. But we do not prove states’ uniqueness as we see the discussion of $\\textit{informal proof}, {uniqueness}$ sufficies for that. Here we aim to provide a more mathematically matured illustration of states’ existince proof.\nBefore doing so, We give precise definitions of the finite automata and the problem we have been working through.\nDefinitions State-Output Deterministic Finite Automata $\\textit{State-Output Deterministic Finite Automata}$ ($SODFA$) is a 6-tuple $(Q, \\Sigma, \\delta, q_0, F, L)$ where:\n$Q$ is a finite set called the states, $\\Sigma = \\set{0, 1}$ is a finite set called the alphabet, $\\delta:Q \\times \\Sigma \\rightarrow Q$ is the transition function, $q_{st} \\in Q$ is the start state, and $F \\subseteq Q$ is the set of accept states. $L: F \\rightarrow \\set{0, 1, \\dots}$ is a function which maps accept states to natural number. This function formalizes our intuitive notion of a state $q_{i,j}$ to output i. The $SODFA$ either accepts or rejects an input string $w$. In case of acceptance, It outputs $L(q')$ where $q'$ is the state the machine has halted on.\nLongest 1s Sequence Problem For an input binary string $w = \\set{0, 1}^*$ of length $n \\in \\mathcal{N}$, It could be re-written as $0^{k_1}1^{k_2} \\dots 0^{k_{n-1}}1^{k_{n}}0^{k_{n+1}}$, such that $\\Sigma_i k_i = n$. $0^{k_{n+1}}$ is added so that this representation accommodates $w$ in case its first bit is 1.\nThe $\\textit{Longest 1s Sequence}$ problem asks for a $SODFA$ machine to halt on an accept state $q'$ such that $L(q') = max \\hspace{2mm} \\set{\\hspace{2mm} k_i \\hspace{1mm} | \\hspace{1mm} 1^{k_i} \\hspace{0.5mm}\\ \\text{is a substring of} \\hspace{2mm} w \\hspace{2mm}}$.\nProof We show:\nFor an arbitrary $SODFA$ machine $M$, if it solves $\\textit{Longest 1s Sequence Problem}$ for inputs of size $n$, Then: For any $0 \\leq i \\leq n$,\n(1) $q_{i, j} \\in M(Q)$ for $0 \\leq j \\leq i$ We solve (1) under the stated assumption.\n(1)\nConsider string $1^i01^{i+1}$. On configuration $1^i0q1^{i+1}$ for some $q$, $L(q)=i$. This conclusion is attributed to the fact that $M$ outputs $i$ upon reading $1^i0$. We call this $q_{i,0}$. If you are super math nerd, Then you might like to develop an $\\textit{extended delta function}$ and solve this step more carefully by recursion.\nFor configurations $1^i01q1^{i}$, $1^i011q1^{i-1}$, …, $1^i01^{i}q1$, all states $q$ have the property that $L(q)=i$ for the exact same reason. We call them respectively $q_{i,1}, q_{i,2}, \\dots, q_{i,i}$.\nThose $q_{i,j}$ are distinct. For the sake of contradiction assume the contrary. Then there are two $q_{i,j0}$ and $q_{i,j1}$ equal to each other. Without the loss of generality let $j0 \u003c j1$. Now there is a sequence of states $q_{i,j0}, \\dots, q_{i,j1}$ such that reading $1$ bit while the machine is on any of them reaches the next one. If the machine reached $q_{i,j1}$ then it is in fact returned back again to $q_{i,j0}$. As a result, no matter how much $1$ bits are read, The machine’s state is going to be within that sequence of states, and it would output $i$. So, Running $M$ on whole $1^i01^{i+1}$ string outputs $i$ which contradicts our definition of $M$ that it yields the correct answer.\nAgain, If you are super math nerd, Pick-up $q_{i,j0}$ then show by a trivial induction on z that the machine always outputs $i$ after reading $1^z$.\nReferences [MS] Michael Sipser. Introduction To The Theory of Computation. Cengage Learning. Appendix Fun Facts I came upon the $\\textit{DFA}$ which finds whether the number of 1 bits in a string is even or odd in $\\textbf{[MS]}$’s superb book. Then I thought of an obvious extension to it. A machine which finds the remainder of dividing on any number. Basically, For number $\\textit{m}$, Designate $\\textit{m}$ states, $q_0, q_1, \\dots, q_{m-1}$ such that halting on $q_i$ indicates the remainder is $i$. This is where the new machine’s construction of output came from!\nAfterward, I tried to think of problems which are elegantly modeled on a $\\textit{DFA}$ but lost hope due to the tedious work of encoding/decoding objects. Since automata works on binary bits, It seemed it is best to work on arithmetic problems. An obvious immediate one is finding the maximum number of an array. This is where the problem of finding the longest sequence of 1 came from!\nEven more notably, I did not pick-up $\\textbf{[MS]}$’s book to find lower-bounds, As I know proving them is hard!\nPaper Notes of Surprise Moment $\\require{textmacros}$\n","wordCount":"2432","inLanguage":"en","image":"https://mostafatouny.github.io/featured.jpg","datePublished":"2020-11-30T00:00:00Z","dateModified":"2020-11-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/post/automata-lower-bound/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Proving a Space Lower-bound on a Contrived Automata</h1><div class=post-meta><span title='2020-11-30 00:00:00 +0000 UTC'>November 30, 2020</span></div></header><figure class=entry-cover><img loading=eager srcset="https://mostafatouny.github.io/post/automata-lower-bound/featured_hu8440232929963028225.jpg 360w ,https://mostafatouny.github.io/post/automata-lower-bound/featured_hu8399957319183334299.jpg 480w ,https://mostafatouny.github.io/post/automata-lower-bound/featured_hu3452154445276849680.jpg 720w ,https://mostafatouny.github.io/post/automata-lower-bound/featured_hu4064239021656151825.jpg 1080w ,https://mostafatouny.github.io/post/automata-lower-bound/featured_hu12989378689248792614.jpg 1500w ,https://mostafatouny.github.io/post/automata-lower-bound/featured.jpg 1632w" sizes="(min-width: 768px) 720px, 100vw" src=https://mostafatouny.github.io/post/automata-lower-bound/featured.jpg alt width=1632 height=768></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#table-of-contents aria-label="Table of Contents">Table of Contents</a></li><li><a href=#motivating-example aria-label="Motivating Example">Motivating Example</a><ul><li><a href=#usual-dfa aria-label="Usual DFA">Usual DFA</a></li><li><a href=#a-new-definition-for-a-new-problem aria-label="A New Definition For A New Problem">A New Definition For A New Problem</a></li><li><a href=#first-remark-on-solving-the-new-problem aria-label="First Remark On Solving The New Problem">First Remark On Solving The New Problem</a></li></ul></li><li><a href=#thought-experiment aria-label="Thought Experiment">Thought Experiment</a><ul><li><a href=#information-reserving-definition aria-label="Information-reserving Definition?">Information-reserving Definition?</a></li><li><a href=#surprise-moment aria-label="Surprise Moment">Surprise Moment</a></li><li><a href=#interpreting-derived-proof aria-label="Interpreting Derived Proof">Interpreting Derived Proof</a></li></ul></li><li><a href=#informal-proof aria-label="Informal Proof">Informal Proof</a><ul><li><a href=#notations aria-label=Notations>Notations</a></li><li><a href=#n1-q_i0-states aria-label="n+1 $q_{i,0}$ States">n+1 $q_{i,0}$ States</a></li><li><a href=#state-q_11 aria-label="State $q_{1,1}$">State $q_{1,1}$</a></li><li><a href=#state-q_21 aria-label="State $q_{2,1}$">State $q_{2,1}$</a></li><li><a href=#state-q_22 aria-label="State $q_{2,2}$">State $q_{2,2}$</a></li><li><a href=#other-states-in-same-manner aria-label="Other States in Same Manner">Other States in Same Manner</a></li><li><a href=#uniqueness aria-label=Uniqueness>Uniqueness</a></li><li><a href=#space-bounds aria-label="Space Bounds">Space Bounds</a></li></ul></li><li><a href=#formal-proof aria-label="Formal Proof">Formal Proof</a><ul><li><a href=#definitions aria-label=Definitions>Definitions</a><ul><li><a href=#state-output-deterministic-finite-automata aria-label="State-Output Deterministic Finite Automata">State-Output Deterministic Finite Automata</a></li><li><a href=#longest-1s-sequence-problem aria-label="Longest 1s Sequence Problem">Longest 1s Sequence Problem</a></li></ul></li><li><a href=#proof aria-label=Proof>Proof</a></li></ul></li><li><a href=#references aria-label=References>References</a></li><li><a href=#appendix aria-label=Appendix>Appendix</a><ul><li><a href=#fun-facts aria-label="Fun Facts">Fun Facts</a></li><li><a href=#paper-notes-of-surprise-moment aria-label="Paper Notes of Surprise Moment">Paper Notes of Surprise Moment</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>In this post we contrive a new kind of Automata, Then prove a space lower-bound on it, for a contrived problem. We begin with an example which shall motivate our whole approach, Then we imagine a thought experiment which is the basis of the proof, Finally we present the formal proof itself. The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth. This is why I wrote a separate section called <em>Thought Experiment</em>. In addition, We strongly recommend the reader not to miss $appendix, fun facts$ section.</p><hr><h2 id=table-of-contents>Table of Contents<a hidden class=anchor aria-hidden=true href=#table-of-contents>#</a></h2><ul><li><a href=#overview>Overview</a></li><li><a href=#motivating-example>Motivating Example</a><ul><li><a href=#usual-dfa>Usual DFA</a></li><li><a href=#a-new-definition-for-a-new-problem>A New Definition For A New Problem</a></li><li><a href=#first-remark-on-solving-the-new-problem>First Remark On Solving The New Problem</a></li></ul></li><li><a href=#thought-experiment>Thought Experiment</a><ul><li><a href=#information-reserving-definition>Information-reserving Definition?</a></li><li><a href=#surprise-moment>Surprise Moment</a></li><li><a href=#interpreting-derived-proof>Interpreting Derived Proof</a></li></ul></li><li><a href=#informal-proof>Informal Proof</a></li><li><a href=#formal-proof>Formal Proof</a><ul><li><a href=#definitions>Definitions</a></li><li><a href=#proof>Proof</a></li></ul></li><li><a href=#references>References</a></li><li><a href=#appendix>Appendix</a><ul><li><a href=#fun-facts>Fun Facts</a></li><li><a href=#paper-notes-of-surprise-moment>Paper Notes of Surprise Moment</a></li></ul></li></ul><hr><h2 id=motivating-example>Motivating Example<a hidden class=anchor aria-hidden=true href=#motivating-example>#</a></h2><h3 id=usual-dfa>Usual DFA<a hidden class=anchor aria-hidden=true href=#usual-dfa>#</a></h3><p><img loading=lazy src=./even-odd.jpg alt=even-odd></p><p>The problem the above $\textit{deterministic finite automata}$ ($\textit{DFA})$ solves is finding whether the number of ones in the input binary string is even or odd. The $\textit{DFA}$ is defined in the usual straight-forward way.</p><h3 id=a-new-definition-for-a-new-problem>A New Definition For A New Problem<a hidden class=anchor aria-hidden=true href=#a-new-definition-for-a-new-problem>#</a></h3><p>Now, Let&rsquo;s think of a different problem for the $\textit{DFA}$ which shall motivate a different definition. Namely, Finding the length of the longest 1-bit sequence. For instance, the string&rsquo;s 0111011 longest 1-bit sequence is 3. But the usual $\textit{DFA}$ outputs either $\textit{accept}$ or $\textit{reject}$, So how could it accommodate outputting a number? We tune its construction/definition as follows: We define a labeled set of states $\textit{F}$ such that if the machine halted on any of them, The output is the label of the state the machine halted on. In our case, We designate a labeled state for each possible longest-length solution.</p><p>For the above diagram of $\textit{usual DFA}$ section, We could ignore $q_{even}$ as an $\textit{acceptance state}$, and think of the labels $\textit{even}$ and $\textit{odd}$ as the output of the machine.</p><h3 id=first-remark-on-solving-the-new-problem>First Remark On Solving The New Problem<a hidden class=anchor aria-hidden=true href=#first-remark-on-solving-the-new-problem>#</a></h3><p>Given $n$ is the length of the input string, An initial thought might be settling states $q_0, q_1, \dots, q_n$ where state $q_i$ transitions to $q_{i+1}$ if bit 1 is read, and stays the same if bit 0 is read.</p><p>Accordingly, On $w = 10110$, and after reading $10$ the machine is supposed to be at $q_1$ indicating it counted a sequence of length one. But what about counting the other ones? If the machine started counting again, It forgets the sequence of length one it counted before. If it reserved saving the first sequence length, and did not count other sequences, Then certainly the machine fails.</p><p>This discussion somehow suggests a state must reserve both the count of longest sequence length and the count of the sequence the machine is running on. This is the central key element our space lower-bound proof is based on.</p><h2 id=thought-experiment>Thought Experiment<a hidden class=anchor aria-hidden=true href=#thought-experiment>#</a></h2><h3 id=information-reserving-definition>Information-reserving Definition?<a hidden class=anchor aria-hidden=true href=#information-reserving-definition>#</a></h3><p>Personally, My first reaction was: If I proved a state must reserve two these informations, Then a $\Omega(n^2)$ lower-bound straight-forwardly follows. That as you need $n+1$ states for each possible 1-bit sequence length, and for each of these states, You need $n+1$ states for counting a sequence the machine is running on. So, $(n+1)(n+1)$ states are needed.</p><p>But how on earth I shall develop a definition of information reserving? No answer. Also, I did not explore $\textit{information theory}$ enough to figure a clue. At this point, I was skeptic whether the problem is going to solved at all.</p><p>Surprisingly for me, Eventhough I did not define $\textit{information-reserving}$, Via the intuition captured from it, I formulated a conjecture which worked at the end!</p><h3 id=surprise-moment>Surprise Moment<a hidden class=anchor aria-hidden=true href=#surprise-moment>#</a></h3><p><img loading=lazy src=thought.jpg alt=thought></p><p>We desginate two strings and conjecture a counter-example yielded from each of both. Namely, Either the machine fails to remember previous counted sequences length, or fails to consider new sequences.</p><p>For the sake of brevity and this post&rsquo;s proof readability, We omit the left string 110111. After reading the other string 1101, The machine must yield $q_{2}'$, An output state whose label indicates the automata&rsquo;s output is $2$, When the machine halts on it.</p><p>But on the input string 110, The machine outputs also $q_{2}'$. So on input 1101, after reading 110 and while the machine is pointing on last 1 bit, it is on state $q_{2}'$.</p><p>It is clear now before and after reading the last 1-bit of 1101, The machine is on state $q_{2}'$. As a result, We conclude the machine state&rsquo;s stays the same if it is on $q_{2}'$ and read 1.</p><p>Now, on string 110111, It is very easy to prove the automata outputs $q_{2}'$ after reading it, and a contradiction occurs as the machine outputs the false answer!</p><h3 id=interpreting-derived-proof>Interpreting Derived Proof<a hidden class=anchor aria-hidden=true href=#interpreting-derived-proof>#</a></h3><p>I must admit, For the proof I have just outlined, It was not intuitive for me why does it work! In this section, I try to interpret the proof in terms of the remark I mentioned before in $\textit{Information-reserving Definition?}$ section.</p><p>On input string 110, What the machine could learn is only the longest sequence of 1s is 2. As the machine halts on $q_{2}'$ upon reading it, We might like to think of the state&rsquo;s information content as indicating only the longest sequence of 1s is 2.</p><p>On input string 1101, The machine halts on $q_{2}'$. However, Reading this string should yield more information content than the one we specified and restricted $q_{2}'$ on. Namely, The $\textbf{last}$ counter of 1s sequence is one. As the machine ignores the information of counting 1s sequence it is running on, It failed!</p><h2 id=informal-proof>Informal Proof<a hidden class=anchor aria-hidden=true href=#informal-proof>#</a></h2><p><img loading=lazy src=./state-space.jpg alt=state-space></p><p>We give informal proofs of concrete examples, Then we show how clear and easy is it to generalize them.</p><p>The approach is as follows: We show the existince of n+1 $q_{i,0}$ states. For each state, the label $i$ indicates output $i$ in case the machine halted on its corresponding state. We pick-up each state of those $q_{i,0}$, and prove the existince of more states. That is proved by picking-up a designated string, Then show a contradiction occurs in case we had a less number of states $q_{i,j}.$ Finally, We show those states&rsquo; uniqueness.</p><p>On the following, We assume $M$ to be an arbitrary automata which solves longest 1s sequence problem.</p><h3 id=notations>Notations<a hidden class=anchor aria-hidden=true href=#notations>#</a></h3><p>Special states $q_{i,j}$ also indicate output $i$ in case a machine halted on them, Even if $j \neq 0$. Also, For convenience, We just say $q_{i,j}$ outputs $i$. We say also machine $M$ output $q_{i,j}$ to mean it output $i$, halting on state $q_{i,j}$. We pinpoint configuration $w_0^*qw_1^*$ if the machine read string $w_0^*$ and is pointing at the first bit of $w_1^*$. if $w_1^*$ is null, Then implicitly the machine completed reading.</p><h3 id=n1-q_i0-states>n+1 $q_{i,0}$ States<a hidden class=anchor aria-hidden=true href=#n1-q_i0-states>#</a></h3><p>Clearly, We need n+1 distinct states for each possible solution of longest sequence of 1s. Given an input string $\textit{w}$ of size $\textit{n}$, It is clear there are $\textit{n+1}$ possible solutions. Namely, $0, 1, \dots, n$. Exemplary strings include $0^n, 10^{n-1}, 110^{n-2}, \dots, 1^n$, respectively. So, the automata must include n+1 distinct labeled states, Covering all possible solutions. We call them $q_{0,0}, q_{1,0}, \dots, q_{n,0}$.</p><h3 id=state-q_11>State $q_{1,1}$<a hidden class=anchor aria-hidden=true href=#state-q_11>#</a></h3><p>We already know there is a state $q_{1,0}$ which outputs $1$. Let&rsquo;s assume for the sake of contradiction there is no state other than $q_{1,0}$ which outputs $1$. Consider the string $1011$. Clearly the machine reaches configuration $\textbf{(1)}$ $101q_{1,0}1$. That is attributed to the fact $M$ must output $q_{1,0}$ on reading input string $101$, By definition of $M$. Note also $q_{1,0}$ is the only state which outputs $1$. A similar reasoning leads to configuration $\textbf{(2)}$ $10q_{1,0}11$. From $\textbf{(1)}$ and $\textbf{(2)}$ we conclude $\delta(q_{1,0}, 1) = q_{1,0}$. As a result, $M$ outputs $1$ on string $1011$, which in turn is a contradiction. It contradicts our assumption, or $M$&rsquo;s definition, That it solves longest 1s sequence problem correctly. Hence, there is a state other than $q_{1,0}$ which outputs $1$. We call it $q_{1,1}$.</p><h3 id=state-q_21>State $q_{2,1}$<a hidden class=anchor aria-hidden=true href=#state-q_21>#</a></h3><p>An exact reasoning to proof of state $q_{1,1}$, but on string $110111$, Concludes there is a state other than $q_{2,0}$ which outputs $1$. We call it $q_{2,1}$</p><h3 id=state-q_22>State $q_{2,2}$<a hidden class=anchor aria-hidden=true href=#state-q_22>#</a></h3><p>We already know there are two distinct states $q_{2,0}$ and $q_{2,1}$ which output $2$. Let&rsquo;s assume for the sake of contradiction there is no state other than $q_{2,0}$ and $q_{2,1}$ which outputs $2$. On input string $110111$, It is clear after the discussion of State $q_{1,1}$, Machine $M$ reaches configuration $110q_{2,0}111$. state $q_{2,0}$ is selected here without the loss of generality. $M$ reaches also configuration $1101q_{2,1}11$. The state here must be different from $q_{2,0}$. Otherwise, A contradiction occurs. So, state $q_{2,1}$ is concluded. On configuration $11011q_{k}1$, It is clear the state $q_{k}$ must output $2$, i.e $q_{k} = q_{2,i}$ for some $i$, As $M$ outputs $2$ upon reading string 11011. As we assumed there are only two states which output $2$, Then $q_{k} = q_{2,0}$ or $q_{k} = q_{2,1}$. In either cases, A contradiction occurs, whereby $M$ outputs $2$ upon reading $110111$.</p><h3 id=other-states-in-same-manner>Other States in Same Manner<a hidden class=anchor aria-hidden=true href=#other-states-in-same-manner>#</a></h3><p>It is clear we could continue in this manner untill state $q_{n,n}$ is proved to exist, in the arbitrary machine $M$. There is only one remaining caveat we must fulfill. It is proving the uniqueness of states $q_{i,j}$.</p><h3 id=uniqueness>Uniqueness<a hidden class=anchor aria-hidden=true href=#uniqueness>#</a></h3><p>Let $q_{i,j}$ and $q_{i',j'}$ be any two arbitrary states, such that it is not the case $i=i' \wedge j=j'$. So, Either $i \neq i'$ or $j \neq j'$. For the former, It is obvious $q_{i,j} \neq q_{i',j'}$. Otherwise, A sole state would output both $i$ and $i'$. That does not conform with our notion of a state outputting a unique label. Let&rsquo;s consider the latter, $j \neq j'$. It is safe to assume $i = i'$ as we handled the case $i \neq i'$. If $q_{i,j} = q_{i,j'}$, Then the number of states which output $i$ is less than $i+1$. From the discussion above, It is clear that leads to a contradiction.</p><h3 id=space-bounds>Space Bounds<a hidden class=anchor aria-hidden=true href=#space-bounds>#</a></h3><p>At this point, We have shown there are $1+2+3+\dots+(n+1) = \frac{(n+2)(n+1)}{2} = \Omega(n^2)$ distinct states. It is easy to see that it is possible to construct a machine of $\frac{(n+2)(n+1)}{2} = \mathcal{O}(n^2)$ states, As shown in this section&rsquo;s diagram, That solves finding longest 1s sequence problem. Hence, A space tight-bound $\Theta(n^2)$ is proved.</p><h2 id=formal-proof>Formal Proof<a hidden class=anchor aria-hidden=true href=#formal-proof>#</a></h2><p>Instead of proving concrete examples as we did before, We present here a general proof. But we do not prove states&rsquo; uniqueness as we see the discussion of $\textit{informal proof}, {uniqueness}$ sufficies for that. Here we aim to provide a more mathematically matured illustration of states&rsquo; existince proof.</p><p>Before doing so, We give precise definitions of the finite automata and the problem we have been working through.</p><h3 id=definitions>Definitions<a hidden class=anchor aria-hidden=true href=#definitions>#</a></h3><h4 id=state-output-deterministic-finite-automata>State-Output Deterministic Finite Automata<a hidden class=anchor aria-hidden=true href=#state-output-deterministic-finite-automata>#</a></h4><p>$\textit{State-Output Deterministic Finite Automata}$ ($SODFA$) is a 6-tuple $(Q, \Sigma, \delta, q_0, F, L)$ where:</p><ul><li>$Q$ is a finite set called the states,</li><li>$\Sigma = \set{0, 1}$ is a finite set called the alphabet,</li><li>$\delta:Q \times \Sigma \rightarrow Q$ is the transition function,</li><li>$q_{st} \in Q$ is the start state, and</li><li>$F \subseteq Q$ is the set of accept states.</li><li>$L: F \rightarrow \set{0, 1, \dots}$ is a function which maps accept states to natural number. This function formalizes our intuitive notion of a state $q_{i,j}$ to output i.</li></ul><p>The $SODFA$ either accepts or rejects an input string $w$. In case of acceptance, It outputs $L(q')$ where $q'$ is the state the machine has halted on.</p><h4 id=longest-1s-sequence-problem>Longest 1s Sequence Problem<a hidden class=anchor aria-hidden=true href=#longest-1s-sequence-problem>#</a></h4><p>For an input binary string $w = \set{0, 1}^*$ of length $n \in \mathcal{N}$, It could be re-written as $0^{k_1}1^{k_2} \dots 0^{k_{n-1}}1^{k_{n}}0^{k_{n+1}}$, such that $\Sigma_i k_i = n$. $0^{k_{n+1}}$ is added so that this representation accommodates $w$ in case its first bit is 1.</p><p>The $\textit{Longest 1s Sequence}$ problem asks for a $SODFA$ machine to halt on an accept state $q'$ such that $L(q') = max \hspace{2mm} \set{\hspace{2mm} k_i \hspace{1mm} | \hspace{1mm} 1^{k_i} \hspace{0.5mm}\ \text{is a substring of} \hspace{2mm} w \hspace{2mm}}$.</p><h3 id=proof>Proof<a hidden class=anchor aria-hidden=true href=#proof>#</a></h3><p>We show:</p><p>For an arbitrary $SODFA$ machine $M$, if it solves $\textit{Longest 1s Sequence Problem}$ for inputs of size $n$, Then:
For any $0 \leq i \leq n$,</p><ul><li>(1) $q_{i, j} \in M(Q)$ for $0 \leq j \leq i$</li></ul><p>We solve (1) under the stated assumption.</p><p><strong>(1)</strong></p><p>Consider string $1^i01^{i+1}$. On configuration $1^i0q1^{i+1}$ for some $q$, $L(q)=i$. This conclusion is attributed to the fact that $M$ outputs $i$ upon reading $1^i0$. We call this $q_{i,0}$. If you are super math nerd, Then you might like to develop an $\textit{extended delta function}$ and solve this step more carefully by recursion.</p><p>For configurations $1^i01q1^{i}$, $1^i011q1^{i-1}$, &mldr;, $1^i01^{i}q1$, all states $q$ have the property that $L(q)=i$ for the exact same reason. We call them respectively $q_{i,1}, q_{i,2}, \dots, q_{i,i}$.</p><p>Those $q_{i,j}$ are distinct. For the sake of contradiction assume the contrary. Then there are two $q_{i,j0}$ and $q_{i,j1}$ equal to each other. Without the loss of generality let $j0 < j1$. Now there is a sequence of states $q_{i,j0}, \dots, q_{i,j1}$ such that reading $1$ bit while the machine is on any of them reaches the next one. If the machine reached $q_{i,j1}$ then it is in fact returned back again to $q_{i,j0}$. As a result, no matter how much $1$ bits are read, The machine&rsquo;s state is going to be within that sequence of states, and it would output $i$. So, Running $M$ on whole $1^i01^{i+1}$ string outputs $i$ which contradicts our definition of $M$ that it yields the correct answer.</p><p>Again, If you are super math nerd, Pick-up $q_{i,j0}$ then show by a trivial induction on z that the machine always outputs $i$ after reading $1^z$.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><strong>[MS]</strong> Michael Sipser. Introduction To The Theory of Computation. Cengage Learning.</li></ul><hr><h2 id=appendix>Appendix<a hidden class=anchor aria-hidden=true href=#appendix>#</a></h2><h3 id=fun-facts>Fun Facts<a hidden class=anchor aria-hidden=true href=#fun-facts>#</a></h3><p>I came upon the $\textit{DFA}$ which finds whether the number of 1 bits in a string is even or odd in $\textbf{[MS]}$&rsquo;s superb book. Then I thought of an obvious extension to it. A machine which finds the remainder of dividing on any number. Basically, For number $\textit{m}$, Designate $\textit{m}$ states, $q_0, q_1, \dots, q_{m-1}$ such that halting on $q_i$ indicates the remainder is $i$. This is where the new machine&rsquo;s construction of output came from!</p><p>Afterward, I tried to think of problems which are elegantly modeled on a $\textit{DFA}$ but lost hope due to the tedious work of encoding/decoding objects. Since automata works on binary bits, It seemed it is best to work on arithmetic problems. An obvious immediate one is finding the maximum number of an array. This is where the problem of finding the longest sequence of 1 came from!</p><p>Even more notably, I did not pick-up $\textbf{[MS]}$&rsquo;s book to find lower-bounds, As I know proving them is hard!</p><h3 id=paper-notes-of-surprise-moment>Paper Notes of Surprise Moment<a hidden class=anchor aria-hidden=true href=#paper-notes-of-surprise-moment>#</a></h3><p><img loading=lazy src=surprise-0.jpg alt=surprise-0.jpg>
<img loading=lazy src=surprise-1.jpg alt=surprise-1.jpg>
$\require{textmacros}$</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>