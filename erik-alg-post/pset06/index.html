<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 06 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
skipped in hope of professionally read while solving the exercises, and
well-gain from lectures.
Ex. 2
To definte shortest-path weight function $\delta$, which satisfies the triangle inequality, enabling the second property of $\overline{w}$.
Ex. 3
For a cycle $c = v_0, v_1, \dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.
Recall the facts

$\overline{w}(u,v) \geq 0$
$\overline{w}(u,v) = w(u,v) + h(u) - h(v)$
$\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$

Lemma.   $\Sigma \overline{w}(v_i, v_{i+1}) = 0$
"><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/erik-alg-post/pset06/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/erik-alg-post/pset06/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 06"><meta property="og:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
skipped in hope of professionally read while solving the exercises, and
well-gain from lectures.
Ex. 2
To definte shortest-path weight function $\delta$, which satisfies the triangle inequality, enabling the second property of $\overline{w}$.
Ex. 3
For a cycle $c = v_0, v_1, \dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.
Recall the facts

$\overline{w}(u,v) \geq 0$
$\overline{w}(u,v) = w(u,v) + h(u) - h(v)$
$\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$

Lemma.   $\Sigma \overline{w}(v_i, v_{i+1}) = 0$
"><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset06/"><meta property="article:section" content="erik-alg-post"><meta property="article:published_time" content="2023-06-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 06"><meta name=twitter:description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
skipped in hope of professionally read while solving the exercises, and
well-gain from lectures.
Ex. 2
To definte shortest-path weight function $\delta$, which satisfies the triangle inequality, enabling the second property of $\overline{w}$.
Ex. 3
For a cycle $c = v_0, v_1, \dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.
Recall the facts

$\overline{w}(u,v) \geq 0$
$\overline{w}(u,v) = w(u,v) + h(u) - h(v)$
$\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$

Lemma.   $\Sigma \overline{w}(v_i, v_{i+1}) = 0$
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Erik's Algorithms","item":"https://mostafatouny.github.io/erik-alg-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 06","item":"https://mostafatouny.github.io/erik-alg-post/pset06/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 06","name":"Problem Set 06","description":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 skipped in hope of professionally read while solving the exercises, and well-gain from lectures.\nEx. 2 To definte shortest-path weight function $\\delta$, which satisfies the triangle inequality, enabling the second property of $\\overline{w}$.\nEx. 3 For a cycle $c = v_0, v_1, \\dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.\nRecall the facts\n$\\overline{w}(u,v) \\geq 0$ $\\overline{w}(u,v) = w(u,v) + h(u) - h(v)$ $\\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$ Lemma. $\\Sigma \\overline{w}(v_i, v_{i+1}) = 0$\n","keywords":[],"articleBody":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 skipped in hope of professionally read while solving the exercises, and well-gain from lectures.\nEx. 2 To definte shortest-path weight function $\\delta$, which satisfies the triangle inequality, enabling the second property of $\\overline{w}$.\nEx. 3 For a cycle $c = v_0, v_1, \\dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.\nRecall the facts\n$\\overline{w}(u,v) \\geq 0$ $\\overline{w}(u,v) = w(u,v) + h(u) - h(v)$ $\\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$ Lemma. $\\Sigma \\overline{w}(v_i, v_{i+1}) = 0$\n$$\\begin{aligned} \\overline{w}(c) \u0026= w(c) + h(v_0) - h(v_k) \\\\\\\\ \u0026= 0 + h(v_0) - h(v_0), v_0=v_k \\\\\\\\ \u0026= 0 \\end{aligned}$$If any $\\overline{w}(v_i,v_{i+1}) \u003e 0$ then $\\overline{w}(c) \u003e 0$, contradicting the proved above lemma.\nEx. 4 skipped in hope of professionally read while solving the exercises, and well-gain from lectures.\nEx. 5 In page 636 there is a hint of using fibonacci-heabs. I am not sure whether it is the key of solving the problem. Anyway, The exercise is postponed untill we gain a guidance from others. Skimming the chapter did not yield any promising clue to pursue.\nEx. 6 Same as Ex. 5\nProblems Prob. 1 a Case $r = w_{i,j}$. Nothing to be done.\nCase $r \u003c w_{i,j}$. Check to see if new paths including edge $(i,j)$ offer less-weight.\n(For LaTeX issue we denote matrix $\\Pi$ by $P$)\nfor x = 0 to n for y = 0 to n if d_x,i + r + d_j,y \u003c d_x,y d_x,y = d_x,i + r + d_j,y P(x,j) = i P(x,y) = P(j,y) Observe $\\Pi(x,i)$ is the same, and same for its recursive vertices. Similarly to $\\Pi(j,y)$.\nComplexity. $\\mathcal{O}(V^2)$\nCase $r \u003e w_{i,j}$. For paths which do not depend on $w_{i,j}$, Nothing needs to be updated about them. If their paths are less or equal than any path which includes $w_{i,j}$ then obviously these paths are still optimal when the weight of $w_{i,j}$ increases. If for vertex $x$, $P(x,j) != i$ then $x$ shall never visit edge $\\set{i,j\\}$.\nOur focus starts on vertices $x$ whose $\\Pi(x,j)$ equals $i$. For each such $x$ and each arbitrary vertex $y$, We compute minimum paths from $x$ to $y$ and update if needed. Let $D'$ and $\\Pi'$ denote minimum distance and predecessor matrices after updating the weight of edge $\\set{i,j\\}$ to $r$, respectively. Any path $x \\rightarrow y$ either consists of a single edge $\\set{x,y\\}$ or contains an intermediate vertex between $x$ and $y$. We loop on all vertices $z$ to compute $D(x,z) + D(z,y)$ and then set $D'(x,y)$. However, we must check whether edge $\\set{i,j\\}$ falls into the path $x \\rightarrow z$ or $z \\rightarrow y$. if NO, then we know $D'(x,z) = D(x,z)$ and $D'(z,y) = D(z,y)$. If YES, then the new weight of path $x \\rightarrow y$ which equals $D(x,y) + (r-w_{i,j})$, is equal or less than the new weight $D(x,z) + D(z,y) + (r - w_{i,j})$. That follows by $D(x,y) \\leq D(x,z) + D(z,y)$ as the additional weight $r - w_{i,j}$ is added on both sides of the inequality. In this case we know $z$ won’t offer a less-weight path. So we can restrict our focus on vertices $z$ whose corresponding paths do not include edge $\\set{i,j\\}$.\n(For LaTeX issues we denote matrix $\\Pi$ by $P$)\nisEdgeInPath(edge {i,j}, path x -\u003e y, predecessor P) if P(x,j) != i return False s = y while P(x,s) != x if P(x,s) == j return False return True Main() for x = 0 to n if P(x,j) = i for y = 0 to n minDistance = min{ edge (x,y) if exists, D(x,y) + (r - w_i,j) } minVertex = NULL isDistanceUpdated = False for z = 0 to n if isEdgeInPath( {i,j}, x -\u003e y, P) OR z = x OR z = y continue to next iteration of z zDistance = D(x,z) + D(z,y) if (distance \u003c minDistance) minDistance = zDistance minVertex = z isDistanceUpdated = True if isDistanceUpdated P'(x,y) = P(z,y) P'(x,z) = P(x,z) Complexity. $\\mathcal{O}(V^3)$\nb c In the same mannger matrices $M$ and $\\Pi$ are maintainces distances and predecessors, We maintain also matrix $W$ for the number of edges corresponding to $d_{i,j}$ in $M$. The algorithm then checks $W$ before updating a new solution whether its number of edges is at most $h$.\nComplexity. The overhead is constant over the original algorithm. In terms of parameters and $h$ is postponed.\nd The algorithm constructs a series of matrices $L^1, L^2, .., L^{n-1}$ where $L^m = \\left ( l_{ij}^m \\right )$, indicating shortest-paths of edges length at most $m$. The adapted algorithm terminates on $L^{h}$ and outputs it.\nComplexity. At most the complexity of the original algorithm.\ne Prob. 2 a We prove if there are two different minimum spanning trees, $T_a$ and $T_b$, Then we can construct a minimum spanning tree $T_c$ whose weight is less than either of them.\nWe define:\n$E_a = T_a(E)$ $E_b = T_b(E)$ $E_c = E_a \\cap E_b$ $E_{a-b} = E_a - E_b$ $E_{b-a} = E_b - E_a$ $E_{-c} = E_{a-b} \\cup E_{b-a}$ $e_{a}$, An edge in $E_a$ $e_{a0}$, An edge in $E_{a-b}$ Lemma. For an edge $e_{a0} = \\{x,y\\}$, $x$ and $y$ are connected by a path in $T_b$ which does not include edge $e_{a0}$. Similarly for $e_{b0}$.\nFollows immediately as by definition $e_{a0} \\not\\in E_b$.\nLemma. For an edge $e_{a0} = \\{x,y\\}$, There exists distinct edges $e_{b}^1$ and $e_{b}^2$ such that $e_b^1$ joins $x$ and $e_b^2$ joins $y$ in $E_b$. Similarly for $e_{b0}$.\nFollows immediately by Lemma 1. Note the two edges $e_{b}^1$ and $e_{b}^2$ can share at most one vertix.\nLemma. If there is a cycle where all edges are in $E_a$ except exactly one edge $e_b$ in $E_b$, and $w(e_b) \u003c w(e_a^i)$ for some $e_a^i$ in the cycle, then we can construct a MST $T_a' = T_a - e_a^i + e_b$ of weight less than $T_a$\nConsider two vertices, $v_1$ and $v_2$, whose connectivity relies on edge $e_a^i = \\{x,y\\}$. The path is $p(v_1,x), (x,y), p(y,v_2)$. By adding $e_b$ we know there is path $p_0(x,y) \\neq (x,y)$, i.e $x$ can reach $y$ without edge $(x,y)$. Therefore we can form an alternative path for $v_1$ and $v_2$ without relying on $(x,y)$ by $p(v_1,x), p_0(x,y), p(y,v_2)$. Thus, Removing $e_a^i$ is safe. Note It is clear neither $p(v_1,x)$ nor $p(v_2,x)$ contains edge $(x,y)$ as that means there is an unnecessary cycle in the path.\nClearly $E_{-c}$ is non-empty, Otherwise $T_a = T_b$. Without the loss of generality, Assume the selected element of $E_{-c}$ is $\\{x,z\\} = e_{a0} \\in E_{a-b}$. There are only two cases regarding the weight of $e_{a0}$.\nCase 1: $w(e_{a0}) = 0$. By Lemma 1 we know there is a path $p(x,y)$ which does not include $e_{a0}$. Clearly have a circle of, edges in $E_b$ and exactly one edge in $E_a$. Since all weights of the graph are distinct and non-negative, $w(e_{a0})$ is strictly less than all edges in the circle. By Lemma 3, We can form a lower-weight MST. Contradiction.\nCase 2: $w(e_{a0}) \u003e 0$. By Lemma 2 we get edges $e_{b}^1$ and $e_{b}^2$ in $E_b$ where they contain vertices $x$ and $y$. Clearly it is not possible for both $e_b^1$ and $e_b^2$ to be in $E_a$. Otherwise we would have a cycle in $T_a$ contradicting the fact a tree has no cycles. It is easy to justify it by considering $T_a' = T_a - e_{a0}$. Without the loss of generality assume $e_b^1 \\not\\in E_a$, i.e $e_b^1 = e_{b0}^1$. Denote $e_{b0}^1$ by $\\{y,z\\}$.\nWe claim there is a cycle of edges including $e_{b0}$ and $e_{a0}$, Where all remaining edges are in $E_a$. By connectivity of $T_a$ we know there is a path in $T_a$ between $x$ and $z$. Note the cycle is totally legit if it contained $y$. Similarly, There is a cycle of edges including $e_{a0}$ and $e_{b0}$, Where all remainig edges are in $E_b$.\nWe know $e_{a0} \\neq e_{b0}$. In either cases some edge is greater than the other. By Lemma 3, We get a lower-weight spanning tree. Contradiction.\nb Correctness. For any graph $G$, There is a unique sub-graph $G_c$, Such that for any cycle $c$ in $G$ whose all edges are in $G_c$ except for exactly one edge $e_x$, The weight of $e_x$ is the maximum along the whole cycle of $c$. The proof is nearly identical to a.\nClearly the MST exerts this property lest we construct another spanning-tree of less weight. Since the algorithm claimed here always prefers less-weight edges, It shall never contradict that property also. By uniqueness the claimed algorithm yields the MST.\nAlgorithm Description.\nComplexity Analysis.\nc Counter-example:\nd Correctness. Yes. The proof is nearly identical to a.\nAlgorithm Description.\n","wordCount":"1442","inLanguage":"en","datePublished":"2023-06-10T00:00:00Z","dateModified":"2023-06-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/erik-alg-post/pset06/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 06</h1><div class=post-meta><span title='2023-06-10 00:00:00 +0000 UTC'>June 10, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exercises aria-label=Exercises>Exercises</a><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a></li><li><a href=#ex-2 aria-label="Ex. 2">Ex. 2</a></li><li><a href=#ex-3 aria-label="Ex. 3">Ex. 3</a></li><li><a href=#ex-4 aria-label="Ex. 4">Ex. 4</a></li><li><a href=#ex-5 aria-label="Ex. 5">Ex. 5</a></li><li><a href=#ex-6 aria-label="Ex. 6">Ex. 6</a></li></ul></li><li><a href=#problems aria-label=Problems>Problems</a><ul><li><a href=#prob-1 aria-label="Prob. 1">Prob. 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li><li><a href=#e aria-label=e>e</a></li></ul></li><li><a href=#prob-2 aria-label="Prob. 2">Prob. 2</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li><li><a href=#c-1 aria-label=c>c</a></li><li><a href=#d-1 aria-label=d>d</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p><h2 id=exercises>Exercises<a hidden class=anchor aria-hidden=true href=#exercises>#</a></h2><h3 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h3><p>skipped in hope of professionally read while solving the exercises, and
well-gain from lectures.</p><h3 id=ex-2>Ex. 2<a hidden class=anchor aria-hidden=true href=#ex-2>#</a></h3><p>To definte shortest-path weight function $\delta$, which satisfies the triangle inequality, enabling the second property of $\overline{w}$.</p><h3 id=ex-3>Ex. 3<a hidden class=anchor aria-hidden=true href=#ex-3>#</a></h3><p>For a cycle $c = v_0, v_1, \dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.</p><p>Recall the facts</p><ol><li>$\overline{w}(u,v) \geq 0$</li><li>$\overline{w}(u,v) = w(u,v) + h(u) - h(v)$</li><li>$\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$</li></ol><p><strong>Lemma.</strong>   $\Sigma \overline{w}(v_i, v_{i+1}) = 0$<br></p>$$\begin{aligned}
\overline{w}(c) &= w(c) + h(v_0) - h(v_k) \\\\
  &= 0 + h(v_0) - h(v_0), v_0=v_k \\\\
&= 0
\end{aligned}$$<p>If any $\overline{w}(v_i,v_{i+1}) > 0$ then $\overline{w}(c) > 0$,
contradicting the proved above lemma.</p><h3 id=ex-4>Ex. 4<a hidden class=anchor aria-hidden=true href=#ex-4>#</a></h3><p>skipped in hope of professionally read while solving the exercises, and well-gain from lectures.</p><h3 id=ex-5>Ex. 5<a hidden class=anchor aria-hidden=true href=#ex-5>#</a></h3><p>In page 636 there is a hint of using <em>fibonacci-heabs</em>. I am not sure whether it is the key of solving the problem. Anyway, The exercise is postponed untill we gain a guidance from others. Skimming the chapter did not yield any promising clue to pursue.</p><h3 id=ex-6>Ex. 6<a hidden class=anchor aria-hidden=true href=#ex-6>#</a></h3><p>Same as <em>Ex. 5</em></p><h2 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h2><h3 id=prob-1>Prob. 1<a hidden class=anchor aria-hidden=true href=#prob-1>#</a></h3><h4 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h4><p>Case $r = w_{i,j}$. Nothing to be done.</p><p>Case $r < w_{i,j}$. Check to see if new paths including edge $(i,j)$
offer less-weight.</p><p>(For LaTeX issue we denote matrix $\Pi$ by $P$)</p><pre><code>for x = 0 to n
  for y = 0 to n
    if d_x,i + r + d_j,y &lt; d_x,y
      d_x,y = d_x,i + r + d_j,y
      P(x,j) = i
      P(x,y) = P(j,y)
</code></pre><p>Observe $\Pi(x,i)$ is the same, and same for its recursive vertices.
Similarly to $\Pi(j,y)$.</p><p><em>Complexity.</em> $\mathcal{O}(V^2)$</p><p>Case $r > w_{i,j}$. For paths which do not depend on $w_{i,j}$, Nothing
needs to be updated about them. If their paths are less or equal than
any path which includes $w_{i,j}$ then obviously these paths are still
optimal when the weight of $w_{i,j}$ increases. If for vertex $x$,
$P(x,j) != i$ then $x$ shall never visit edge $\set{i,j\}$.</p><p>Our focus starts on vertices $x$ whose $\Pi(x,j)$ equals $i$. For each such $x$ and each arbitrary vertex $y$, We compute minimum paths from $x$ to $y$ and update if needed. Let $D'$ and $\Pi'$ denote minimum distance and predecessor matrices after updating the weight of edge $\set{i,j\}$ to $r$, respectively. Any path $x \rightarrow y$ either consists of a single edge $\set{x,y\}$ or contains an intermediate vertex between $x$ and $y$. We loop on all vertices $z$ to compute $D(x,z) + D(z,y)$ and then set $D'(x,y)$. However, we must check whether edge $\set{i,j\}$ falls into the path $x \rightarrow z$ or $z \rightarrow y$. if NO, then we know $D'(x,z) = D(x,z)$ and $D'(z,y) = D(z,y)$. If YES, then the new weight of path $x \rightarrow y$ which equals $D(x,y) + (r-w_{i,j})$, is equal or less than the new weight $D(x,z) + D(z,y) + (r - w_{i,j})$. That follows by $D(x,y) \leq D(x,z) + D(z,y)$ as the additional weight $r - w_{i,j}$ is added on both sides of the inequality. In this case we know $z$ won&rsquo;t offer a less-weight path. So we can restrict our focus on vertices $z$ whose corresponding paths do not include edge $\set{i,j\}$.</p><p>(For LaTeX issues we denote matrix $\Pi$ by $P$)</p><pre tabindex=0><code>isEdgeInPath(edge {i,j}, path x -&gt; y, predecessor P)
      if P(x,j) != i
        return False

      s = y
      while P(x,s) != x
        if P(x,s) == j
          return False

      return True

Main()
      for x = 0 to n
        if P(x,j) = i
          for y = 0 to n
            minDistance = min{ edge (x,y) if exists, D(x,y) + (r - w_i,j) }
            minVertex = NULL
            isDistanceUpdated = False
            for z = 0 to n
              if isEdgeInPath( {i,j}, x -&gt; y, P) OR z = x OR z = y
                continue to next iteration of z

              zDistance = D(x,z) + D(z,y)
              if (distance &lt; minDistance)
                minDistance = zDistance
                minVertex = z
                isDistanceUpdated = True

             if isDistanceUpdated
               P&#39;(x,y) = P(z,y)
               P&#39;(x,z) = P(x,z)
</code></pre><p><strong>Complexity.</strong> $\mathcal{O}(V^3)$</p><h4 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h4><p><img loading=lazy src=3.jpg alt=image></p><h4 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h4><p>In the same mannger matrices $M$ and $\Pi$ are maintainces <em>distances</em>
and <em>predecessors</em>, We maintain also matrix $W$ for the number of edges
corresponding to $d_{i,j}$ in $M$. The algorithm then checks $W$ before
updating a new solution whether its number of edges is at most $h$.</p><p><strong>Complexity.</strong> The overhead is constant over the original algorithm. In
terms of parameters and $h$ is postponed.</p><h4 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h4><p>The algorithm constructs a series of matrices $L^1, L^2, .., L^{n-1}$
where $L^m = \left ( l_{ij}^m \right )$, indicating shortest-paths of
edges length at most $m$. The adapted algorithm terminates on $L^{h}$
and outputs it.</p><p><strong>Complexity.</strong> At most the complexity of the original algorithm.</p><h4 id=e>e<a hidden class=anchor aria-hidden=true href=#e>#</a></h4><h3 id=prob-2>Prob. 2<a hidden class=anchor aria-hidden=true href=#prob-2>#</a></h3><h4 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h4><p>We prove if there are two different minimum spanning trees, $T_a$ and $T_b$, Then we can construct a minimum spanning tree $T_c$ whose weight is less than either of them.</p><p>We define:</p><ul><li>$E_a = T_a(E)$</li><li>$E_b = T_b(E)$</li><li>$E_c = E_a \cap E_b$</li><li>$E_{a-b} = E_a - E_b$</li><li>$E_{b-a} = E_b - E_a$</li><li>$E_{-c} = E_{a-b} \cup E_{b-a}$</li><li>$e_{a}$, An edge in $E_a$</li><li>$e_{a0}$, An edge in $E_{a-b}$</li></ul><p><strong>Lemma.</strong>   For an edge $e_{a0} = \{x,y\}$, $x$ and $y$ are connected by a path in $T_b$ which does not include edge $e_{a0}$. Similarly for $e_{b0}$.</p><p>Follows immediately as by definition $e_{a0} \not\in E_b$.</p><p><strong>Lemma.</strong>   For an edge $e_{a0} = \{x,y\}$, There exists distinct edges $e_{b}^1$ and $e_{b}^2$ such that $e_b^1$ joins $x$ and $e_b^2$ joins $y$ in $E_b$. Similarly for $e_{b0}$.</p><p>Follows immediately by <em>Lemma 1</em>. Note the two edges $e_{b}^1$ and $e_{b}^2$ can share at most one vertix.</p><p><strong>Lemma.</strong>   If there is a cycle where all edges are in $E_a$ except exactly one edge $e_b$ in $E_b$, and $w(e_b) < w(e_a^i)$ for some $e_a^i$ in the cycle, then we can construct a MST $T_a' = T_a - e_a^i + e_b$ of weight less than $T_a$</p><p>Consider two vertices, $v_1$ and $v_2$, whose connectivity relies on edge $e_a^i = \{x,y\}$. The path is $p(v_1,x), (x,y), p(y,v_2)$. By adding $e_b$ we know there is path $p_0(x,y) \neq (x,y)$, i.e $x$ can reach $y$ without edge $(x,y)$. Therefore we can form an alternative path for $v_1$ and $v_2$ without relying on $(x,y)$ by $p(v_1,x), p_0(x,y), p(y,v_2)$. Thus, Removing $e_a^i$ is safe. Note It is clear neither $p(v_1,x)$ nor $p(v_2,x)$ contains edge $(x,y)$ as that means there is an unnecessary cycle in the path.</p><p>Clearly $E_{-c}$ is non-empty, Otherwise $T_a = T_b$. Without the loss of generality, Assume the selected element of $E_{-c}$ is $\{x,z\} = e_{a0} \in E_{a-b}$. There are only two cases regarding the weight of $e_{a0}$.</p><p><img loading=lazy src=0.jpg alt=image></p><p><strong>Case 1:</strong> $w(e_{a0}) = 0$. By <em>Lemma 1</em> we know there is a path $p(x,y)$ which does not include $e_{a0}$. Clearly have a circle of, edges in $E_b$ and exactly one edge in $E_a$. Since all weights of the graph are distinct and non-negative, $w(e_{a0})$ is strictly less than all edges in the circle. By <em>Lemma 3</em>, We can form a lower-weight MST. Contradiction.</p><p><strong>Case 2:</strong> $w(e_{a0}) > 0$. By <em>Lemma 2</em> we get edges $e_{b}^1$ and $e_{b}^2$ in $E_b$ where they contain vertices $x$ and $y$. Clearly it is not possible for both $e_b^1$ and $e_b^2$ to be in $E_a$. Otherwise we would have a cycle in $T_a$ contradicting the fact a tree has no cycles. It is easy to justify it by considering $T_a' = T_a - e_{a0}$. Without the loss of generality assume $e_b^1 \not\in E_a$, i.e
$e_b^1 = e_{b0}^1$. Denote $e_{b0}^1$ by $\{y,z\}$.</p><p>We claim there is a cycle of edges including $e_{b0}$ and $e_{a0}$, Where all remaining edges are in $E_a$. By connectivity of $T_a$ we know there is a path in $T_a$ between $x$ and $z$. Note the cycle is totally legit if it contained $y$. Similarly, There is a cycle of edges including $e_{a0}$ and $e_{b0}$, Where all remainig edges are in $E_b$.</p><p>We know $e_{a0} \neq e_{b0}$. In either cases some edge is greater than the other. By <em>Lemma 3</em>, We get a lower-weight spanning tree. Contradiction.</p><h4 id=b-1>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h4><p><strong>Correctness.</strong> For any graph $G$, There is a unique sub-graph $G_c$, Such that for any cycle $c$ in $G$ whose all edges are in $G_c$ except for exactly one edge $e_x$, The weight of $e_x$ is the maximum along the whole cycle of $c$. The proof is nearly identical to <em>a</em>.</p><p>Clearly the MST exerts this property lest we construct another spanning-tree of less weight. Since the algorithm claimed here always prefers less-weight edges, It shall never contradict that property also. By uniqueness the claimed algorithm yields the MST.</p><p><strong>Algorithm Description.</strong></p><p><strong>Complexity Analysis.</strong></p><h4 id=c-1>c<a hidden class=anchor aria-hidden=true href=#c-1>#</a></h4><p>Counter-example:</p><p><img loading=lazy src=2.jpg alt=image></p><h4 id=d-1>d<a hidden class=anchor aria-hidden=true href=#d-1>#</a></h4><p><strong>Correctness.</strong> Yes. The proof is nearly identical to <em>a</em>.</p><p><strong>Algorithm Description.</strong></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>