<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 01 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="Problem 1
a
Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\{v_1,v_2\}, \{v_2, v_3\}$.
The optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.
b
Since the graph is given to be acyclic, Each neighbour of the graph&rsquo;s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/erik-alg-post/pset01/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/erik-alg-post/pset01/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 01"><meta property="og:description" content="Problem 1
a
Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\{v_1,v_2\}, \{v_2, v_3\}$.
The optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.
b
Since the graph is given to be acyclic, Each neighbour of the graph&rsquo;s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset01/"><meta property="article:section" content="erik-alg-post"><meta property="article:published_time" content="2023-02-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 01"><meta name=twitter:description content="Problem 1
a
Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\{v_1,v_2\}, \{v_2, v_3\}$.
The optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.
b
Since the graph is given to be acyclic, Each neighbour of the graph&rsquo;s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Erik's Algorithms","item":"https://mostafatouny.github.io/erik-alg-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 01","item":"https://mostafatouny.github.io/erik-alg-post/pset01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 01","name":"Problem Set 01","description":"Problem 1 a Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\\{v_1,v_2\\}, \\{v_2, v_3\\}$.\nThe optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.\nb Since the graph is given to be acyclic, Each neighbour of the graph\u0026rsquo;s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees.\n","keywords":[],"articleBody":"Problem 1 a Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\\{v_1,v_2\\}, \\{v_2, v_3\\}$.\nThe optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.\nb Since the graph is given to be acyclic, Each neighbour of the graph’s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees.\nWe design a divide and conquer algorithm where solutions to smaller subtrees can be merged for a larger subtree.\nThe base case is when the tree has only one vertex, where optimal subset contains only that vertex.\nAssuming we know solutions of subtrees, How can we merge? Observe the optimal subset of the whole tree either\n(1) Contains the root (2) Does not contain the root For (2), The optimal solution of the whole tree is the sum of all subtrees’ optimal profits. Assume for the sake of contradiction that is not the case. Then there are different selections of vertices with overall greater profit. Since by definition we are assuming whole tree’s root to be excluded, We know the different selection is in one of the subtrees. We know also that subtree’s new total profit is greater, But that contradicts the fact subtree is given optimal in the first place to us.\nFor (1), The tricky part comes into play. If we restricted our scope only on a subtree, Then It is possible to choose a non-optimal subset, As it shall be better integrated with the bigger subtree, Yielding a greater profit for the bigger subtree. Particularly, That happens if we had to include the new root in the subset and exclude the subtree’s root.\nThe key is to have this information given to us by the main algorithm. So we let it compute also optimal possible profit under the assumption root is excluded. With that in our pocket we can compute the whole big tree’s optimal subset profit assuming it contains the root.\nSpecifically, we loop on each given subtree and check whether root is included in optimal solution. If not, we add subtree’s optimal profit. If yes we add subtree’s optimal profit under the assumption subtree’s root is excluded.\nFinally we select the maximum of case (1) and case (2) and return it as the optimal solution.\nObserve we have covered all possible cases by such a simple trick!\nExample\nBlack number indicates profit of a single vertex, and red is the optimal profit of the vertice’s subtree.\nFor the first tree, Case (1) is maximum, and for the second tree, Case (2) is maximum.\nPsuedo Code\noptimalSubsetProfit(tree G, tree root v_r) if (verticesNumber(G) == 1) return (True, profit(v_r), profit(v_r)) subtreesOptimalData = () for v_neig in neighbours(v_r) out = (optimalProfit, isRootIncluded, profitRootExcluded) = optimalSubsetProfit(subtree(v_neig), v_neih) subtreesOptimalData.append(out) profitRootExcluded = 0 for subtree in subtreesOptimalData profitRootExluded += subtree.optimalProfit profitRootIncluded = 0 for subtree in subtreesOptimalData if subtree.isRootIncluded == False profitRootIncluded += subtree.optimalProfit else profitRootIncluded += subtree.profitRootExcluded optimalProfit = max{profitRootExcluded, profitRootIncluded} if optimalProfit == profitRootExcluded isRootIncluded = False else isRootIncluded = True return optimalProfit, isRootIncluded, profitRootExcluded c Remark Stacks’ Vertices Number\nThink of the given graph as levels of stacks from bottom to top as shown below\nObserve the number of vertices in a stack must be equal or greater than the number of its preceeding stack. So, final stack of leafs is the greatest.\nAlgorithm Description\nInclude the bottom most stack in solution subset. Ignore the preceeding stack, As every vertex in it is adjacent to some selected vertex. Include the preceeding stack in solution subset. Continue similarly untill the whole graph is covered By alternatively toggling between stacks, We ensure no adjacent vertices are selected, and we greedily select stacks of greatest number of vertices.\nPsuedo-code\noptimalProfit(tree G, tree's root v_r) if G contains one vertex return (True, 1) someChildIncluded = False count = 0 for each child v_chi of root v_r (isChildIncluded, childCount) = optimalProfit(G, v_chi) if isChildIncluded == True someChildIncluded = True increase count by childCount if someChildIncluded == True return (False, count) else return (True, count+1) Complexity $\\log(n)$\nProof\nTheorem. 1 If the given graph contains only vertices with at most 1 child branch, Then the algorithm selects maximum number of valid vertices.\nNote the graph in this case is basically a linear path of vertices. Note also the number of vertices selected by our algorithm is $\\lceil \\frac{n}{2} \\rceil$, where $n$ is the number of graph’s vertices.\nIt sufficies to show if there is any selection subset $U$ whose number of vertices is more than $\\lceil \\frac{n}{2} \\rceil$, Then $U$ contains two adjacent vertices. The proof is by induction on $n$.\nThe base case of $n = 2$ is trivial. Assume the statement holds for $k \\geq 2$, and consider an arbitrary graph $G$ where $n = k+1$.\nConsider an arbitrary $X \\subseteq G(V)$ with vertices number at least $\\lceil \\frac{k+1}{2} \\rceil + 1$. Our goal now is to prove the existince of two adjacent vertices in $X$. By removing a leaf from $G$ we obtain a graph $G'$ whose number of vertices is $n' = n - 1 = k + 1 - 1 = k$. Define $X'$ to be $X \\cap G'(V)$. Observe $X'$ contains at least $\\lceil \\frac{k+1}{2} \\rceil + 1 - 1 = \\lceil \\frac{k+1}{2} \\rceil = \\lceil \\frac{k}{2} \\rceil + 1$ vertices. By the induction hypothesis it follows $X'$ contains two adjacent vertices, And so does $X$.\nDefinition. 1 multiLinearLeafsParent and branchPath\nFor any vertex v, If all its child generations have degree at most 2, Then we call it multiLinearLeafsParent. Note on any branch l, Vertices constiute a linear path from v and upto the leaf. We call that path branchPath(v, l).\nLemma. 1\nIf a vertex v contains more than one branch for children, and it is multiLinearLeafsParent, Then\n1.1 If for any branches l, The length of branchPath(v, l) is odd, Then v is selected by the algorithm. 1.2 If for some branch l, The length of branchPath(v, l) is even, Then v is ignored by the algorithm. Lemma. 2 If the given graph contains a vertex with more than 2 child branches, and a new graph $G'$ is constructed by removing either\n$(1)$ Two bottom most vertices from odd length branchPath $l_0$, or $(2)$ One leaf from an even length branchPath, From some vertex $v_0$ which has at least two branches, Then the algorithm’s selections on $G'$, are also selected on $G$.\nSelect that given vertex which has more than 2 child branches, and call it $v_0$. Call its branches $l_1, l_2, \\dots, l_m$.\nFor case $(1)$, The new pruned branch is still of odd length. It is fine if the branch is completely removed also. Since parity of branches are reserved, By Lemma. 1, the algorithm makes the same choice on $v_0$ for both $G$ and $G'$ graphs.\nNote in case the branch is completely removed, Then the choice on $v_0$ is totally dependent on other branches. If there is another even length branch then ignoring $v_0$ is reserved on $G'$; If all branches are of odd length then selecting $v_0$ is reserved also. All these cases follow by Lemma. 1.\nFor case $(2)$, We know there is another even length branch in $G'$, and by Lemma. 1, the algorithm ignores $v_0$ on both $G$ and $G'$ graphs.\nTheorem. 2 If the given graph contains a vertex with more than 2 child branches, Then the algorithm selects maximum number of valid vertices.\nThe proof is by strong induction. The base case of $n = 3$ vertices is trivial (if you are super nerd, for $n$ less than $3$, It is vacuously true). Assume the statement holds for $k \\leq p$ where $p \\geq 3$, and consider arbitrary graph where number of vertices $n$ is $k+1$.\nCall the count the algorithm produces $p$. Assume for the sake of contradiction there is a valid selection $X$ of vertices with count at least $p + 1$.\nSelect that given vertex which has more than 2 child branches promised by the theorem’s hypothesis, and call it $v_0$. Call its branches $l_1, l_2, \\dots, l_m$.\nWe are ahead of two cases\n$(1)$ For some branch $l_0$, length of $branchPath(v_0, l_0)$ is odd $(2)$ For any branch $l_i$, length of $branchPath(v_0, l_i)$ is even For $(1)$, Construct a new graph $G'$ where the two bottom most vertices are removed from $l_0$.\nNote existince of at least 2 vertices along the branch is ensured by the definition of branch’s existince; There is no odd branch of path length equal to 1.\nNote also exactly one vertex of the selected two vertices is in $X$, The optimal selection of $G$, As the two vertices are adjacent.\nBy Lemma. 2, Selections made on $G'$ are exactly the same as selections made on $G$ by the algorithm, Except on $G$ there is an additional leaf selected. So selections number $p=p'+1$.\nDefine $X' = X \\cap G'(V)$. At most one vertex selected by the algorithm on $G$ is in $X$ but not in $X'$. So $X'$ has at least $p+1-1=p$ vertices. But we have just established $p=p'+1$, Thus $X'$ has at least $p'+1$ vertices.\nNumber of vertices in $G'$ is $n-2 = k+1-2 = k-1$. By the induction hypothesis, $p'$, The number of selections made by the algorithm, is the greatest valid solution for $G'$.\nContradiction, as $X'$ is a valid solution for $G'$.\nFor $(2)$, We fix some branch $l_0$ and construct a new graph $G'$ where leaf of $l_0$ is removed.\nBy a very similar reasoning a contradiction is reached.\nCorollary. 1 The algorithm produces a the maximum number of selections, Generally\nFollows immediately by theorem 1 and theorem 2.\nd Remark Redundant Subproblem\nIf considered the subset marked by a red rectangle, We notice we are left with exploring remaining search space of $v_1, v_2$. We see two different subsets with the same search subspace, Which is redundant. Moreover, The left subset’s profit is $9$ while the right subset’s profit is $10$. So we can safely assure the right subset is yielding a better solution.\nThis observation clearly suggests an algorithm based on dynamic programming. It also suggests a subproblem defined in terms of profit and remaining graph vertices.\nTable\nOur algorithm is initialized on row = 0 and maxRowProfit = 0\nAlgorithm Description\nFor each row, we loop on all remaining graph subsets alongside their memoized profits. Then for the remaining graph selected, and for each vertex of it, We sum its profit to previous total profit and remove the vertex from remaining graph, to generate a new solution.\nPsuedo-code\noptimalProfit(row, maxRowProfit) if row == n return maxRowProfit maxNextRowProfit = -1 for each ith profit of table[row, ] for each vertex v of ith graph subset totalProfit = profit + v.profit remGra = removeAdj(ith graph subset, v) if table[row+1, remGra] \u003c totalProfit table[row+1, remGra] = totalProfit if table[row+1, remGra] \u003e maxNextRowProfit maxNextRowProfit = totalProfit if maxNextRowProfit == -1 return maxRowProfit optimalProfit(row+1, maxNextRowProfit) Note the algorithm can be trivially extended to output the solution subset by outputting $G(V)$ - $remGra$, where $remGra$ is the last remaining graph found by the algorithm.\nProblem 2 a Maximum distance between two requests $r_i$ and $r_j$ is $\\sqrt{(1/2)^2 + (1/2)^2} = \\sqrt{1/4 + 1/4} = 1\\sqrt{2} \\leq 1$\nb Algorithm Description\nRecursively the algorithm divides requests into nine sub problems. The first four calls cover all requests, but we also need to check a subproblem between each pair of those four. The base case is when the square length is $1/2$, and if two requests are within the square, Then the algorithm terminates as given requests are not valid.\nIt is not hard to see why those calls between each pair of the first four are necessary and sufficient to merge.\nWe don’t see a need for specifying a psuedo-code (and my time is limited to write all details).\nc Exactly the same as b but on the base case, The algorithm checks whether there are three requests within the square.\n","wordCount":"2018","inLanguage":"en","datePublished":"2023-02-05T00:00:00Z","dateModified":"2023-02-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/erik-alg-post/pset01/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 01</h1><div class=post-meta><span title='2023-02-05 00:00:00 +0000 UTC'>February 5, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#problem-1 aria-label="Problem 1">Problem 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li></ul></li><li><a href=#problem-2 aria-label="Problem 2">Problem 2</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li><li><a href=#c-1 aria-label=c>c</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=problem-1>Problem 1<a hidden class=anchor aria-hidden=true href=#problem-1>#</a></h2><h3 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h3><p>Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\{v_1,v_2\}, \{v_2, v_3\}$.</p><p>The optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.</p><h3 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h3><p>Since the graph is given to be acyclic, Each neighbour of the graph&rsquo;s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees.</p><p>We design a divide and conquer algorithm where solutions to smaller subtrees can be merged for a larger subtree.</p><p>The base case is when the tree has only one vertex, where optimal subset contains only that vertex.</p><p>Assuming we know solutions of subtrees, How can we merge? Observe the optimal subset of the whole tree either</p><ul><li>(1) Contains the root</li><li>(2) Does not contain the root</li></ul><p>For (2), The optimal solution of the whole tree is the sum of all subtrees&rsquo; optimal profits. Assume for the sake of contradiction that is not the case. Then there are different selections of vertices with overall greater profit. Since by definition we are assuming whole tree&rsquo;s root to be excluded, We know the different selection is in one of the subtrees. We know also that subtree&rsquo;s new total profit is greater, But that contradicts the fact subtree is given optimal in the first place to us.</p><p>For (1), The tricky part comes into play. If we restricted our scope only on a subtree, Then It is possible to choose a non-optimal subset, As it shall be better integrated with the bigger subtree, Yielding a greater profit for the bigger subtree. Particularly, That happens if we had to include the new root in the subset and exclude the subtree&rsquo;s root.</p><p>The key is to have this information given to us by the main algorithm. So we let it compute also optimal possible profit under the assumption root is excluded. With that in our pocket we can compute the whole big tree&rsquo;s optimal subset profit assuming it contains the root.</p><p>Specifically, we loop on each given subtree and check whether root is included in optimal solution. If not, we add subtree&rsquo;s optimal profit. If yes we add subtree&rsquo;s optimal profit under the assumption subtree&rsquo;s root is excluded.</p><p>Finally we select the maximum of case (1) and case (2) and return it as the optimal solution.</p><p>Observe we have covered all possible cases by such a simple trick!</p><p><strong>Example</strong></p><p>Black number indicates profit of a single vertex, and red is the optimal profit of the vertice&rsquo;s subtree.</p><p>For the first tree, Case (1) is maximum, and for the second tree, Case (2) is maximum.</p><p><img loading=lazy src=./screen_0.jpg alt>
<img loading=lazy src=./screen_1.jpg alt></p><p><strong>Psuedo Code</strong></p><pre tabindex=0><code>optimalSubsetProfit(tree G, tree root v_r)
  if (verticesNumber(G) == 1)
    return (True, profit(v_r), profit(v_r))

  subtreesOptimalData = ()

  for v_neig in neighbours(v_r)
    out = (optimalProfit, isRootIncluded, profitRootExcluded) = optimalSubsetProfit(subtree(v_neig), v_neih)
    subtreesOptimalData.append(out)
  
  
  profitRootExcluded = 0
  for subtree in subtreesOptimalData
    profitRootExluded += subtree.optimalProfit
  
  profitRootIncluded = 0
  for subtree in subtreesOptimalData
	if subtree.isRootIncluded == False
	  profitRootIncluded += subtree.optimalProfit
	else
	  profitRootIncluded += subtree.profitRootExcluded
  
  optimalProfit = max{profitRootExcluded, profitRootIncluded}
  if optimalProfit == profitRootExcluded
	isRootIncluded = False
  else
    isRootIncluded = True
  
  return optimalProfit, isRootIncluded, profitRootExcluded
</code></pre><h3 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h3><p><strong>Remark</strong> Stacks&rsquo; Vertices Number</p><p>Think of the given graph as levels of stacks from bottom to top as shown below</p><p><img loading=lazy src=screen_2.jpg alt></p><p>Observe the number of vertices in a stack must be equal or greater than the number of its preceeding stack. So, final stack of leafs is the greatest.</p><p><strong>Algorithm Description</strong></p><ul><li>Include the bottom most stack in solution subset.</li><li>Ignore the preceeding stack, As every vertex in it is adjacent to some selected vertex.</li><li>Include the preceeding stack in solution subset.</li><li>Continue similarly untill the whole graph is covered</li></ul><p>By alternatively toggling between stacks, We ensure no adjacent vertices are selected, and we greedily select stacks of greatest number of vertices.</p><p><strong>Psuedo-code</strong></p><pre tabindex=0><code>optimalProfit(tree G, tree&#39;s root v_r)

  if G contains one vertex
	return (True, 1)


  someChildIncluded = False
  count = 0

  for each child v_chi of root v_r
    (isChildIncluded, childCount) =  optimalProfit(G, v_chi)
    
	if isChildIncluded == True
	  someChildIncluded = True
	increase count by childCount


  if someChildIncluded == True
    return (False, count)
  else
    return (True, count+1)
</code></pre><p><strong>Complexity</strong> $\log(n)$</p><p><strong>Proof</strong></p><p><strong>Theorem. 1</strong> If the given graph contains only vertices with at most 1 child branch, Then the algorithm selects maximum number of valid vertices.</p><p>Note the graph in this case is basically a linear path of vertices. Note also the number of vertices selected by our algorithm is $\lceil \frac{n}{2} \rceil$, where $n$ is the number of graph&rsquo;s vertices.</p><p>It sufficies to show if there is any selection subset $U$ whose number of vertices is more than $\lceil \frac{n}{2} \rceil$, Then $U$ contains two adjacent vertices. The proof is by induction on $n$.</p><p>The base case of $n = 2$ is trivial. Assume the statement holds for $k \geq 2$, and consider an arbitrary graph $G$ where $n = k+1$.</p><p>Consider an arbitrary $X \subseteq G(V)$ with vertices number at least $\lceil \frac{k+1}{2} \rceil + 1$. Our goal now is to prove the existince of two adjacent vertices in $X$. By removing a leaf from $G$ we obtain a graph $G'$ whose number of vertices is $n' = n - 1 = k + 1 - 1 = k$. Define $X'$ to be $X \cap G'(V)$. Observe $X'$ contains at least $\lceil \frac{k+1}{2} \rceil + 1 - 1 = \lceil \frac{k+1}{2} \rceil = \lceil \frac{k}{2} \rceil + 1$ vertices. By the induction hypothesis it follows $X'$ contains two adjacent vertices, And so does $X$.</p><p><strong>Definition. 1</strong> <em>multiLinearLeafsParent</em> and <em>branchPath</em></p><p>For any vertex v, If all its child generations have degree at most 2, Then we call it <em>multiLinearLeafsParent</em>. Note on any branch l, Vertices constiute a linear path from v and upto the leaf. We call that path <em>branchPath(v, l)</em>.</p><p><strong>Lemma. 1</strong></p><p>If a vertex <em>v</em> contains more than one branch for children, and it is <em>multiLinearLeafsParent</em>, Then</p><ul><li><strong>1.1</strong> If for any branches <em>l</em>, The length of <em>branchPath(v, l)</em> is odd, Then <em>v</em> is selected by the algorithm.</li><li><strong>1.2</strong> If for some branch <em>l</em>, The length of <em>branchPath(v, l)</em> is even, Then <em>v</em> is ignored by the algorithm.</li></ul><p><strong>Lemma. 2</strong> If the given graph contains a vertex with more than 2 child branches, and a new graph $G'$ is constructed by removing either</p><ul><li>$(1)$ Two bottom most vertices from odd length <em>branchPath</em> $l_0$, or</li><li>$(2)$ One leaf from an even length <em>branchPath</em>,</li></ul><p>From some vertex $v_0$ which has at least two branches, Then the algorithm&rsquo;s selections on $G'$, are also selected on $G$.</p><p>Select that given vertex which has more than 2 child branches, and call it $v_0$. Call its branches $l_1, l_2, \dots, l_m$.</p><p>For case $(1)$, The new pruned branch is still of odd length. It is fine if the branch is completely removed also. Since parity of branches are reserved, By <em>Lemma. 1</em>, the algorithm makes the same choice on $v_0$ for both $G$ and $G'$ graphs.</p><p>Note in case the branch is completely removed, Then the choice on $v_0$ is totally dependent on other branches. If there is another even length branch then ignoring $v_0$ is reserved on $G'$; If all branches are of odd length then selecting $v_0$ is reserved also. All these cases follow by <em>Lemma. 1</em>.</p><p>For case $(2)$, We know there is another even length branch in $G'$, and by <em>Lemma. 1</em>, the algorithm ignores $v_0$ on both $G$ and $G'$ graphs.</p><p><strong>Theorem. 2</strong> If the given graph contains a vertex with more than 2 child branches, Then the algorithm selects maximum number of valid vertices.</p><p>The proof is by strong induction. The base case of $n = 3$ vertices is trivial (if you are super nerd, for $n$ less than $3$, It is vacuously true). Assume the statement holds for $k \leq p$ where $p \geq 3$, and consider arbitrary graph where number of vertices $n$ is $k+1$.</p><p>Call the count the algorithm produces $p$. Assume for the sake of contradiction there is a valid selection $X$ of vertices with count at least $p + 1$.</p><p>Select that given vertex which has more than 2 child branches promised by the theorem&rsquo;s hypothesis, and call it $v_0$. Call its branches $l_1, l_2, \dots, l_m$.</p><p>We are ahead of two cases</p><ul><li>$(1)$ For some branch $l_0$, length of $branchPath(v_0, l_0)$ is odd</li><li>$(2)$ For any branch $l_i$, length of $branchPath(v_0, l_i)$ is even</li></ul><p>For $(1)$, Construct a new graph $G'$ where the two bottom most vertices are removed from $l_0$.</p><p>Note existince of at least 2 vertices along the branch is ensured by the definition of branch&rsquo;s existince; There is no odd branch of path length equal to 1.</p><p>Note also exactly one vertex of the selected two vertices is in $X$, The optimal selection of $G$, As the two vertices are adjacent.</p><p>By <em>Lemma. 2</em>, Selections made on $G'$ are exactly the same as selections made on $G$ by the algorithm, Except on $G$ there is an additional leaf selected. So selections number $p=p'+1$.</p><p>Define $X' = X \cap G'(V)$. At most one vertex selected by the algorithm on $G$ is in $X$ but not in $X'$. So $X'$ has at least $p+1-1=p$ vertices. But we have just established $p=p'+1$, Thus $X'$ has at least $p'+1$ vertices.</p><p>Number of vertices in $G'$ is $n-2 = k+1-2 = k-1$. By the induction hypothesis, $p'$, The number of selections made by the algorithm, is the greatest valid solution for $G'$.</p><p>Contradiction, as $X'$ is a valid solution for $G'$.</p><p>For $(2)$, We fix some branch $l_0$ and construct a new graph $G'$ where leaf of $l_0$ is removed.</p><p>By a very similar reasoning a contradiction is reached.</p><p><strong>Corollary. 1</strong> The algorithm produces a the maximum number of selections, Generally</p><p>Follows immediately by <em>theorem 1</em> and <em>theorem 2</em>.</p><h3 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h3><p><strong>Remark</strong> Redundant Subproblem</p><p><img loading=lazy src=./screen_3.jpg alt></p><p>If considered the subset marked by a red rectangle, We notice we are left with exploring remaining search space of $v_1, v_2$. We see two different subsets with the same search subspace, Which is redundant. Moreover, The left subset&rsquo;s profit is $9$ while the right subset&rsquo;s profit is $10$. So we can safely assure the right subset is yielding a better solution.</p><p>This observation clearly suggests an algorithm based on dynamic programming. It also suggests a subproblem defined in terms of profit and remaining graph vertices.</p><p><strong>Table</strong></p><p><img loading=lazy src=./screen_4.jpg alt></p><p>Our algorithm is initialized on row = 0 and maxRowProfit = 0</p><p><strong>Algorithm Description</strong></p><p>For each row, we loop on all remaining graph subsets alongside their memoized profits. Then for the remaining graph selected, and for each vertex of it, We sum its profit to previous total profit and remove the vertex from remaining graph, to generate a new solution.</p><p><strong>Psuedo-code</strong></p><pre tabindex=0><code>optimalProfit(row, maxRowProfit)
  if row == n
    return maxRowProfit

  maxNextRowProfit = -1
  
  for each ith profit of table[row, ]
    for each vertex v of ith graph subset
	  totalProfit = profit + v.profit
	  remGra = removeAdj(ith graph subset, v)
	  	  
	  if table[row+1, remGra] &lt; totalProfit
	    table[row+1, remGra] = totalProfit

	  if table[row+1, remGra] &gt; maxNextRowProfit
	    maxNextRowProfit = totalProfit

  if maxNextRowProfit == -1
    return maxRowProfit
  
  optimalProfit(row+1, maxNextRowProfit)
</code></pre><p>Note the algorithm can be trivially extended to output the solution subset by outputting $G(V)$ - $remGra$, where $remGra$ is the last remaining graph found by the algorithm.</p><h2 id=problem-2>Problem 2<a hidden class=anchor aria-hidden=true href=#problem-2>#</a></h2><h3 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h3><p>Maximum distance between two requests $r_i$ and $r_j$ is $\sqrt{(1/2)^2 + (1/2)^2} = \sqrt{1/4 + 1/4} = 1\sqrt{2} \leq 1$</p><h3 id=b-1>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h3><p><strong>Algorithm Description</strong></p><p><img loading=lazy src=./screen_5.jpg alt></p><p>Recursively the algorithm divides requests into nine sub problems. The first four calls cover all requests, but we also need to check a subproblem between each pair of those four. The base case is when the square length is $1/2$, and if two requests are within the square, Then the algorithm terminates as given requests are not valid.</p><p>It is not hard to see why those calls between each pair of the first four are necessary and sufficient to merge.</p><p>We don&rsquo;t see a need for specifying a psuedo-code (and my time is limited to write all details).</p><h3 id=c-1>c<a hidden class=anchor aria-hidden=true href=#c-1>#</a></h3><p>Exactly the same as <strong>b</strong> but on the base case, The algorithm checks whether there are three requests within the square.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>