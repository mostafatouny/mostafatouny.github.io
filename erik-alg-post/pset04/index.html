<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 04 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done.
Ex. 2
he amortized cost of n operations is upper-bounded by
\begin{align*}
&amp;n + \sum_{i=1}^{\lfloor \lg n \rfloor} 2^i \\
&= n + \ddfrac{2(1-2^{\lfloor \lg n \rfloor})}{1-2} \\
&\leq n + \ddfrac{2(1-n)}{-1} \\
&= n - 2 + 2n \\
&= 3n - 2 \\
&= \mathcal{O}(n)
\end{align*}
So the amortized cost of one operation is $\ddfrac{\mathcal{O}(n)}{n} = \mathcal{O}(1).$
Ex. 3
We assign the following amortized costs:"><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/erik-alg-post/pset04/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/erik-alg-post/pset04/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 04"><meta property="og:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done.
Ex. 2
he amortized cost of n operations is upper-bounded by
\begin{align*}
&amp;n + \sum_{i=1}^{\lfloor \lg n \rfloor} 2^i \\
&= n + \ddfrac{2(1-2^{\lfloor \lg n \rfloor})}{1-2} \\
&\leq n + \ddfrac{2(1-n)}{-1} \\
&= n - 2 + 2n \\
&= 3n - 2 \\
&= \mathcal{O}(n)
\end{align*}
So the amortized cost of one operation is $\ddfrac{\mathcal{O}(n)}{n} = \mathcal{O}(1).$
Ex. 3
We assign the following amortized costs:"><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset04/"><meta property="article:section" content="erik-alg-post"><meta property="article:published_time" content="2023-04-16T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 04"><meta name=twitter:description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done.
Ex. 2
he amortized cost of n operations is upper-bounded by
\begin{align*}
&amp;n + \sum_{i=1}^{\lfloor \lg n \rfloor} 2^i \\
&= n + \ddfrac{2(1-2^{\lfloor \lg n \rfloor})}{1-2} \\
&\leq n + \ddfrac{2(1-n)}{-1} \\
&= n - 2 + 2n \\
&= 3n - 2 \\
&= \mathcal{O}(n)
\end{align*}
So the amortized cost of one operation is $\ddfrac{\mathcal{O}(n)}{n} = \mathcal{O}(1).$
Ex. 3
We assign the following amortized costs:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Erik's Algorithms","item":"https://mostafatouny.github.io/erik-alg-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 04","item":"https://mostafatouny.github.io/erik-alg-post/pset04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 04","name":"Problem Set 04","description":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 he amortized cost of n operations is upper-bounded by \\begin{align*} \u0026amp;n + \\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i \\\\ \u0026amp;= n + \\ddfrac{2(1-2^{\\lfloor \\lg n \\rfloor})}{1-2} \\\\ \u0026amp;\\leq n + \\ddfrac{2(1-n)}{-1} \\\\ \u0026amp;= n - 2 + 2n \\\\ \u0026amp;= 3n - 2 \\\\ \u0026amp;= \\mathcal{O}(n) \\end{align*}\nSo the amortized cost of one operation is $\\ddfrac{\\mathcal{O}(n)}{n} = \\mathcal{O}(1).$\nEx. 3 We assign the following amortized costs:\n","keywords":[],"articleBody":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 he amortized cost of n operations is upper-bounded by \\begin{align*} \u0026n + \\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i \\\\ \u0026= n + \\ddfrac{2(1-2^{\\lfloor \\lg n \\rfloor})}{1-2} \\\\ \u0026\\leq n + \\ddfrac{2(1-n)}{-1} \\\\ \u0026= n - 2 + 2n \\\\ \u0026= 3n - 2 \\\\ \u0026= \\mathcal{O}(n) \\end{align*}\nSo the amortized cost of one operation is $\\ddfrac{\\mathcal{O}(n)}{n} = \\mathcal{O}(1).$\nEx. 3 We assign the following amortized costs:\nith operation isn’t a power of 2 $\\rightarrow$ 4 ith operation is an exact power of 2 $\\rightarrow$ 0 We prove for each operation $2^i$, There’s a sufficient balance for it. For $i \\geq 2$, There are exactly $2^{i-1} - 1$ non-power operations before $2^i$ and after $2^{i-1}$. It sufficies to show $4(2^{i-1}-1) \\geq 2^i$ which can trivially be proven by induction.\nObserve amortized cost $= 4n - 4 \\lfloor \\lg n \\rfloor \\geq n - \\lfloor \\lg n \\rfloor + 2n \\geq n - \\lfloor \\lg n \\rfloor + \\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i$ = actual cost. Note by the geometric series $\\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i = \\ddfrac{2(1-2^{\\lfloor \\lg n \\rfloor})}{1-2} \\leq 2n$\nThe amortized cost of n operations is $\\mathcal{O}(n)$, and hence the amortzed cost of one operation is $\\mathcal{O}(1)$.\nEx. 4 Define potential function $\\Phi(D_i)$ to be the number of 1-bits in the binary representation of i. Note $\\Phi(D_0) = 0$ and $\\Phi(D_i) \\geq 0$ which suffices to show the validity of our definition.\nObserve the amortized cost of operations: \\begin{align} c_i’ = \\begin{array}{lr} i+1-i=1, \u0026 \\text{i is a power of 2} \\\\ 1+1=2, \u0026 \\text{if i is odd} \\\\ 1 + \\Delta \\Phi(D_i) \\leq 1, \u0026 \\text{if i is even but not power of 2} \\end{array} \\end{align}\nWhen i is odd, it has one additional 1-bit over even i-1, due to the right most bit being only flipped from 0 to 1. When i is even, then i-1 is odd, and at least one 1-bit is flipped to zero and at most one 0-bit is flipped to 1. So $\\Delta \\Phi(D_i) \\leq 0$. When $i = 2^k$, a power of two, then $\\Phi(D_i) = 1$ because there’s exactly one 1-bit. Also, i-1 contains exactly i 1-bits, So $\\Phi(D_{i-1}) = i$.\nIn all cases, the amortized cost of a single operation is $\\mathcal{O}(1)$.\nEx. 5 Done\nEx. 6 Each element of the array needs to be compared with the pivot only once to conclude whether it is greater or less than it.\nEx. 7 Since $0 \u003c \\alpha \\leq \\ddfrac{1}{2}$ branching $1 - \\alpha$ is greater or equal than branching $\\alpha$. Maximum depth is $\\lg_{\\ddfrac{1}{1-\\alpha}} n = \\ddfrac{\\lg n}{\\lg \\ddfrac{1}{1-\\alpha}} = \\ddfrac{\\lg n}{\\lg 1 - \\lg (1-\\alpha)}$ and minimum depth is $\\lg_{\\ddfrac{1}{\\alpha}} n = \\ddfrac{\\lg n}{\\lg \\ddfrac{1}{\\alpha}} = \\ddfrac{\\lg n}{\\lg 1 - \\lg\\alpha}$. The fact $\\lg 1 = 0$ concludes the intended result.\nEx. 8 Failed to solve.\nThrough the same reasoning of establishing upper-bound, we derived a lower-bound of $\\Omega(\\lg n)$.\nProblems Prob. 1 The obvious FIFO queue satisfies the problem’s requirements. Think of a list of numbers where integers are enqueued to left and dequeued from right.\nA list.min variable is maintained whenever a new integer is added, Checking whether it’s less than list.min and updating accordingly. Whenever dequeue is called, we check whether removed integer is equal to list.min. If not, no additional work is done. If yes, we know by the distinctness of integers, that the list.min is removed from the list, and hence it must be updated. A linear scan is implemented to update list.min.\nWhile the worst-case analysis of dequeue is linear, That worst case of removing the list.min happens in proportion to the number of integers enqueued, which in turn allows us to conclude an amortized cost of $\\mathcal{O}(1)$.\nThe central key idea is to loop only once on each element, from left to right, storing in each element.min, The minimum integer of the sub-array starting from left-most to current element’s position. Now whenever we need to loop again to find list.min, We do not loop on already-visited elements, but only on newly inserted elements. We assign list.min to be the minimum integer of that new sub-array. Observe we can conclude the minimum of the whole list, from list.min and right-most element.min stored in visited elements. It’s basically min(list.min, element.min).\nWe continue in this manner untill all visited elements are dequeued. Then we are left with a list of totally no visited elements, and list.min is the minimum integer of the whole list.\na element contains int holding the integer value and min storing the minimum element of a sub-array. list contains min indicating the minimum integer of the unstamped sub-array. That, besides elements aforementioned. b minAllElements Loop from left to right on the whole list, Maintaining the minimum of the sub-array from left-most to currently visiting element, and storing it in each element.min. Reset list.min to $+\\infty$ so that it considers only newly inserted elements. Enqueue Append element to the left of the list. If it’s less than list.min, Update list.min to it. Find-Min (1) No element is visited in a minAllElements call before. return list.min. (2) Some elements are visited in a minAllElements call before. return min(list.min, element.min), where the element here is the right-most one. Dequeue Assign localMin=Find-Min(), and remove the element. For case (1), if removed element is equal to localMin, minAllElements is called. c We skip a proof by invariance is it seems unnecessarily. We believe our discussion suffices to convince the reader our design covers all cases.\nd Trivially, Enqueue and Find-Min are $\\mathcal{O}(1)$, and $minAllElements$ is $\\mathcal{\\theta}(n)$. Dequeue’s worst-case is $\\mathcal{\\theta}(n)$ due to the call of minAllElements. So, m operations are upper-bounded by $\\mathcal{\\omega}(m^2)$.\nThe goal now, by the accounting method, is to show we can pay minAllElements by an amortized cost of 2 for Enqueue. Note we cannot visit an element unless it’s enqueued. We already discussed each element is going to be visited by minAllElements at most once, Hence the additional credit for each element accommodates the payment.\nNow we have all desired operations to have an amortized cost of $\\mathcal{O}(1)$, and a sequence of m operations costs $\\mathcal{O}(m)$.\nProb. 2 a The event is logically equivalent to, assuming $x_i$ is not the pivot the next recursive call containing $x_i$ has a subarray of size at most $3m/4$.\nConsider the array’s elements ordered as $q_1 \u003c q_2 \u003c \\dots \u003c q_m$. There are three cases for which the event occurs:\n(i) The pivot $z \\in \\{ \\lceil m/4 \\rceil, \\dots, \\lfloor 3m/4 \\rfloor + 1 \\}$. Then $x_i$ is always in a subarray of size at most $3m/4$. (ii) $z \\in \\{ 1, \\dots, \\lceil m/4 \\rceil -1 \\}$, and $x_i$ is in the left subarray. (iii) $z \\in \\{ \\lfloor 3m/4 \\rfloor + 2, \\dots, m \\}$, and $x_i$ is in the right subarray. We ignore (ii) and (iii) and prove (i) concludes the desired lower-bound of probability $1/2$.\nSince the pivot is randomly selected, we know the probability of $q_i$ being the pivot is $1/m$. There are exactly $\\lfloor 3m/4 \\rfloor + 1 - \\lceil m/4 \\rceil + 1$ elements. So the probability is:\n\\begin{align*} \\geq \u0026 \\ddfrac{1}{m} (\\left \\lfloor \\ddfrac{3m}{4} \\right \\rfloor + 1 - \\left \\lceil \\ddfrac{m}{4} \\right \\rceil + 1) \\\\ \\geq \u0026 \\ddfrac{1}{m} ( \\ddfrac{3m}{4} - \\ddfrac{m}{4} ) \\\\ = \u0026 \\ddfrac{1}{m} \\cdot \\ddfrac{m}{2} = \\ddfrac{1}{2} \\end{align*}\nb Assume the algorithm lasted for iteration $3(2 + \\ddfrac{1}{\\log_2 4/3}) \\log_2 n = 3(\\alpha + c) \\log_2 n$. By the instructor’s claim and exercise a, We know the array size is reduced by a factor of at most $3m/4$ for at least $\\ddfrac{1}{\\log_2 4/3} \\; \\log_2 n = \\log_{4/3} n$ times. Thus the array size is at most $\\ddfrac{n}{(4/3)^{\\lg_{4/3}n}} = 1$ and the algorithm terminates. Therefore with probability at least $1 - \\ddfrac{1}{n^2}$, The number of comparisons is logarithmic for $d \\leq 3(2+\\ddfrac{1}{\\log_2 4/3})$.\nc Definition 1. Let $k_i$ denote the event, that the total comparisons of $x_i$ with pivots is at most $d \\lg n$.\nLemma 2. $prob[\\neg k_1 \\vee \\neg k_2 \\vee \\dots \\vee \\neg k_n] \\leq \\ddfrac{1}{n}$.\nImmediately follows by the fact $prob[\\neg k_i] = \\ddfrac{1}{n^2}$ and the union bound. Note $\\ddfrac{1}{n^2} + \\dots + \\ddfrac{1}{n^2} = n \\ddfrac{1}{n^2} = \\ddfrac{1}{n}$\nCorollary 3. $prob[k_1 \\wedge \\dots \\wedge k_n] \\geq 1 - \\ddfrac{1}{n}$\nThe event is the logical negation of the event in lemma 2. Hence $prob[k_1 \\wedge \\dots \\wedge k_n] = 1 - prob[\\neg k_1 \\vee \\neg k_2 \\vee \\dots \\vee \\neg k_n] \\geq 1 - \\ddfrac{1}{n}$.\nd The procedure of c yields probability $1 - \\ddfrac{1}{n^{\\alpha-1}} = 1 - \\ddfrac{1}{n^{1}}$ from $\\alpha = 2$ in b. But the procedure of b is general enough, So we can select any $\\alpha$ instead of just $\\alpha = 2$. In other words, For any $\\alpha$ we can set $\\alpha + 1$ in b and get the desired probability bound.\n","wordCount":"1476","inLanguage":"en","datePublished":"2023-04-16T00:00:00Z","dateModified":"2023-04-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/erik-alg-post/pset04/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 04</h1><div class=post-meta><span title='2023-04-16 00:00:00 +0000 UTC'>April 16, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exercises aria-label=Exercises>Exercises</a><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a></li><li><a href=#ex-2 aria-label="Ex. 2">Ex. 2</a></li><li><a href=#ex-3 aria-label="Ex. 3">Ex. 3</a></li><li><a href=#ex-4 aria-label="Ex. 4">Ex. 4</a></li><li><a href=#ex-5 aria-label="Ex. 5">Ex. 5</a></li><li><a href=#ex-6 aria-label="Ex. 6">Ex. 6</a></li><li><a href=#ex-7 aria-label="Ex. 7">Ex. 7</a></li><li><a href=#ex-8 aria-label="Ex. 8">Ex. 8</a></li></ul></li><li><a href=#problems aria-label=Problems>Problems</a><ul><li><a href=#prob-1 aria-label="Prob. 1">Prob. 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li></ul></li><li><a href=#prob-2 aria-label="Prob. 2">Prob. 2</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li><li><a href=#c-1 aria-label=c>c</a></li><li><a href=#d-1 aria-label=d>d</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p><h2 id=exercises>Exercises<a hidden class=anchor aria-hidden=true href=#exercises>#</a></h2><h3 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h3><p>Done.</p><h3 id=ex-2>Ex. 2<a hidden class=anchor aria-hidden=true href=#ex-2>#</a></h3><p>he amortized cost of n operations is upper-bounded by
\begin{align*}
&amp;n + \sum_{i=1}^{\lfloor \lg n \rfloor} 2^i \\
&= n + \ddfrac{2(1-2^{\lfloor \lg n \rfloor})}{1-2} \\
&\leq n + \ddfrac{2(1-n)}{-1} \\
&= n - 2 + 2n \\
&= 3n - 2 \\
&= \mathcal{O}(n)
\end{align*}</p><p>So the amortized cost of one operation is $\ddfrac{\mathcal{O}(n)}{n} = \mathcal{O}(1).$</p><h3 id=ex-3>Ex. 3<a hidden class=anchor aria-hidden=true href=#ex-3>#</a></h3><p>We assign the following amortized costs:</p><ul><li>ith operation isn&rsquo;t a power of 2 $\rightarrow$ 4</li><li>ith operation is an exact power of 2 $\rightarrow$ 0</li></ul><p>We prove for each operation $2^i$, There&rsquo;s a sufficient balance for it. For $i \geq 2$, There are exactly $2^{i-1} - 1$ non-power operations before $2^i$ and after $2^{i-1}$. It sufficies to show $4(2^{i-1}-1) \geq 2^i$ which can trivially be proven by induction.</p><p>Observe amortized cost $= 4n - 4 \lfloor \lg n \rfloor \geq n - \lfloor \lg n \rfloor + 2n \geq n - \lfloor \lg n \rfloor + \sum_{i=1}^{\lfloor \lg n \rfloor} 2^i$ = actual cost. Note by the geometric series $\sum_{i=1}^{\lfloor \lg n \rfloor} 2^i = \ddfrac{2(1-2^{\lfloor \lg n \rfloor})}{1-2} \leq 2n$</p><p>The amortized cost of n operations is $\mathcal{O}(n)$, and hence the amortzed cost of one operation is $\mathcal{O}(1)$.</p><h3 id=ex-4>Ex. 4<a hidden class=anchor aria-hidden=true href=#ex-4>#</a></h3><p>Define potential function $\Phi(D_i)$ to be the number of 1-bits in the binary representation of i. Note $\Phi(D_0) = 0$ and $\Phi(D_i) \geq 0$ which suffices to show the validity of our definition.</p><p>Observe the amortized cost of operations:
\begin{align}
c_i&rsquo; =
\begin{array}{lr}
i+1-i=1, & \text{i is a power of 2} \\
1+1=2, & \text{if i is odd} \\
1 + \Delta \Phi(D_i) \leq 1, & \text{if i is even but not power of 2}
\end{array}
\end{align}</p><p>When i is odd, it has one additional 1-bit over even i-1, due to the right most bit being only flipped from 0 to 1. When i is even, then i-1 is odd, and at least one 1-bit is flipped to zero and at most one 0-bit is flipped to 1. So $\Delta \Phi(D_i) \leq 0$. When $i = 2^k$, a power of two, then $\Phi(D_i) = 1$ because there&rsquo;s exactly one 1-bit. Also, i-1 contains exactly i 1-bits, So $\Phi(D_{i-1}) = i$.</p><p>In all cases, the amortized cost of a single operation is $\mathcal{O}(1)$.</p><h3 id=ex-5>Ex. 5<a hidden class=anchor aria-hidden=true href=#ex-5>#</a></h3><p>Done</p><h3 id=ex-6>Ex. 6<a hidden class=anchor aria-hidden=true href=#ex-6>#</a></h3><p>Each element of the array needs to be compared with the <em>pivot</em> only once to conclude whether it is greater or less than it.</p><h3 id=ex-7>Ex. 7<a hidden class=anchor aria-hidden=true href=#ex-7>#</a></h3><p>Since $0 < \alpha \leq \ddfrac{1}{2}$ branching $1 - \alpha$ is greater or equal than branching $\alpha$. Maximum depth is $\lg_{\ddfrac{1}{1-\alpha}} n = \ddfrac{\lg n}{\lg \ddfrac{1}{1-\alpha}} = \ddfrac{\lg n}{\lg 1 - \lg (1-\alpha)}$ and minimum depth is $\lg_{\ddfrac{1}{\alpha}} n = \ddfrac{\lg n}{\lg \ddfrac{1}{\alpha}} = \ddfrac{\lg n}{\lg 1 - \lg\alpha}$. The fact $\lg 1 = 0$ concludes the intended result.</p><h3 id=ex-8>Ex. 8<a hidden class=anchor aria-hidden=true href=#ex-8>#</a></h3><p>Failed to solve.</p><p>Through the same reasoning of establishing upper-bound, we derived a lower-bound of $\Omega(\lg n)$.</p><h2 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h2><h3 id=prob-1>Prob. 1<a hidden class=anchor aria-hidden=true href=#prob-1>#</a></h3><p>The obvious FIFO queue satisfies the problem&rsquo;s requirements. Think of a list of numbers where integers are <em>enqueued</em> to left and <em>dequeued</em> from right.</p><p>A <em>list.min</em> variable is maintained whenever a new integer is added, Checking whether it&rsquo;s less than <em>list.min</em> and updating accordingly. Whenever <em>dequeue</em> is called, we check whether removed integer is equal to <em>list.min</em>. If not, no additional work is done. If yes, we know by the distinctness of integers, that the <em>list.min</em> is removed from the list, and hence it must be updated. A linear scan is implemented to update <em>list.min</em>.</p><p>While the worst-case analysis of <em>dequeue</em> is linear, That worst case of removing the <em>list.min</em> happens in proportion to the number of integers enqueued, which in turn allows us to conclude an amortized cost of $\mathcal{O}(1)$.</p><p>The central key idea is to loop only once on each element, from left to right, storing in each <em>element.min</em>, The minimum integer of the sub-array starting from left-most to current element&rsquo;s position. Now whenever we need to loop again to find <em>list.min</em>, We do not loop on already-visited elements, but only on newly inserted elements. We assign <em>list.min</em> to be the minimum integer of that new sub-array. Observe we can conclude the minimum of the whole list, from <em>list.min</em> and right-most <em>element.min</em> stored in visited elements. It&rsquo;s basically <em>min(list.min, element.min)</em>.</p><p>We continue in this manner untill all visited elements are dequeued. Then we are left with a list of totally no visited elements, and <em>list.min</em> is the minimum integer of the whole list.</p><h4 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h4><ul><li><strong>element</strong> contains <em>int</em> holding the integer value and <em>min</em> storing the minimum element of a sub-array.</li><li><strong>list</strong> contains <em>min</em> indicating the minimum integer of the unstamped sub-array. That, besides <em>elements</em> aforementioned.</li></ul><h4 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h4><ul><li><strong>minAllElements</strong> Loop from left to right on the whole list, Maintaining the minimum of the sub-array from left-most to currently visiting element, and storing it in each <em>element.min</em>. Reset <em>list.min</em> to $+\infty$ so that it considers only newly inserted elements.</li><li><strong>Enqueue</strong> Append element to the left of the list. If it&rsquo;s less than <em>list.min</em>, Update <em>list.min</em> to it.</li><li><strong>Find-Min</strong><ul><li>(1) No element is visited in a <em>minAllElements</em> call before.<ul><li>return <em>list.min</em>.</li></ul></li><li>(2) Some elements are visited in a <em>minAllElements</em> call before.<ul><li>return <em>min(list.min, element.min)</em>, where the element here is the right-most one.</li></ul></li></ul></li><li><strong>Dequeue</strong> Assign <em>localMin=Find-Min()</em>, and remove the element. For case (1), if removed element is equal to <em>localMin</em>, <em>minAllElements</em> is called.</li></ul><h4 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h4><p>We skip a proof by invariance is it seems unnecessarily. We believe our discussion suffices to convince the reader our design covers all cases.</p><h4 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h4><p>Trivially, <em>Enqueue</em> and <em>Find-Min</em> are $\mathcal{O}(1)$, and $minAllElements$ is $\mathcal{\theta}(n)$. <em>Dequeue</em>&rsquo;s worst-case is $\mathcal{\theta}(n)$ due to the call of <em>minAllElements</em>. So, <em>m</em> operations are upper-bounded by $\mathcal{\omega}(m^2)$.</p><p>The goal now, by the <em>accounting</em> method, is to show we can pay <em>minAllElements</em> by an amortized cost of 2 for <em>Enqueue</em>. Note we cannot visit an element unless it&rsquo;s enqueued. We already discussed each element is going to be visited by <em>minAllElements</em> at most once, Hence the additional credit for each element accommodates the payment.</p><p>Now we have all desired operations to have an amortized cost of $\mathcal{O}(1)$, and a sequence of m operations costs $\mathcal{O}(m)$.</p><h3 id=prob-2>Prob. 2<a hidden class=anchor aria-hidden=true href=#prob-2>#</a></h3><h4 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h4><p>The event is logically equivalent to, assuming $x_i$ is not the pivot the next recursive call containing $x_i$ has a subarray of size at most $3m/4$.</p><p>Consider the array&rsquo;s elements ordered as $q_1 < q_2 < \dots < q_m$. There are three cases for which the event occurs:</p><ul><li>(i) The pivot $z \in \{ \lceil m/4 \rceil, \dots, \lfloor 3m/4 \rfloor + 1 \}$. Then $x_i$ is always in a subarray of size at most $3m/4$.</li><li>(ii) $z \in \{ 1, \dots, \lceil m/4 \rceil -1 \}$, and $x_i$ is in the left subarray.</li><li>(iii) $z \in \{ \lfloor 3m/4 \rfloor + 2, \dots, m \}$, and $x_i$ is in the right subarray.</li></ul><p>We ignore (ii) and (iii) and prove (i) concludes the desired lower-bound of probability $1/2$.</p><p>Since the pivot is randomly selected, we know the probability of $q_i$ being the pivot is $1/m$. There are exactly $\lfloor 3m/4 \rfloor + 1 - \lceil m/4 \rceil + 1$ elements. So the probability is:</p><p>\begin{align*}
\geq & \ddfrac{1}{m} (\left \lfloor \ddfrac{3m}{4} \right \rfloor + 1 - \left \lceil \ddfrac{m}{4} \right \rceil + 1) \\
\geq & \ddfrac{1}{m} ( \ddfrac{3m}{4} - \ddfrac{m}{4} ) \\
= & \ddfrac{1}{m} \cdot \ddfrac{m}{2} = \ddfrac{1}{2}
\end{align*}</p><h4 id=b-1>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h4><p>Assume the algorithm lasted for iteration $3(2 + \ddfrac{1}{\log_2 4/3}) \log_2 n = 3(\alpha + c) \log_2 n$. By the instructor&rsquo;s claim and exercise <em>a</em>, We know the array size is reduced by a factor of at most $3m/4$ for at least $\ddfrac{1}{\log_2 4/3} \; \log_2 n = \log_{4/3} n$ times. Thus the array size is at most $\ddfrac{n}{(4/3)^{\lg_{4/3}n}} = 1$ and the algorithm terminates. Therefore with probability at least $1 - \ddfrac{1}{n^2}$, The number of comparisons is logarithmic for $d \leq 3(2+\ddfrac{1}{\log_2 4/3})$.</p><h4 id=c-1>c<a hidden class=anchor aria-hidden=true href=#c-1>#</a></h4><p><strong>Definition 1.</strong> Let $k_i$ denote the event, that the total comparisons of $x_i$ with pivots is at most $d \lg n$.</p><p><strong>Lemma 2.</strong> $prob[\neg k_1 \vee \neg k_2 \vee \dots \vee \neg k_n] \leq \ddfrac{1}{n}$.</p><p>Immediately follows by the fact $prob[\neg k_i] = \ddfrac{1}{n^2}$ and the union bound. Note $\ddfrac{1}{n^2} + \dots + \ddfrac{1}{n^2} = n \ddfrac{1}{n^2} = \ddfrac{1}{n}$</p><p><strong>Corollary 3.</strong> $prob[k_1 \wedge \dots \wedge k_n] \geq 1 - \ddfrac{1}{n}$</p><p>The event is the logical negation of the event in <strong>lemma 2</strong>. Hence $prob[k_1 \wedge \dots \wedge k_n] = 1 - prob[\neg k_1 \vee \neg k_2 \vee \dots \vee \neg k_n] \geq 1 - \ddfrac{1}{n}$.</p><h4 id=d-1>d<a hidden class=anchor aria-hidden=true href=#d-1>#</a></h4><p>The procedure of <em>c</em> yields probability $1 - \ddfrac{1}{n^{\alpha-1}} = 1 - \ddfrac{1}{n^{1}}$ from $\alpha = 2$ in <em>b</em>. But the procedure of <em>b</em> is general enough, So we can select any $\alpha$ instead of just $\alpha = 2$. In other words, For any $\alpha$ we can set $\alpha + 1$ in <em>b</em> and get the desired probability bound.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>