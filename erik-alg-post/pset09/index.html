<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 09 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Ex. 2
Ex. 3
Ex. 4
Problems
Prob. 1
a
Consider 
$$\begin{aligned}
    A &= \{ 1, 2 \} \\\\
    S &= \{ 1, 50 \} \\\\
    V &= \{ 2, 50 \} \\\\
    B &= 50\end{aligned}$$
Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.
It is easy to see the number $50$ can be set arbitrarily larger, and
therefore we can reach the desired unbounded approximation ratio."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/erik-alg-post/pset09/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/erik-alg-post/pset09/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 09"><meta property="og:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Ex. 2
Ex. 3
Ex. 4
Problems
Prob. 1
a
Consider 
$$\begin{aligned}
    A &= \{ 1, 2 \} \\\\
    S &= \{ 1, 50 \} \\\\
    V &= \{ 2, 50 \} \\\\
    B &= 50\end{aligned}$$
Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.
It is easy to see the number $50$ can be set arbitrarily larger, and
therefore we can reach the desired unbounded approximation ratio."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset09/"><meta property="article:section" content="erik-alg-post"><meta property="article:published_time" content="2023-08-02T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 09"><meta name=twitter:description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Ex. 2
Ex. 3
Ex. 4
Problems
Prob. 1
a
Consider 
$$\begin{aligned}
    A &= \{ 1, 2 \} \\\\
    S &= \{ 1, 50 \} \\\\
    V &= \{ 2, 50 \} \\\\
    B &= 50\end{aligned}$$
Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.
It is easy to see the number $50$ can be set arbitrarily larger, and
therefore we can reach the desired unbounded approximation ratio."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Erik's Algorithms","item":"https://mostafatouny.github.io/erik-alg-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 09","item":"https://mostafatouny.github.io/erik-alg-post/pset09/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 09","name":"Problem Set 09","description":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Ex. 2 Ex. 3 Ex. 4 Problems Prob. 1 a Consider $$\\begin{aligned} A \u0026= \\{ 1, 2 \\} \\\\\\\\ S \u0026= \\{ 1, 50 \\} \\\\\\\\ V \u0026= \\{ 2, 50 \\} \\\\\\\\ B \u0026= 50\\end{aligned}$$ Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.\nIt is easy to see the number $50$ can be set arbitrarily larger, and therefore we can reach the desired unbounded approximation ratio.\n","keywords":[],"articleBody":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Ex. 2 Ex. 3 Ex. 4 Problems Prob. 1 a Consider $$\\begin{aligned} A \u0026= \\{ 1, 2 \\} \\\\\\\\ S \u0026= \\{ 1, 50 \\} \\\\\\\\ V \u0026= \\{ 2, 50 \\} \\\\\\\\ B \u0026= 50\\end{aligned}$$ Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.\nIt is easy to see the number $50$ can be set arbitrarily larger, and therefore we can reach the desired unbounded approximation ratio.\nb We follow the same convention of assuming the given indices order follow non-increasing order of their densities.\nFor the first index $i$ such that $\\sum_{j=1}^{i} v_j \u003e B$, denote items up to $i-1$ by Max-Dens-Items and $i$th item by First-Overweight. For item $a_i$ denote $D(a_i)$ to be the density of $a_i$, i.e the value per one unit of weight.\nTake D(First-Overweight) and multiply it by the slack weight in $B$ after consuming weights of Max-Dens-Items. Sum the resulting value along values of Max-Dens-Items and let $V_{maxDensities}$ denote that sum.\nIt is very clear $C* \\leq V_{maxDensities}$ as we fully utilized the space of $B$ with maximum possible densities.\nLet’s return to Alg2 and note how similar it is to the way we defined $V_{maxDensities}$. Remark that $C = max\\{ V_{maxDensities}, \\textit{value of First-Overweight} \\}$. We have two cases:\nCase 1. Weights of Max-Dens-Items $\\geq \\frac{\\displaystyle{B}}{\\displaystyle{2}}$.\nThen $C \\geq \\frac{\\displaystyle{ V_{maxDensities} }}{\\displaystyle{2}}$, As Max-Dens-Items accounts for more than 50% of $V_{maxDensities}$. Case 2. Weights of Max-Dens-Items $\u003c \\frac{\\displaystyle{B}}{\\displaystyle{2}}$.\nThen the weight of First-Overweight is greater than $\\frac{\\displaystyle{B}}{\\displaystyle{2}}$. It follows $V_{maxDensities}$ is contributed only by Max-Dens-Items and First-Overweight. Observe one of them must contribute at least 50% of $V_{maxDensities}$. By definition, that one shall be selected by Alg2, and therefore $C \\geq \\frac{\\displaystyle{ V_{maxDensities} }}{\\displaystyle{2}}$. c That is a standard dynamic programming problem whose solution can be found in any textbook. For brevity we only show the recurrece relation.\nBase: $S_{1,v} = w(a_1)$ if $w(a_1) = v$.\nInduction Step: $S_{i,v} = min\\{ S_{i-1,v}, w(a_i) + S_{i-1, v-v_i} \\}$\nd Polynomial Time Complexity. Observe the time complexity of $Alg3$ is $\\mathcal{O}(n^2 V)$, As the memoization table is:\nvalue\\items 1 .. n 1 .. nV Since $Alg4$ basically runs $Alg3$ with additional linear operations, Its time complexity is $\\mathcal{O}(n^2 V')$, where $V'$ is similarly defined but on scaled values $v_i'$.\nClearly $V' = \\lfloor \\frac{\\displaystyle{V}}{\\displaystyle{V}} \\cdot \\frac{\\displaystyle{n}}{\\displaystyle{\\epsilon}} \\rfloor = \\lfloor \\frac{\\displaystyle{n}}{\\displaystyle{\\epsilon}} \\rfloor$. So complexity of $Alg4$ can be re-written as $\\mathcal{O}(n^3 \\cdot \\frac{1}{\\epsilon})$.\nApproximation Scheme. The idea is to use the bound of b but on scaled values $v_i'$, then reverse the scaling to reach the intended ratio.\nLet $U$ be the upper-bound of optimal solutions which we defined earlier in b on given values $v_i$. Let $U'$ be similarly defined but on scaled values $v_i'$. Define function $f$ so that it scales value as mentioned by the author. Let $C$ and $C'$ denote the value of the subset solution obtained by $Alg4$ but on given and scaled values respectively.\nFrom b, We know there exists a solution on scaled values $v_i'$ whose approximation ratio is $2$, out of $U'$. Then trivially the optimal solution also can deviate by a ratio of at most $2$ out of $U'$.\nObserve if we scaled back a value then the calculated value is no greater than the original given value, since we are taking ceils. In other words, $f^{-1}(v_i') \\leq v_i$.\nJoining all these remarks: \\begin{aligned} C’ \u0026\\geq \\frac{1}{2} U’ \\\\ C \\geq f^{-1}(C’) \u0026\\geq \\frac{1}{2} f^{-1}(U’) = U \\end{aligned} From b, That suffices to concluding $Alg4$ is an approximation scheme.\nProb. 2 a Assume for the sake of contradiction there is a cycle $c_0$ in the reversed graph $\\hat{G}$. Then it must contain an edge from $A$. Otherwise $c_0$ would also be in graph $G$ and by definition it must contain an edge from $A$. Call that edge $a$. Returning to $G$, $a$ would be reversed as in the figure below. It is possible to have edges other than $a$ in cycle $c_0$ which would also be reversed in graph $G$ In this case $p_0$ would be constructed by taking the corresponding sub-cycles into it.\nSince $A$ is minimal there must be a cycle $c_1$ in graph $G$ which would not be covered if not for $a$. Observe we have cycle $c_2$ constructed by paths $p_0$ and $p_1$. What covers $c_2$ in $G$? Clearly no edge in path $p_0$ would do that since we already considered all edges of $A$ we might encounter and took a sub-cycle avoiding them. Then $c_2$ is covered by edge $b$ in path $p_1$ which is part of the cycle $c_1$. That contradicts $c_1$ being a cycle only covered by edge $a$ $\\textbf{QED}$.\nb Remove all isolated vertices as they are irrelevant to cycles. Iteratively contract edges if they are not a side of a triangle as in the following figure.\nBy definition, Each edge of the resulting graph is a side of a triangle. Observe the graph is still equivalent to the previous one, When it comes to cycles. Intuitively we just condensed the length of cycles.\nFor a single edge $e$, Consider the number of different triangles it is a side of. If the number is greater than $k$ then we must have $e \\in S$; Otherwise, To cover all of these triangles, We will need more than $k$ edges. Note any two different triangles can share at most one edge. Remove edge $e$, and contract edges as needed if they are no longer a side of a triangle (suffices also to maintain no isolated vertices). Output the resulting graph as $\\hat{G}$ but with a capacity of at most $k-1$ edges to cover all of its cycles.\nAfter repeating this process, We will have a graph where each edge is a side of a triangles, whose count is no more than $k$. Also each vertex is part of a cycle. We show now the number of vertices is upper-bounded by $k^2 + 2k$. They key idea is, If there is an additional vertex, We will have cycles more than what $k$ edges can accommodate.\nFor a single edge $e$, It can cover at most $k$ cycles. Vertices in those cycles are exactly, $2$ of the edge itself, and $k$ for each cycle. That is a total of $2+k$. See the picture below:\nConsidering all edges of $A$, The total we get is $k(2+k) = 2k + k^2$.\nIt is clear now we cannot have vertices greater than that number. As by our graph structure that vertex $v$ would be part of a cycle, and we have already consumed the maximum number of cycles $k$ edges can cover. In other words, We will miss a cycle which contains vertex $v$.\nc It suffices to have a polynomial-time algorithm of the kernlization procedure we illustrated.\nDegrees of vertices are computed by a linear scan of edges, $\\mathcal{O}(|E|)$. Contracting edges takes at most $\\mathcal{O}(|E|^2)$. Computing number of triangles for each edge takes at most $\\mathcal{O}(|E| (|E| + |V|))$ by a trivial graph search, made for each edge. Removing edges consumes $\\mathcal{O}(|E|)$. Since each step is polynomial in the size of the input, The sum of these sub-routines is polynomial also.\n","wordCount":"1206","inLanguage":"en","datePublished":"2023-08-02T00:00:00Z","dateModified":"2023-08-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/erik-alg-post/pset09/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 09</h1><div class=post-meta><span title='2023-08-02 00:00:00 +0000 UTC'>August 2, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exercises aria-label=Exercises>Exercises</a><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a></li><li><a href=#ex-2 aria-label="Ex. 2">Ex. 2</a></li><li><a href=#ex-3 aria-label="Ex. 3">Ex. 3</a></li><li><a href=#ex-4 aria-label="Ex. 4">Ex. 4</a></li></ul></li><li><a href=#problems aria-label=Problems>Problems</a><ul><li><a href=#prob-1 aria-label="Prob. 1">Prob. 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li></ul></li><li><a href=#prob-2 aria-label="Prob. 2">Prob. 2</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li><li><a href=#c-1 aria-label=c>c</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p><h2 id=exercises>Exercises<a hidden class=anchor aria-hidden=true href=#exercises>#</a></h2><h3 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h3><h3 id=ex-2>Ex. 2<a hidden class=anchor aria-hidden=true href=#ex-2>#</a></h3><h3 id=ex-3>Ex. 3<a hidden class=anchor aria-hidden=true href=#ex-3>#</a></h3><h3 id=ex-4>Ex. 4<a hidden class=anchor aria-hidden=true href=#ex-4>#</a></h3><h2 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h2><h3 id=prob-1>Prob. 1<a hidden class=anchor aria-hidden=true href=#prob-1>#</a></h3><h4 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h4><p>Consider</p>$$\begin{aligned}
A &= \{ 1, 2 \} \\\\
    S &= \{ 1, 50 \} \\\\
V &= \{ 2, 50 \} \\\\
    B &= 50\end{aligned}$$<p>Observe the optimal solution is $C = 50$ while <em>Alg1</em> is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.</p><p>It is easy to see the number $50$ can be set arbitrarily larger, and
therefore we can reach the desired unbounded approximation ratio.</p><h4 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h4><p>We follow the same convention of assuming the given indices order follow
non-increasing order of their densities.</p><p>For the first index $i$ such that $\sum_{j=1}^{i} v_j > B$, denote items up to $i-1$ by <em>Max-Dens-Items</em> and $i$th item by <em>First-Overweight</em>. For item $a_i$ denote $D(a_i)$ to be the density of $a_i$, i.e the <em>value</em> per one unit of <em>weight</em>.</p><p>Take <em>D(First-Overweight)</em> and multiply it by the slack weight in $B$ after consuming weights of <em>Max-Dens-Items</em>. Sum the resulting value along values of <em>Max-Dens-Items</em> and let $V_{maxDensities}$ denote that sum.</p><p>It is very clear $C* \leq V_{maxDensities}$ as we fully utilized the space of $B$ with maximum possible densities.</p><p>Let&rsquo;s return to <em>Alg2</em> and note how similar it is to the way we defined $V_{maxDensities}$. Remark that $C = max\{ V_{maxDensities}, \textit{value of First-Overweight} \}$. We have two cases:</p><ul><li>Case 1. Weights of <em>Max-Dens-Items</em> $\geq \frac{\displaystyle{B}}{\displaystyle{2}}$.<br>Then $C \geq \frac{\displaystyle{ V_{maxDensities} }}{\displaystyle{2}}$, As <em>Max-Dens-Items</em> accounts for more than 50% of $V_{maxDensities}$.</li><li>Case 2. Weights of <em>Max-Dens-Items</em> $< \frac{\displaystyle{B}}{\displaystyle{2}}$.<br>Then the weight of <em>First-Overweight</em> is greater than $\frac{\displaystyle{B}}{\displaystyle{2}}$. It follows $V_{maxDensities}$ is contributed only by <em>Max-Dens-Items</em> and <em>First-Overweight</em>. Observe one of them must contribute at least 50% of $V_{maxDensities}$. By definition, that one shall be selected by <em>Alg2</em>, and therefore $C \geq \frac{\displaystyle{ V_{maxDensities} }}{\displaystyle{2}}$.</li></ul><h4 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h4><p>That is a standard dynamic programming problem whose solution can be found in any textbook. For brevity we only show the recurrece relation.</p><p>Base: $S_{1,v} = w(a_1)$ if $w(a_1) = v$.<br>Induction Step: $S_{i,v} = min\{ S_{i-1,v}, w(a_i) + S_{i-1, v-v_i} \}$</p><h4 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h4><p><strong>Polynomial Time Complexity.</strong> Observe the time complexity of $Alg3$ is
$\mathcal{O}(n^2 V)$, As the memoization table is:</p><table><thead><tr><th>value\items</th><th>1</th><th>..</th><th>n</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td></tr><tr><td>..</td><td></td><td></td><td></td></tr><tr><td>nV</td><td></td><td></td><td></td></tr></tbody></table><p>Since $Alg4$ basically runs $Alg3$ with additional linear operations, Its time complexity is $\mathcal{O}(n^2 V')$, where $V'$ is similarly defined but on scaled values $v_i'$.</p><p>Clearly $V' = \lfloor \frac{\displaystyle{V}}{\displaystyle{V}} \cdot \frac{\displaystyle{n}}{\displaystyle{\epsilon}} \rfloor = \lfloor \frac{\displaystyle{n}}{\displaystyle{\epsilon}} \rfloor$. So complexity of $Alg4$ can be re-written as $\mathcal{O}(n^3 \cdot \frac{1}{\epsilon})$.</p><p><strong>Approximation Scheme.</strong> The idea is to use the bound of <strong>b</strong> but on scaled values $v_i'$, then reverse the scaling to reach the intended ratio.</p><p>Let $U$ be the upper-bound of optimal solutions which we defined earlier in <strong>b</strong> on given values $v_i$. Let $U'$ be similarly defined but on scaled values $v_i'$. Define function $f$ so that it scales value as mentioned by the author. Let $C$ and $C'$ denote the value of the subset solution obtained by $Alg4$ but on given and scaled values respectively.</p><p>From <strong>b</strong>, We know there exists a solution on scaled values $v_i'$ whose approximation ratio is $2$, out of $U'$. Then trivially the optimal solution also can deviate by a ratio of at most $2$ out of $U'$.</p><p>Observe if we scaled back a value then the calculated value is no greater than the original given value, since we are taking ceils. In other words, $f^{-1}(v_i') \leq v_i$.</p><p>Joining all these remarks:
\begin{aligned}
C&rsquo; &\geq \frac{1}{2} U&rsquo; \\
C \geq f^{-1}(C&rsquo;) &\geq \frac{1}{2} f^{-1}(U&rsquo;) = U
\end{aligned}
From <strong>b</strong>, That suffices to concluding $Alg4$ is an approximation scheme.</p><h3 id=prob-2>Prob. 2<a hidden class=anchor aria-hidden=true href=#prob-2>#</a></h3><h4 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h4><p>Assume for the sake of contradiction there is a cycle $c_0$ in the reversed graph $\hat{G}$. Then it must contain an edge from $A$. Otherwise $c_0$ would also be in graph $G$ and by definition it must contain an edge from $A$. Call that edge $a$. Returning to $G$, $a$ would be reversed as in the figure below. It is possible to have edges other than $a$ in cycle $c_0$ which would also be reversed in graph $G$ In this case $p_0$ would be constructed by taking the corresponding sub-cycles into it.</p><p>Since $A$ is minimal there must be a cycle $c_1$ in graph $G$ which would not be covered if not for $a$. Observe we have cycle $c_2$ constructed by paths $p_0$ and $p_1$. What covers $c_2$ in $G$? Clearly no edge in path $p_0$ would do that since we already considered all edges of $A$ we might encounter and took a sub-cycle avoiding them. Then $c_2$ is covered by edge $b$ in path $p_1$ which is part of the cycle $c_1$. That contradicts $c_1$ being a cycle only covered by edge $a$ $\textbf{QED}$.</p><p><img loading=lazy src=./cycle.jpg alt=image></p><h4 id=b-1 class=unnumbered>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h4><p>Remove all isolated vertices as they are irrelevant to cycles. Iteratively <em>contract</em> edges if they are not a side of a triangle as in the following figure.</p><p><img loading=lazy src=./contract.jpg alt=image></p><p>By definition, Each edge of the resulting graph is a side of a triangle. Observe the graph is still equivalent to the previous one, When it comes to cycles. Intuitively we just condensed the length of cycles.</p><p>For a single edge $e$, Consider the number of different triangles it is a side of. If the number is greater than $k$ then we must have $e \in S$; Otherwise, To cover all of these triangles, We will need more than $k$ edges. Note any two different triangles can share at most one edge. Remove edge $e$, and <em>contract</em> edges as needed if they are no longer a side of a triangle (suffices also to maintain no isolated vertices). Output the resulting graph as $\hat{G}$ but with a capacity
of at most $k-1$ edges to cover all of its cycles.</p><p>After repeating this process, We will have a graph where each edge is a side of a triangles, whose count is no more than $k$. Also each vertex is part of a cycle. We show now the number of vertices is upper-bounded by $k^2 + 2k$. They key idea is, If there is an additional vertex, We will have cycles more than what $k$ edges can accommodate.</p><p>For a single edge $e$, It can cover at most $k$ cycles. Vertices in those cycles are exactly, $2$ of the edge itself, and $k$ for each cycle. That is a total of $2+k$. See the picture below:</p><p><img loading=lazy src=./verNum.jpg alt=image></p><p>Considering all edges of $A$, The total we get is $k(2+k) = 2k + k^2$.</p><p>It is clear now we cannot have vertices greater than that number. As by our graph structure that vertex $v$ would be part of a cycle, and we have already consumed the maximum number of cycles $k$ edges can cover. In other words, We will miss a cycle which contains vertex $v$.</p><h4 id=c-1>c<a hidden class=anchor aria-hidden=true href=#c-1>#</a></h4><p>It suffices to have a polynomial-time algorithm of the kernlization
procedure we illustrated.</p><ul><li>Degrees of vertices are computed by a linear scan of edges, $\mathcal{O}(|E|)$.</li><li>Contracting edges takes at most $\mathcal{O}(|E|^2)$.</li><li>Computing number of triangles for each edge takes at most $\mathcal{O}(|E| (|E| + |V|))$ by a trivial graph search, made for each edge.</li><li>Removing edges consumes $\mathcal{O}(|E|)$.</li></ul><p>Since each step is polynomial in the size of the input, The sum of these sub-routines is polynomial also.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>