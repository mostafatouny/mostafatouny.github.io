<!DOCTYPE html>
<!-- This site was created with Hugo Blox. https://hugoblox.com -->
<!-- Last Published: June 1, 2024 --><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Hugo Blox Builder 5.9.7" />
  

  
  












  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  

  
  
    
    <script src="/js/mathjax-config.js"></script>
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.26c458e6907dc03073573976b7f4044e.css" media="print" onload="this.media='all'">

  
  
  
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.4/css/academicons.min.css" integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    
    
    
    
      
      
    
    
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.08764d393984928e0719bd53b26ed27a.css" />

  
  
  

  
  
  
  
  
  
  
    
    
    <link rel="stylesheet" href="/css/libs/chroma/github-light.min.css" title="hl-light" media="print" onload="this.media='all'" disabled>
    <link rel="stylesheet" href="/css/libs/chroma/dracula.min.css" title="hl-dark" media="print" onload="this.media='all'" >
  

  
  



























  
  
  






  <meta name="author" content="Mostafa Touny" />





  

<meta name="description" content="Ex. 2-1 done
Ex. 2-2 For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 &#43; x$ with $B(x) = 3 - 6x$.
Double-degree form
$A(x) = -10 &#43; x &#43; 0x^2 &#43; 0x^3$" />



<link rel="alternate" hreflang="en-us" href="https://mostafatouny.github.io/erik-alg-post/pset02/" />
<link rel="canonical" href="https://mostafatouny.github.io/erik-alg-post/pset02/" />



  <link rel="manifest" href="/manifest.webmanifest" />



<link rel="icon" type="image/png" href="/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_32x32_fill_lanczos_center_3.png" />
<link rel="apple-touch-icon" type="image/png" href="/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_180x180_fill_lanczos_center_3.png" />

<meta name="theme-color" content="#bbdefb" />










  
  






<meta property="twitter:card" content="summary" />
<meta property="twitter:image" content="https://mostafatouny.github.io/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_512x512_fill_lanczos_center_3.png" />



  

<meta property="og:type" content="website" />
<meta property="og:site_name" content="Mostafa Touny" />
<meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset02/" />
<meta property="og:title" content="Problem Set 02 | Mostafa Touny" />
<meta property="og:description" content="Ex. 2-1 done
Ex. 2-2 For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 &#43; x$ with $B(x) = 3 - 6x$.
Double-degree form
$A(x) = -10 &#43; x &#43; 0x^2 &#43; 0x^3$" /><meta property="og:image" content="https://mostafatouny.github.io/media/icon_hucf8be6c19c9550cf4f3e1aa359e52dbd_889622_512x512_fill_lanczos_center_3.png" /><meta property="og:locale" content="en-us" />

  
    <meta
      property="article:published_time"
      content="2023-02-26T00:00:00&#43;00:00"
    />
  
  
    <meta property="article:modified_time" content="2023-02-26T00:00:00&#43;00:00">
  







  




  
  
  

  
  

  


  
  <title>Problem Set 02 | Mostafa Touny</title>

  
  
  
  











</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper  dark " data-wc-page-id="51fa5db15e829fb93ba198c6c6243bb7" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.db21e13b9b5c4f4b947717750ec8b3cc.js"></script>

  




  <div class="page-header header--fixed">
  
  
  
  
  












<header>
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Mostafa Touny</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Mostafa Touny</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          

          

          
          
          
          

          
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/"><span>About</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/post/"><span>Blog</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        
          
        

        
        
        

        
        
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <article class="article">

  













  

  
  
  
<div class="article-container pt-3">
  <h1>Problem Set 02</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Feb 26, 2023
  </span>
  

  

  

  
  
  
  

  
  

</div>

    





  
</div>



  <div class="article-container">

    <div class="article-style">
      <h2 id="ex-2-1">Ex. 2-1</h2>
<p>done</p>
<h2 id="ex-2-2">Ex. 2-2</h2>
<p>For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.</p>
<p><strong>Double-degree form</strong></p>
<p>$A(x) = -10 + x + 0x^2 + 0x^3$</p>
<p>$B(x) = 3 - 6x + 0x^2 + 0x^3$</p>
<p><strong>Computing A(x) on sample</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-FFT(-10, 1, 0, 0)
</span></span><span class="line"><span class="cl">  n = 4
</span></span><span class="line"><span class="cl">  w_4 = e^{2 pi i / 4}
</span></span><span class="line"><span class="cl">  w = w_4^0 = 1
</span></span><span class="line"><span class="cl">  a[even] = (-10, 0)
</span></span><span class="line"><span class="cl">  a[odd] = (1, 0)
</span></span><span class="line"><span class="cl">  y[even] = Recursive-FFT(-10, 0) = (-10, -10)
</span></span><span class="line"><span class="cl">  y[odd] = Recursive-FFT(1, 0) = (1, 1)
</span></span><span class="line"><span class="cl">  for k=0 to 1
</span></span><span class="line"><span class="cl">    k=0
</span></span><span class="line"><span class="cl">	  y_0 = (-10) + (1)(1) = -9
</span></span><span class="line"><span class="cl">	  y_2 = (-10) - (1)(1) = -11
</span></span><span class="line"><span class="cl">	  w = w_4^1
</span></span><span class="line"><span class="cl">	k=1
</span></span><span class="line"><span class="cl">	  y_1 = (-10) + (e^{1 2 pi i / 4})(1) = -10+i
</span></span><span class="line"><span class="cl">	  y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i
</span></span><span class="line"><span class="cl">	  w = w_4^2
</span></span><span class="line"><span class="cl">  return (-9, -10+i, -11, -10-i)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-FFT(-10, 0)
</span></span><span class="line"><span class="cl">  n = 2
</span></span><span class="line"><span class="cl">  w_2 = e^{2 pi i / 2}
</span></span><span class="line"><span class="cl">  w = w_2^0 = 1
</span></span><span class="line"><span class="cl">  a[even] = (-10)
</span></span><span class="line"><span class="cl">  a[odd] = (0)
</span></span><span class="line"><span class="cl">  y[even] = Recursive-FFT(-10) = (-10)  // base case
</span></span><span class="line"><span class="cl">  y[odd] = Recursive-FFT(0) = (0)
</span></span><span class="line"><span class="cl">  for k=0 to 0
</span></span><span class="line"><span class="cl">    k=0
</span></span><span class="line"><span class="cl">	  y_0 = (-10) + w (0) = -10
</span></span><span class="line"><span class="cl">	  y_1 = (-10) - w (0) = -10
</span></span><span class="line"><span class="cl">	  w = w_2^1
</span></span><span class="line"><span class="cl">  return (-10, -10)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-FFT(1, 0)
</span></span><span class="line"><span class="cl">  n = 2
</span></span><span class="line"><span class="cl">  w_2 = e^{2 pi i / 2}
</span></span><span class="line"><span class="cl">  w = w_2^0 = 1
</span></span><span class="line"><span class="cl">  a[even] = (1)
</span></span><span class="line"><span class="cl">  a[odd] = (0)
</span></span><span class="line"><span class="cl">  y[even] = Recursive-FFT(1) = (1) // base case
</span></span><span class="line"><span class="cl">  y[odd] = Recursive-FFT(0) = (0)
</span></span><span class="line"><span class="cl">  for k=0 to 0
</span></span><span class="line"><span class="cl">    k=0
</span></span><span class="line"><span class="cl">	  y_0 = 1 + w(0) = 1
</span></span><span class="line"><span class="cl">	  y_1 = 1 - w(0) = 1
</span></span><span class="line"><span class="cl">	  w = w_2^1
</span></span><span class="line"><span class="cl">  return (1, 1)
</span></span></code></pre></div><p><strong>Computing B(x) on sample</strong></p>
<p>Similarly, we get $y=(-3, 3-6i, 9, 3+6i)$</p>
<p><strong>Computing C(x) on sample, By multiplying corresponding sample points of A and B</strong></p>
<p>$y = ((-9)(-3), (-10+i)(3-6i), (-11)(9), (-10-i)(3+6i)) = (27, -24+63i, -99, -24-63i)$</p>
<p><strong>Interpolating C(x) coefficients</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-IFFT(27, -24+63i, -99, -24-63i)
</span></span><span class="line"><span class="cl">  n = 4
</span></span><span class="line"><span class="cl">  w_4^-1 = e^{-1 i 2 pi / 4}
</span></span><span class="line"><span class="cl">  w = w_4^0 = 1
</span></span><span class="line"><span class="cl">  y[even] = (27, -99)
</span></span><span class="line"><span class="cl">  y[odd] = (-24+63i, -24-63i)
</span></span><span class="line"><span class="cl">  a[even] = Recursive-IFFT(27, -99) = (-72, 126)
</span></span><span class="line"><span class="cl">  a[odd] = Recursive-IFFT(-24+63i, -24-63i) = (-48, 126i)
</span></span><span class="line"><span class="cl">  for k=0 to 1
</span></span><span class="line"><span class="cl">    k=0
</span></span><span class="line"><span class="cl">	  y_0 = (-72) + (1)(-48) = -120
</span></span><span class="line"><span class="cl">	  y_2 = (-72) - (1)(-48) = -24
</span></span><span class="line"><span class="cl">	  w = w_4^-1
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	k=1
</span></span><span class="line"><span class="cl">	  y_1 = (126) + (e^{-1 i 2 pi / 4})(126i) = 252
</span></span><span class="line"><span class="cl">	  y_3 = (126) - (e^{-1 i 2 pi / 4})(126i) = 0
</span></span><span class="line"><span class="cl">	  w = w_4^-2
</span></span><span class="line"><span class="cl">  return (-120, 252, -24, 0)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-IFFT(27, -99)
</span></span><span class="line"><span class="cl">  n = 2
</span></span><span class="line"><span class="cl">  w_2^-1 = e^{-1 i 2 pi / 2}
</span></span><span class="line"><span class="cl">  w = w_2^0 = 1
</span></span><span class="line"><span class="cl">  y[even] = (27)
</span></span><span class="line"><span class="cl">  y[odd] (-99)
</span></span><span class="line"><span class="cl">  a[even] = Recursive-IFFT(27) = (27)  // base case
</span></span><span class="line"><span class="cl">  a[odd] = Recursive-IFFT(-99) = (-99)
</span></span><span class="line"><span class="cl">  for k=0 to 0
</span></span><span class="line"><span class="cl">    k=0
</span></span><span class="line"><span class="cl">	  y_0 = 27 + (1)(-99) = -72
</span></span><span class="line"><span class="cl">	  y_1 = 27 - (1)(-99) = 126
</span></span><span class="line"><span class="cl">	  w = w_2^-1
</span></span><span class="line"><span class="cl">  return (-72, 126)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-IFFT(-24+63i, -24-63i)
</span></span><span class="line"><span class="cl">  n = 2
</span></span><span class="line"><span class="cl">  w_2^-1 = e^{-1 i 2 pi /2}
</span></span><span class="line"><span class="cl">  w = w_2^0 = 1
</span></span><span class="line"><span class="cl">  y[even] = (-24+63i)
</span></span><span class="line"><span class="cl">  y[odd] = (-24-63i)
</span></span><span class="line"><span class="cl">  a[even] = Recursive-IFFT(-24+63i) = (-24+63i)
</span></span><span class="line"><span class="cl">  a[odd] = Recursive-IFFT(-24-63i) = (-24-63i)
</span></span><span class="line"><span class="cl">  for k=0 to 0
</span></span><span class="line"><span class="cl">    k=0
</span></span><span class="line"><span class="cl">	  y_0 = (-24+63i) + (1)(-24-63i) = -48
</span></span><span class="line"><span class="cl">	  y_1 = (-24+63i) - (1)(-24-63i) = 126i
</span></span><span class="line"><span class="cl">  return (-48, 126i)
</span></span></code></pre></div><p>Hence, Final answer is (-120, 252, -24, 0)/4 = (-30, 63, -6, 0), and resulting polynomial is $C(x) = -30 + 63x - 6x^2$.</p>
<h2 id="ex-2-3">Ex. 2-3</h2>
<p>Modifying <code>Recursive-FFT</code>, by switching $a$ and $y$, replacing $w_n$ by $w_n^{-1}$. Finally, result vector is divided by $n$.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Recursive-IFFT(y)
</span></span><span class="line"><span class="cl">  n = y.length
</span></span><span class="line"><span class="cl">  if n == 1
</span></span><span class="line"><span class="cl">    return y
</span></span><span class="line"><span class="cl">  w_n^-1 = e^{-1 2 pi i / n}
</span></span><span class="line"><span class="cl">  w = 1
</span></span><span class="line"><span class="cl">  y[even] = (y_0, y_2, ..., y_n-2})
</span></span><span class="line"><span class="cl">  y[odd] = (y_1, y_3, ..., y_n-1)
</span></span><span class="line"><span class="cl">  a[even] = Recursive-IFFT(y[even])
</span></span><span class="line"><span class="cl">  a[odd] = Recursive-IFFT(y[odd])
</span></span><span class="line"><span class="cl">  for k=0 to n/2 - 1
</span></span><span class="line"><span class="cl">    a_k = a[even]_k + w a[odd]_k
</span></span><span class="line"><span class="cl">	a_k+(n/2) = a[even]_k - w a[odd]_k
</span></span><span class="line"><span class="cl">	w = w w_n^-1
</span></span><span class="line"><span class="cl">  return a
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">a = a/n
</span></span></code></pre></div><h2 id="ex-2-4">Ex. 2-4</h2>
<p>done</p>
<h2 id="ex-2-5">Ex. 2-5</h2>
<p>Create operation accounts for number of pointers filled. Insert operations are modified to allow up to $2t-1$ keys in case of internal node, and up to $(2t-1) + (2t) = 4t-1$ keys in case of leaf node. That, by basically modifying the if condition. Also, insertion in place of pointers happens by checking whether a leaf have $2t-1$ keys.</p>
<p>Note we haven&rsquo;t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">B-TREE-CREATE(T)
</span></span><span class="line"><span class="cl">  x = ALLOCATE-NODE()
</span></span><span class="line"><span class="cl">  x.leaf = TRUE
</span></span><span class="line"><span class="cl">  x.n = 0
</span></span><span class="line"><span class="cl">  x.n&#39; = 0  // number of pointers to children filled
</span></span><span class="line"><span class="cl">  DISK-WRITE(x)
</span></span><span class="line"><span class="cl">  T.root = x
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">B-TREE-INSERT(T,k)
</span></span><span class="line"><span class="cl">  r = T.root
</span></span><span class="line"><span class="cl">  if (r.n == 2t-1 and not r.leaf) or (r.n == 4t-1 and r.leaf)  // different cases for internal and leaf nodes
</span></span><span class="line"><span class="cl">    s = ALLOCATE-NODE()
</span></span><span class="line"><span class="cl">	T.root = s
</span></span><span class="line"><span class="cl">	s.leaf = FALSE
</span></span><span class="line"><span class="cl">	s.n = 0
</span></span><span class="line"><span class="cl">	s.c1 = r
</span></span><span class="line"><span class="cl">	B-TREE-SPLIT-CHILD(s,1)
</span></span><span class="line"><span class="cl">	B-TREE-INSERT-NONFULL(s,k)
</span></span><span class="line"><span class="cl">  else
</span></span><span class="line"><span class="cl">    B-TREE-INSERT-NONFULL(r,k)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">B-TREE-INSERT-NONFULL(x,k)
</span></span><span class="line"><span class="cl">  if x.leaf
</span></span><span class="line"><span class="cl">    i = x.n + x.n&#39;  // sum of both keys and pointers
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while i &gt;= x.n + 1 and k &lt; x.c_(i-x.n)
</span></span><span class="line"><span class="cl">	  x.c_(i-x.n+1) = x.c_(i-x.n)
</span></span><span class="line"><span class="cl">	  i = i-1
</span></span><span class="line"><span class="cl">    while i &gt;= 1 and k &lt; x.key_i
</span></span><span class="line"><span class="cl">	  x.key_i+1 = x.key_i
</span></span><span class="line"><span class="cl">	  i = i-1
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	if i &gt;= x.n + 1
</span></span><span class="line"><span class="cl">	  x.c_i+1 = k
</span></span><span class="line"><span class="cl">	  x.n&#39; = x.n&#39; + 1
</span></span><span class="line"><span class="cl">	else
</span></span><span class="line"><span class="cl">	  x.key_i+1 = k
</span></span><span class="line"><span class="cl">	  x.n = x.n + 1
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	DISK-WRITE(x)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  else
</span></span><span class="line"><span class="cl">    i = x.n
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    while i&gt;=1 and k&lt;x.key_i
</span></span><span class="line"><span class="cl">	  i = i-1
</span></span><span class="line"><span class="cl">	i = i+1
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	DISK-READ(x,c_i)
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	if (x.c_i).n == 2t-1  // note this is an internal node
</span></span><span class="line"><span class="cl">	  B-TREE-SPLIT-CHILD(x,i)
</span></span><span class="line"><span class="cl">	  if k &gt; x.key_i
</span></span><span class="line"><span class="cl">	    i = i+1
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	B-TREE-INSERT-NONFULL(x.c_i, k)
</span></span></code></pre></div><h2 id="ex-3-2">Ex. 3-2</h2>
<p>We implement the prescription described in p.500.</p>
<p>Note we haven&rsquo;t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">B-TREE-DELETE(x, k)
</span></span><span class="line"><span class="cl">  // check if k is in node x
</span></span><span class="line"><span class="cl">  i = x.n
</span></span><span class="line"><span class="cl">  while i&gt;=1 and x.key_i != k
</span></span><span class="line"><span class="cl">    i = i-1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // k is found
</span></span><span class="line"><span class="cl">  if i&gt;=1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // x is a leaf node
</span></span><span class="line"><span class="cl">    if x.leaf
</span></span><span class="line"><span class="cl">      key_i = NULL
</span></span><span class="line"><span class="cl">      x.n = x.n - 1
</span></span><span class="line"><span class="cl">      x.shiftKeysAndPointers()  // for brevity we ignore implementing this subroutine
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // x is an internal node
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">	  y = x.c_i  // child preceeding k
</span></span><span class="line"><span class="cl">	  z = x.c_i+1  // child following k
</span></span><span class="line"><span class="cl">	  
</span></span><span class="line"><span class="cl">	  // number of keys in child preceeding k is at least t
</span></span><span class="line"><span class="cl">	  if y.n &gt;= t
</span></span><span class="line"><span class="cl">	    k&#39; = y.lastKey()  // implementation is ignored
</span></span><span class="line"><span class="cl">		B-TREE-DELETE(y, k&#39;)
</span></span><span class="line"><span class="cl">        key_i = k = k&#39;
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	  // number of keys in child following k is at least t
</span></span><span class="line"><span class="cl">	  else if z.n &gt;= t
</span></span><span class="line"><span class="cl">		// symmetrically replace k by k&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      // number of keys in both child following and preceeding k, is less than t
</span></span><span class="line"><span class="cl">      else 
</span></span><span class="line"><span class="cl">        mergeInto([y, k, z])  // merge k and z into y. implementation is ignored
</span></span><span class="line"><span class="cl">		x.c_i+1 = NULL
</span></span><span class="line"><span class="cl">		B-TREE-DELETE(k)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  // k isn&#39;t found in x
</span></span><span class="line"><span class="cl">  else
</span></span><span class="line"><span class="cl">    // find k in children
</span></span><span class="line"><span class="cl">	i = x.n
</span></span><span class="line"><span class="cl">    while i &gt;= 1 and k &lt; x.key_i
</span></span><span class="line"><span class="cl">	  i = i-1
</span></span><span class="line"><span class="cl">    y = x.c_(i+1) // subtree y containing k
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // guarantee we descend to a node containing at least t keys
</span></span><span class="line"><span class="cl">	if y.n == t-1
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">   	  if i+2 &lt;= x.n
</span></span><span class="line"><span class="cl">	    z = x.c_(i+2)  // immediate forward sibling of y
</span></span><span class="line"><span class="cl">	  if i &gt;= 1
</span></span><span class="line"><span class="cl">	    r = x.c_(i)  // immediate preceeding sibling of y
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	  // some sibling contains at least t keys
</span></span><span class="line"><span class="cl">      if z and z.n &gt;= t
</span></span><span class="line"><span class="cl">	    B-TREE-INSERT(y, key_i)
</span></span><span class="line"><span class="cl">	    B-TREE-DELETE(key_i)
</span></span><span class="line"><span class="cl">	    B-TREE-INSERT(x, z.firstKey())
</span></span><span class="line"><span class="cl">	    B-TREE-DELETE(z, z.firstKey())
</span></span><span class="line"><span class="cl">	    // don&#39;t get why a pointer from sibling should be moved to y
</span></span><span class="line"><span class="cl">	  else if r and r.n &gt;= t
</span></span><span class="line"><span class="cl">	    // symmetrically
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	  // both immediate siblings have t-1 keys
</span></span><span class="line"><span class="cl">	  else
</span></span><span class="line"><span class="cl">	    mergeInto([r, key_i, y])
</span></span><span class="line"><span class="cl">		x.c_(i+1) = NULL
</span></span><span class="line"><span class="cl">        B-TREE-DELETE(x, key_i)
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	// remove k from child y
</span></span><span class="line"><span class="cl">    B-TREE-DELETE(y, k)  
</span></span></code></pre></div><hr>
<h2 id="problem-2-1">Problem 2-1</h2>
<h3 id="a">a</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Match(S, P)
</span></span><span class="line"><span class="cl">  n = S.length
</span></span><span class="line"><span class="cl">  m = P.length
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  M = []
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  for i = 0..n-m+1
</span></span><span class="line"><span class="cl">    flag = true
</span></span><span class="line"><span class="cl">    for j = 0..m
</span></span><span class="line"><span class="cl">	  if P[j] != S[i+j] flag = false
</span></span><span class="line"><span class="cl">	if flag M.append(i)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  return M
</span></span></code></pre></div><h3 id="b">b</h3>
<p>Source string $S$ gets encoded as $S(x) = s_0x^0 + s_1x^1 + \dots + s_{n-1}x^{n-1}$, and pattern string $P$ as $P(x) = p_0x^{m-1} + p_1x^{m-2} + \dots + p_{m-1}x^0$, where $s_i$ and $p_i$ are, $1$ or $-1$, if characters $S[i]$ and $P[i]$, are $a$ or $b$, respectively. If $P[i] = *$, Then $p_i = 0$.</p>
<p>Observe $s_jp_k = 1$ if $S[j] = P[k]$, $s_jp_k = -1$ if $S[j] \neq P[k]$, and $s_jp_k = 0$ if $P[k] = *$. Observe for resulting polynomial $(s \cdot p)(x) = r_0x^0 + r_1x^1 + \cdots + r_{m+n-2}x^{m+n-2}$, Coefficient $r_i = \sum_{j+k=i} s_jp_k$, Exactly matches the sum of multiplying $s_{i-m+1}$, $s_{i-m+2}$, $\dots$, $s_{i-1}$, $s_i$ with $p_0$, $p_1$, $\dots$, $p_{m-1}$, respectively, for $i = m-1, m, \dots, n-1$. If and only if, All corresponding alphabetic characters are equal, Then each contributes to the sum by $+1$. Asterik $*$ always contributes nothing to the sum. Therefore, if $k$ is the number of alphabetic character in $P$ (non asterik characters), Then $r_i = k$ if and only if $P$ matches substring $S[i-m+1..i]$.</p>
<p>Now we can set output $M$ to be the ordered list of $i$ such that $r_i = k$, Then subtract each entry by $m-1$, so that $i$ matches the position of the first character of the substring.</p>
<p>Note coefficients $r_0$, $r_1$, $\dots$, $r_{m-2}$ are irrelevant to our consideration, Since they do not consider a matching with the whole characters of pattern string $P$.</p>
<p>For the example, $S = ababbab$ and $P = ab*$,
\begin{align*}
S(x) &amp;= (1)x^0 + (-1)x^1 + (1)x^2 + (-1)x^3 + (-1)x^4 + (1)x^5 + (-1)x^6 \\
P(x) &amp;= (1)x^2 + (-1)x^1 + (0)x^0 \\
(S \cdot P)(x) &amp;= (-1)x^1 + (x)x^2 + (-2)x^3 + (2)x^4 + (1)x^7 + (-1)x^8 \\
M &amp;= [2, 4] \\
M &amp;= [2 - (m-1), 4 - (m-1)] = [2 - (3-1), 4 - (3-1)] \\
M &amp;= [0, 2]
\end{align*}</p>
<h3 id="c">c</h3>
<p>$\mathcal{O}(n \lg n)$, Since each operation of my algorithm requires at most a linear scan of complexity $\mathcal{O}(n)$</p>
<h3 id="d">d</h3>
<p>Exactly as $b$, but characters are encoded as</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>C</th>
<th>G</th>
<th>T</th>
<th>*</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>1</td>
<td>-1</td>
<td>i</td>
<td>-i</td>
<td></td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>1</td>
<td>-1</td>
<td>-i</td>
<td>i</td>
<td>0</td>
<td></td>
</tr>
</tbody>
</table>
<p>Note if characters are matching, Then as before, each contributes to the sum by $+1$. In case of non-matching, A number less than $+1$ or an imaginary number is contributed.</p>
<h2 id="problem-2-2">Problem 2-2</h2>
<h3 id="a-1">a</h3>
<p>Merge roots of $T_1$ and $T_2$, placing $k$ in between them. If new root&rsquo;s keys are greater than $2t-1$, Apply the standard operation of split and push median up.</p>
<p>Note roots of $T_1$ and $T_2$, each has at most $2t-1$ keys. When merging the new root is at most $(2t-1) + (2t-1) + 1 = 4t-1$. If we spllitted, We get a new root of key size exactly 1 and two childs, Each is of size at most $2t-1$.</p>
<h3 id="b-1">b</h3>
<p>Modify $T_1$ to decrease its height by one, Then apply the same procedure of <em>a</em>. That, by merging all of $T_1$&rsquo;s children into its root. In other words, $Merge(x.c_0, key_0, x.c_1, key_1, \dots, x.c_{n-1}, key_{n-1}, x.c_{n})$. Note new root of $T_1$ has at most $(2t-1) + (2t)(2t-1) = (2t+1)(2t-1) = 4t^2 - 1$ keys.</p>
<p>As in <em>a</em>, Merge $T_1$, $k$, and $T_2$. The new root has at most $(4t^2 - 1) + (2t-1) + 1 = (2t+2)(2t-1) + 1 = 4t^2 + 2t - 1$ keys. Hence we are going to split around $\mathcal{O}(\lg t^2) = \mathcal{O}(\lg t)$ times. Note that shall result in many one-key nodes. So, at most $\mathcal{O}(\lg t)$ merge of one-key nodes, to finally fix the tree. But since $t$ is assumed to be a constant, the total complexity is $\mathcal{O}(1)$.</p>
<h3 id="c-1">c</h3>
<p>The tree&rsquo;s height is increased only when the root has a full capacity of keys, and a new root is allocated.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">B-TREE-INSERT(T,k)
</span></span><span class="line"><span class="cl">r = T.root
</span></span><span class="line"><span class="cl">if r.n == 2t-1
</span></span><span class="line"><span class="cl">  s = ALLOCATE-NODE()
</span></span><span class="line"><span class="cl">  T.root = s
</span></span><span class="line"><span class="cl">  s.leaf = FALSE
</span></span><span class="line"><span class="cl">  s.n = 0
</span></span><span class="line"><span class="cl">  s.c1 = r
</span></span><span class="line"><span class="cl">  s.height = r.height+1  // new root is of height +1 than the previous one
</span></span><span class="line"><span class="cl">  B-TREE-SPLIT-CHILD(s,1)
</span></span><span class="line"><span class="cl">  B-TREE-INSERT-NONFULL(s,k)
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">  B-TREE-INSERT-NONFULL(r,k)
</span></span></code></pre></div><p>Tree shrinks only when a merge happens with the root alongside its children. If we assumed the new root is updated to point to one of the children, Then no height variable needs to be updated.</p>
<h3 id="d-1">d</h3>
<p>Without the loss of generality assume $h_1 \geq h_2$. Then the procedure of $b$ is applied $h_1 - h_2$ times so $T_1$ and $T_2$ have the same weight. Then the procedure of <em>a</em> is applied to combine them. Each operation costs a constant time, Hence a complexity upperbounded by $\mathcal{O}((h_1 - h_2) + 1)$.</p>

    </div>

    







<div class="share-box">
  <ul class="share">
    
  </ul>
</div>



















  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  












  
  
  
  
  













  





  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      Published with <a href="https://hugoblox.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Hugo Blox Builder</a> — the free, <a href="https://github.com/HugoBlox/hugo-blox-builder" target="_blank" rel="noopener">open source</a> website builder that empowers creators.
    
  </p>
</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.938a3a7554cd9f6602290411f64d2617.js"></script>




  

  
  

  








































<script id="page-data" type="application/json">{"use_headroom":true}</script>


  <script src="/js/wowchemy-headroom.db4755770454eb63685f8de785c0a172.js" type="module"></script>










<script src="/en/js/wowchemy.min.dddc448a63b69628e8b50b98438b6866.js"></script>

























</body>
</html>
