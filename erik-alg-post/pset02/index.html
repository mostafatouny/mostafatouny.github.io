<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Problem Set 02 | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="Ex. 2-1
done
Ex. 2-2
For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 &#43; x$ with $B(x) = 3 - 6x$.
Double-degree form
$A(x) = -10 &#43; x &#43; 0x^2 &#43; 0x^3$
$B(x) = 3 - 6x &#43; 0x^2 &#43; 0x^3$
Computing A(x) on sample
Recursive-FFT(-10, 1, 0, 0)
  n = 4
  w_4 = e^{2 pi i / 4}
  w = w_4^0 = 1
  a[even] = (-10, 0)
  a[odd] = (1, 0)
  y[even] = Recursive-FFT(-10, 0) = (-10, -10)
  y[odd] = Recursive-FFT(1, 0) = (1, 1)
  for k=0 to 1
    k=0
	  y_0 = (-10) &#43; (1)(1) = -9
	  y_2 = (-10) - (1)(1) = -11
	  w = w_4^1
	k=1
	  y_1 = (-10) &#43; (e^{1 2 pi i / 4})(1) = -10&#43;i
	  y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i
	  w = w_4^2
  return (-9, -10&#43;i, -11, -10-i)
Recursive-FFT(-10, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (-10)
  a[odd] = (0)
  y[even] = Recursive-FFT(-10) = (-10)  // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = (-10) &#43; w (0) = -10
	  y_1 = (-10) - w (0) = -10
	  w = w_2^1
  return (-10, -10)
Recursive-FFT(1, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (1)
  a[odd] = (0)
  y[even] = Recursive-FFT(1) = (1) // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = 1 &#43; w(0) = 1
	  y_1 = 1 - w(0) = 1
	  w = w_2^1
  return (1, 1)
Computing B(x) on sample">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/erik-alg-post/pset02/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/erik-alg-post/pset02/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Problem Set 02" />
<meta property="og:description" content="Ex. 2-1
done
Ex. 2-2
For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 &#43; x$ with $B(x) = 3 - 6x$.
Double-degree form
$A(x) = -10 &#43; x &#43; 0x^2 &#43; 0x^3$
$B(x) = 3 - 6x &#43; 0x^2 &#43; 0x^3$
Computing A(x) on sample
Recursive-FFT(-10, 1, 0, 0)
  n = 4
  w_4 = e^{2 pi i / 4}
  w = w_4^0 = 1
  a[even] = (-10, 0)
  a[odd] = (1, 0)
  y[even] = Recursive-FFT(-10, 0) = (-10, -10)
  y[odd] = Recursive-FFT(1, 0) = (1, 1)
  for k=0 to 1
    k=0
	  y_0 = (-10) &#43; (1)(1) = -9
	  y_2 = (-10) - (1)(1) = -11
	  w = w_4^1
	k=1
	  y_1 = (-10) &#43; (e^{1 2 pi i / 4})(1) = -10&#43;i
	  y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i
	  w = w_4^2
  return (-9, -10&#43;i, -11, -10-i)
Recursive-FFT(-10, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (-10)
  a[odd] = (0)
  y[even] = Recursive-FFT(-10) = (-10)  // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = (-10) &#43; w (0) = -10
	  y_1 = (-10) - w (0) = -10
	  w = w_2^1
  return (-10, -10)
Recursive-FFT(1, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (1)
  a[odd] = (0)
  y[even] = Recursive-FFT(1) = (1) // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = 1 &#43; w(0) = 1
	  y_1 = 1 - w(0) = 1
	  w = w_2^1
  return (1, 1)
Computing B(x) on sample" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/erik-alg-post/pset02/" /><meta property="article:section" content="erik-alg-post" />
<meta property="article:published_time" content="2023-02-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-26T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Problem Set 02"/>
<meta name="twitter:description" content="Ex. 2-1
done
Ex. 2-2
For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 &#43; x$ with $B(x) = 3 - 6x$.
Double-degree form
$A(x) = -10 &#43; x &#43; 0x^2 &#43; 0x^3$
$B(x) = 3 - 6x &#43; 0x^2 &#43; 0x^3$
Computing A(x) on sample
Recursive-FFT(-10, 1, 0, 0)
  n = 4
  w_4 = e^{2 pi i / 4}
  w = w_4^0 = 1
  a[even] = (-10, 0)
  a[odd] = (1, 0)
  y[even] = Recursive-FFT(-10, 0) = (-10, -10)
  y[odd] = Recursive-FFT(1, 0) = (1, 1)
  for k=0 to 1
    k=0
	  y_0 = (-10) &#43; (1)(1) = -9
	  y_2 = (-10) - (1)(1) = -11
	  w = w_4^1
	k=1
	  y_1 = (-10) &#43; (e^{1 2 pi i / 4})(1) = -10&#43;i
	  y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i
	  w = w_4^2
  return (-9, -10&#43;i, -11, -10-i)
Recursive-FFT(-10, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (-10)
  a[odd] = (0)
  y[even] = Recursive-FFT(-10) = (-10)  // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = (-10) &#43; w (0) = -10
	  y_1 = (-10) - w (0) = -10
	  w = w_2^1
  return (-10, -10)
Recursive-FFT(1, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (1)
  a[odd] = (0)
  y[even] = Recursive-FFT(1) = (1) // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = 1 &#43; w(0) = 1
	  y_1 = 1 - w(0) = 1
	  w = w_2^1
  return (1, 1)
Computing B(x) on sample"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Erik's Algorithms",
      "item": "https://www.mostafatouny.github.io/erik-alg-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Problem Set 02",
      "item": "https://www.mostafatouny.github.io/erik-alg-post/pset02/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Problem Set 02",
  "name": "Problem Set 02",
  "description": "Ex. 2-1 done\nEx. 2-2 For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.\nDouble-degree form\n$A(x) = -10 + x + 0x^2 + 0x^3$\n$B(x) = 3 - 6x + 0x^2 + 0x^3$\nComputing A(x) on sample\nRecursive-FFT(-10, 1, 0, 0) n = 4 w_4 = e^{2 pi i / 4} w = w_4^0 = 1 a[even] = (-10, 0) a[odd] = (1, 0) y[even] = Recursive-FFT(-10, 0) = (-10, -10) y[odd] = Recursive-FFT(1, 0) = (1, 1) for k=0 to 1 k=0 y_0 = (-10) + (1)(1) = -9 y_2 = (-10) - (1)(1) = -11 w = w_4^1 k=1 y_1 = (-10) + (e^{1 2 pi i / 4})(1) = -10+i y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i w = w_4^2 return (-9, -10+i, -11, -10-i) Recursive-FFT(-10, 0) n = 2 w_2 = e^{2 pi i / 2} w = w_2^0 = 1 a[even] = (-10) a[odd] = (0) y[even] = Recursive-FFT(-10) = (-10) // base case y[odd] = Recursive-FFT(0) = (0) for k=0 to 0 k=0 y_0 = (-10) + w (0) = -10 y_1 = (-10) - w (0) = -10 w = w_2^1 return (-10, -10) Recursive-FFT(1, 0) n = 2 w_2 = e^{2 pi i / 2} w = w_2^0 = 1 a[even] = (1) a[odd] = (0) y[even] = Recursive-FFT(1) = (1) // base case y[odd] = Recursive-FFT(0) = (0) for k=0 to 0 k=0 y_0 = 1 + w(0) = 1 y_1 = 1 - w(0) = 1 w = w_2^1 return (1, 1) Computing B(x) on sample\n",
  "keywords": [
    
  ],
  "articleBody": "Ex. 2-1 done\nEx. 2-2 For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.\nDouble-degree form\n$A(x) = -10 + x + 0x^2 + 0x^3$\n$B(x) = 3 - 6x + 0x^2 + 0x^3$\nComputing A(x) on sample\nRecursive-FFT(-10, 1, 0, 0) n = 4 w_4 = e^{2 pi i / 4} w = w_4^0 = 1 a[even] = (-10, 0) a[odd] = (1, 0) y[even] = Recursive-FFT(-10, 0) = (-10, -10) y[odd] = Recursive-FFT(1, 0) = (1, 1) for k=0 to 1 k=0 y_0 = (-10) + (1)(1) = -9 y_2 = (-10) - (1)(1) = -11 w = w_4^1 k=1 y_1 = (-10) + (e^{1 2 pi i / 4})(1) = -10+i y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i w = w_4^2 return (-9, -10+i, -11, -10-i) Recursive-FFT(-10, 0) n = 2 w_2 = e^{2 pi i / 2} w = w_2^0 = 1 a[even] = (-10) a[odd] = (0) y[even] = Recursive-FFT(-10) = (-10) // base case y[odd] = Recursive-FFT(0) = (0) for k=0 to 0 k=0 y_0 = (-10) + w (0) = -10 y_1 = (-10) - w (0) = -10 w = w_2^1 return (-10, -10) Recursive-FFT(1, 0) n = 2 w_2 = e^{2 pi i / 2} w = w_2^0 = 1 a[even] = (1) a[odd] = (0) y[even] = Recursive-FFT(1) = (1) // base case y[odd] = Recursive-FFT(0) = (0) for k=0 to 0 k=0 y_0 = 1 + w(0) = 1 y_1 = 1 - w(0) = 1 w = w_2^1 return (1, 1) Computing B(x) on sample\nSimilarly, we get $y=(-3, 3-6i, 9, 3+6i)$\nComputing C(x) on sample, By multiplying corresponding sample points of A and B\n$y = ((-9)(-3), (-10+i)(3-6i), (-11)(9), (-10-i)(3+6i)) = (27, -24+63i, -99, -24-63i)$\nInterpolating C(x) coefficients\nRecursive-IFFT(27, -24+63i, -99, -24-63i) n = 4 w_4^-1 = e^{-1 i 2 pi / 4} w = w_4^0 = 1 y[even] = (27, -99) y[odd] = (-24+63i, -24-63i) a[even] = Recursive-IFFT(27, -99) = (-72, 126) a[odd] = Recursive-IFFT(-24+63i, -24-63i) = (-48, 126i) for k=0 to 1 k=0 y_0 = (-72) + (1)(-48) = -120 y_2 = (-72) - (1)(-48) = -24 w = w_4^-1 k=1 y_1 = (126) + (e^{-1 i 2 pi / 4})(126i) = 252 y_3 = (126) - (e^{-1 i 2 pi / 4})(126i) = 0 w = w_4^-2 return (-120, 252, -24, 0) Recursive-IFFT(27, -99) n = 2 w_2^-1 = e^{-1 i 2 pi / 2} w = w_2^0 = 1 y[even] = (27) y[odd] (-99) a[even] = Recursive-IFFT(27) = (27) // base case a[odd] = Recursive-IFFT(-99) = (-99) for k=0 to 0 k=0 y_0 = 27 + (1)(-99) = -72 y_1 = 27 - (1)(-99) = 126 w = w_2^-1 return (-72, 126) Recursive-IFFT(-24+63i, -24-63i) n = 2 w_2^-1 = e^{-1 i 2 pi /2} w = w_2^0 = 1 y[even] = (-24+63i) y[odd] = (-24-63i) a[even] = Recursive-IFFT(-24+63i) = (-24+63i) a[odd] = Recursive-IFFT(-24-63i) = (-24-63i) for k=0 to 0 k=0 y_0 = (-24+63i) + (1)(-24-63i) = -48 y_1 = (-24+63i) - (1)(-24-63i) = 126i return (-48, 126i) Hence, Final answer is (-120, 252, -24, 0)/4 = (-30, 63, -6, 0), and resulting polynomial is $C(x) = -30 + 63x - 6x^2$.\nEx. 2-3 Modifying Recursive-FFT, by switching $a$ and $y$, replacing $w_n$ by $w_n^{-1}$. Finally, result vector is divided by $n$.\nRecursive-IFFT(y) n = y.length if n == 1 return y w_n^-1 = e^{-1 2 pi i / n} w = 1 y[even] = (y_0, y_2, ..., y_n-2}) y[odd] = (y_1, y_3, ..., y_n-1) a[even] = Recursive-IFFT(y[even]) a[odd] = Recursive-IFFT(y[odd]) for k=0 to n/2 - 1 a_k = a[even]_k + w a[odd]_k a_k+(n/2) = a[even]_k - w a[odd]_k w = w w_n^-1 return a a = a/n Ex. 2-4 done\nEx. 2-5 Create operation accounts for number of pointers filled. Insert operations are modified to allow up to $2t-1$ keys in case of internal node, and up to $(2t-1) + (2t) = 4t-1$ keys in case of leaf node. That, by basically modifying the if condition. Also, insertion in place of pointers happens by checking whether a leaf have $2t-1$ keys.\nNote we haven’t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.\nB-TREE-CREATE(T) x = ALLOCATE-NODE() x.leaf = TRUE x.n = 0 x.n' = 0 // number of pointers to children filled DISK-WRITE(x) T.root = x B-TREE-INSERT(T,k) r = T.root if (r.n == 2t-1 and not r.leaf) or (r.n == 4t-1 and r.leaf) // different cases for internal and leaf nodes s = ALLOCATE-NODE() T.root = s s.leaf = FALSE s.n = 0 s.c1 = r B-TREE-SPLIT-CHILD(s,1) B-TREE-INSERT-NONFULL(s,k) else B-TREE-INSERT-NONFULL(r,k) B-TREE-INSERT-NONFULL(x,k) if x.leaf i = x.n + x.n' // sum of both keys and pointers while i \u003e= x.n + 1 and k \u003c x.c_(i-x.n) x.c_(i-x.n+1) = x.c_(i-x.n) i = i-1 while i \u003e= 1 and k \u003c x.key_i x.key_i+1 = x.key_i i = i-1 if i \u003e= x.n + 1 x.c_i+1 = k x.n' = x.n' + 1 else x.key_i+1 = k x.n = x.n + 1 DISK-WRITE(x) else i = x.n while i\u003e=1 and k x.key_i i = i+1 B-TREE-INSERT-NONFULL(x.c_i, k) Ex. 3-2 We implement the prescription described in p.500.\nNote we haven’t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.\nB-TREE-DELETE(x, k) // check if k is in node x i = x.n while i\u003e=1 and x.key_i != k i = i-1 // k is found if i\u003e=1 // x is a leaf node if x.leaf key_i = NULL x.n = x.n - 1 x.shiftKeysAndPointers() // for brevity we ignore implementing this subroutine // x is an internal node else y = x.c_i // child preceeding k z = x.c_i+1 // child following k // number of keys in child preceeding k is at least t if y.n \u003e= t k' = y.lastKey() // implementation is ignored B-TREE-DELETE(y, k') key_i = k = k' // number of keys in child following k is at least t else if z.n \u003e= t // symmetrically replace k by k' // number of keys in both child following and preceeding k, is less than t else mergeInto([y, k, z]) // merge k and z into y. implementation is ignored x.c_i+1 = NULL B-TREE-DELETE(k) // k isn't found in x else // find k in children i = x.n while i \u003e= 1 and k \u003c x.key_i i = i-1 y = x.c_(i+1) // subtree y containing k // guarantee we descend to a node containing at least t keys if y.n == t-1 if i+2 \u003c= x.n z = x.c_(i+2) // immediate forward sibling of y if i \u003e= 1 r = x.c_(i) // immediate preceeding sibling of y // some sibling contains at least t keys if z and z.n \u003e= t B-TREE-INSERT(y, key_i) B-TREE-DELETE(key_i) B-TREE-INSERT(x, z.firstKey()) B-TREE-DELETE(z, z.firstKey()) // don't get why a pointer from sibling should be moved to y else if r and r.n \u003e= t // symmetrically // both immediate siblings have t-1 keys else mergeInto([r, key_i, y]) x.c_(i+1) = NULL B-TREE-DELETE(x, key_i) // remove k from child y B-TREE-DELETE(y, k) Problem 2-1 a Match(S, P) n = S.length m = P.length M = [] for i = 0..n-m+1 flag = true for j = 0..m if P[j] != S[i+j] flag = false if flag M.append(i) return M b Source string $S$ gets encoded as $S(x) = s_0x^0 + s_1x^1 + \\dots + s_{n-1}x^{n-1}$, and pattern string $P$ as $P(x) = p_0x^{m-1} + p_1x^{m-2} + \\dots + p_{m-1}x^0$, where $s_i$ and $p_i$ are, $1$ or $-1$, if characters $S[i]$ and $P[i]$, are $a$ or $b$, respectively. If $P[i] = *$, Then $p_i = 0$.\nObserve $s_jp_k = 1$ if $S[j] = P[k]$, $s_jp_k = -1$ if $S[j] \\neq P[k]$, and $s_jp_k = 0$ if $P[k] = \\*$. Observe for resulting polynomial $(s \\cdot p)(x) = r_0x^0 + r_1x^1 + \\cdots + r_{m+n-2}x^{m+n-2}$, Coefficient $r_i = \\sum_{j+k=i} s_jp_k$, Exactly matches the sum of multiplying $s_{i-m+1}$, $s_{i-m+2}$, $\\dots$, $s_{i-1}$, $s_i$ with $p_0$, $p_1$, $\\dots$, $p_{m-1}$, respectively, for $i = m-1, m, \\dots, n-1$. If and only if, All corresponding alphabetic characters are equal, Then each contributes to the sum by $+1$. Asterik $*$ always contributes nothing to the sum. Therefore, if $k$ is the number of alphabetic character in $P$ (non asterik characters), Then $r_i = k$ if and only if $P$ matches substring $S[i-m+1..i]$.\nNow we can set output $M$ to be the ordered list of $i$ such that $r_i = k$, Then subtract each entry by $m-1$, so that $i$ matches the position of the first character of the substring.\nNote coefficients $r_0$, $r_1$, $\\dots$, $r_{m-2}$ are irrelevant to our consideration, Since they do not consider a matching with the whole characters of pattern string $P$.\nFor the example, $S = ababbab$ and $P = ab*$, \\begin{align*} S(x) \u0026= (1)x^0 + (-1)x^1 + (1)x^2 + (-1)x^3 + (-1)x^4 + (1)x^5 + (-1)x^6 \\\\ P(x) \u0026= (1)x^2 + (-1)x^1 + (0)x^0 \\\\ (S \\cdot P)(x) \u0026= (-1)x^1 + (x)x^2 + (-2)x^3 + (2)x^4 + (1)x^7 + (-1)x^8 \\\\ M \u0026= [2, 4] \\\\ M \u0026= [2 - (m-1), 4 - (m-1)] = [2 - (3-1), 4 - (3-1)] \\\\ M \u0026= [0, 2] \\end{align*}\nc $\\mathcal{O}(n \\lg n)$, Since each operation of my algorithm requires at most a linear scan of complexity $\\mathcal{O}(n)$\nd Exactly as $b$, but characters are encoded as\nA C G T * S 1 -1 i -i P 1 -1 -i i 0 Note if characters are matching, Then as before, each contributes to the sum by $+1$. In case of non-matching, A number less than $+1$ or an imaginary number is contributed.\nProblem 2-2 a Merge roots of $T_1$ and $T_2$, placing $k$ in between them. If new root’s keys are greater than $2t-1$, Apply the standard operation of split and push median up.\nNote roots of $T_1$ and $T_2$, each has at most $2t-1$ keys. When merging the new root is at most $(2t-1) + (2t-1) + 1 = 4t-1$. If we spllitted, We get a new root of key size exactly 1 and two childs, Each is of size at most $2t-1$.\nb Modify $T_1$ to decrease its height by one, Then apply the same procedure of a. That, by merging all of $T_1$’s children into its root. In other words, $Merge(x.c_0, key_0, x.c_1, key_1, \\dots, x.c_{n-1}, key_{n-1}, x.c_{n})$. Note new root of $T_1$ has at most $(2t-1) + (2t)(2t-1) = (2t+1)(2t-1) = 4t^2 - 1$ keys.\nAs in a, Merge $T_1$, $k$, and $T_2$. The new root has at most $(4t^2 - 1) + (2t-1) + 1 = (2t+2)(2t-1) + 1 = 4t^2 + 2t - 1$ keys. Hence we are going to split around $\\mathcal{O}(\\lg t^2) = \\mathcal{O}(\\lg t)$ times. Note that shall result in many one-key nodes. So, at most $\\mathcal{O}(\\lg t)$ merge of one-key nodes, to finally fix the tree. But since $t$ is assumed to be a constant, the total complexity is $\\mathcal{O}(1)$.\nc The tree’s height is increased only when the root has a full capacity of keys, and a new root is allocated.\nB-TREE-INSERT(T,k) r = T.root if r.n == 2t-1 s = ALLOCATE-NODE() T.root = s s.leaf = FALSE s.n = 0 s.c1 = r s.height = r.height+1 // new root is of height +1 than the previous one B-TREE-SPLIT-CHILD(s,1) B-TREE-INSERT-NONFULL(s,k) else B-TREE-INSERT-NONFULL(r,k) Tree shrinks only when a merge happens with the root alongside its children. If we assumed the new root is updated to point to one of the children, Then no height variable needs to be updated.\nd Without the loss of generality assume $h_1 \\geq h_2$. Then the procedure of $b$ is applied $h_1 - h_2$ times so $T_1$ and $T_2$ have the same weight. Then the procedure of a is applied to combine them. Each operation costs a constant time, Hence a complexity upperbounded by $\\mathcal{O}((h_1 - h_2) + 1)$.\n",
  "wordCount" : "2022",
  "inLanguage": "en",
  "datePublished": "2023-02-26T00:00:00Z",
  "dateModified": "2023-02-26T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/erik-alg-post/pset02/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Problem Set 02
    </h1>
    <div class="post-meta"><span title='2023-02-26 00:00:00 +0000 UTC'>February 26, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#ex-2-1" aria-label="Ex. 2-1">Ex. 2-1</a></li>
                <li>
                    <a href="#ex-2-2" aria-label="Ex. 2-2">Ex. 2-2</a></li>
                <li>
                    <a href="#ex-2-3" aria-label="Ex. 2-3">Ex. 2-3</a></li>
                <li>
                    <a href="#ex-2-4" aria-label="Ex. 2-4">Ex. 2-4</a></li>
                <li>
                    <a href="#ex-2-5" aria-label="Ex. 2-5">Ex. 2-5</a></li>
                <li>
                    <a href="#ex-3-2" aria-label="Ex. 3-2">Ex. 3-2</a></li>
                <li>
                    <a href="#problem-2-1" aria-label="Problem 2-1">Problem 2-1</a><ul>
                        
                <li>
                    <a href="#a" aria-label="a">a</a></li>
                <li>
                    <a href="#b" aria-label="b">b</a></li>
                <li>
                    <a href="#c" aria-label="c">c</a></li>
                <li>
                    <a href="#d" aria-label="d">d</a></li></ul>
                </li>
                <li>
                    <a href="#problem-2-2" aria-label="Problem 2-2">Problem 2-2</a><ul>
                        
                <li>
                    <a href="#a-1" aria-label="a">a</a></li>
                <li>
                    <a href="#b-1" aria-label="b">b</a></li>
                <li>
                    <a href="#c-1" aria-label="c">c</a></li>
                <li>
                    <a href="#d-1" aria-label="d">d</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="ex-2-1">Ex. 2-1<a hidden class="anchor" aria-hidden="true" href="#ex-2-1">#</a></h2>
<p>done</p>
<h2 id="ex-2-2">Ex. 2-2<a hidden class="anchor" aria-hidden="true" href="#ex-2-2">#</a></h2>
<p>For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.</p>
<p><strong>Double-degree form</strong></p>
<p>$A(x) = -10 + x + 0x^2 + 0x^3$</p>
<p>$B(x) = 3 - 6x + 0x^2 + 0x^3$</p>
<p><strong>Computing A(x) on sample</strong></p>
<pre tabindex="0"><code>Recursive-FFT(-10, 1, 0, 0)
  n = 4
  w_4 = e^{2 pi i / 4}
  w = w_4^0 = 1
  a[even] = (-10, 0)
  a[odd] = (1, 0)
  y[even] = Recursive-FFT(-10, 0) = (-10, -10)
  y[odd] = Recursive-FFT(1, 0) = (1, 1)
  for k=0 to 1
    k=0
	  y_0 = (-10) + (1)(1) = -9
	  y_2 = (-10) - (1)(1) = -11
	  w = w_4^1
	k=1
	  y_1 = (-10) + (e^{1 2 pi i / 4})(1) = -10+i
	  y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i
	  w = w_4^2
  return (-9, -10+i, -11, -10-i)
</code></pre><pre tabindex="0"><code>Recursive-FFT(-10, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (-10)
  a[odd] = (0)
  y[even] = Recursive-FFT(-10) = (-10)  // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = (-10) + w (0) = -10
	  y_1 = (-10) - w (0) = -10
	  w = w_2^1
  return (-10, -10)
</code></pre><pre tabindex="0"><code>Recursive-FFT(1, 0)
  n = 2
  w_2 = e^{2 pi i / 2}
  w = w_2^0 = 1
  a[even] = (1)
  a[odd] = (0)
  y[even] = Recursive-FFT(1) = (1) // base case
  y[odd] = Recursive-FFT(0) = (0)
  for k=0 to 0
    k=0
	  y_0 = 1 + w(0) = 1
	  y_1 = 1 - w(0) = 1
	  w = w_2^1
  return (1, 1)
</code></pre><p><strong>Computing B(x) on sample</strong></p>
<p>Similarly, we get $y=(-3, 3-6i, 9, 3+6i)$</p>
<p><strong>Computing C(x) on sample, By multiplying corresponding sample points of A and B</strong></p>
<p>$y = ((-9)(-3), (-10+i)(3-6i), (-11)(9), (-10-i)(3+6i)) = (27, -24+63i, -99, -24-63i)$</p>
<p><strong>Interpolating C(x) coefficients</strong></p>
<pre tabindex="0"><code>Recursive-IFFT(27, -24+63i, -99, -24-63i)
  n = 4
  w_4^-1 = e^{-1 i 2 pi / 4}
  w = w_4^0 = 1
  y[even] = (27, -99)
  y[odd] = (-24+63i, -24-63i)
  a[even] = Recursive-IFFT(27, -99) = (-72, 126)
  a[odd] = Recursive-IFFT(-24+63i, -24-63i) = (-48, 126i)
  for k=0 to 1
    k=0
	  y_0 = (-72) + (1)(-48) = -120
	  y_2 = (-72) - (1)(-48) = -24
	  w = w_4^-1
	
	k=1
	  y_1 = (126) + (e^{-1 i 2 pi / 4})(126i) = 252
	  y_3 = (126) - (e^{-1 i 2 pi / 4})(126i) = 0
	  w = w_4^-2
  return (-120, 252, -24, 0)
</code></pre><pre tabindex="0"><code>Recursive-IFFT(27, -99)
  n = 2
  w_2^-1 = e^{-1 i 2 pi / 2}
  w = w_2^0 = 1
  y[even] = (27)
  y[odd] (-99)
  a[even] = Recursive-IFFT(27) = (27)  // base case
  a[odd] = Recursive-IFFT(-99) = (-99)
  for k=0 to 0
    k=0
	  y_0 = 27 + (1)(-99) = -72
	  y_1 = 27 - (1)(-99) = 126
	  w = w_2^-1
  return (-72, 126)
</code></pre><pre tabindex="0"><code>Recursive-IFFT(-24+63i, -24-63i)
  n = 2
  w_2^-1 = e^{-1 i 2 pi /2}
  w = w_2^0 = 1
  y[even] = (-24+63i)
  y[odd] = (-24-63i)
  a[even] = Recursive-IFFT(-24+63i) = (-24+63i)
  a[odd] = Recursive-IFFT(-24-63i) = (-24-63i)
  for k=0 to 0
    k=0
	  y_0 = (-24+63i) + (1)(-24-63i) = -48
	  y_1 = (-24+63i) - (1)(-24-63i) = 126i
  return (-48, 126i)
</code></pre><p>Hence, Final answer is (-120, 252, -24, 0)/4 = (-30, 63, -6, 0), and resulting polynomial is $C(x) = -30 + 63x - 6x^2$.</p>
<h2 id="ex-2-3">Ex. 2-3<a hidden class="anchor" aria-hidden="true" href="#ex-2-3">#</a></h2>
<p>Modifying <code>Recursive-FFT</code>, by switching $a$ and $y$, replacing $w_n$ by $w_n^{-1}$. Finally, result vector is divided by $n$.</p>
<pre tabindex="0"><code>Recursive-IFFT(y)
  n = y.length
  if n == 1
    return y
  w_n^-1 = e^{-1 2 pi i / n}
  w = 1
  y[even] = (y_0, y_2, ..., y_n-2})
  y[odd] = (y_1, y_3, ..., y_n-1)
  a[even] = Recursive-IFFT(y[even])
  a[odd] = Recursive-IFFT(y[odd])
  for k=0 to n/2 - 1
    a_k = a[even]_k + w a[odd]_k
	a_k+(n/2) = a[even]_k - w a[odd]_k
	w = w w_n^-1
  return a
  
a = a/n
</code></pre><h2 id="ex-2-4">Ex. 2-4<a hidden class="anchor" aria-hidden="true" href="#ex-2-4">#</a></h2>
<p>done</p>
<h2 id="ex-2-5">Ex. 2-5<a hidden class="anchor" aria-hidden="true" href="#ex-2-5">#</a></h2>
<p>Create operation accounts for number of pointers filled. Insert operations are modified to allow up to $2t-1$ keys in case of internal node, and up to $(2t-1) + (2t) = 4t-1$ keys in case of leaf node. That, by basically modifying the if condition. Also, insertion in place of pointers happens by checking whether a leaf have $2t-1$ keys.</p>
<p>Note we haven&rsquo;t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.</p>
<pre tabindex="0"><code>B-TREE-CREATE(T)
  x = ALLOCATE-NODE()
  x.leaf = TRUE
  x.n = 0
  x.n&#39; = 0  // number of pointers to children filled
  DISK-WRITE(x)
  T.root = x
</code></pre><pre tabindex="0"><code>B-TREE-INSERT(T,k)
  r = T.root
  if (r.n == 2t-1 and not r.leaf) or (r.n == 4t-1 and r.leaf)  // different cases for internal and leaf nodes
    s = ALLOCATE-NODE()
	T.root = s
	s.leaf = FALSE
	s.n = 0
	s.c1 = r
	B-TREE-SPLIT-CHILD(s,1)
	B-TREE-INSERT-NONFULL(s,k)
  else
    B-TREE-INSERT-NONFULL(r,k)
</code></pre><pre tabindex="0"><code>B-TREE-INSERT-NONFULL(x,k)
  if x.leaf
    i = x.n + x.n&#39;  // sum of both keys and pointers

    while i &gt;= x.n + 1 and k &lt; x.c_(i-x.n)
	  x.c_(i-x.n+1) = x.c_(i-x.n)
	  i = i-1
    while i &gt;= 1 and k &lt; x.key_i
	  x.key_i+1 = x.key_i
	  i = i-1
	
	if i &gt;= x.n + 1
	  x.c_i+1 = k
	  x.n&#39; = x.n&#39; + 1
	else
	  x.key_i+1 = k
	  x.n = x.n + 1
	
	DISK-WRITE(x)

  else
    i = x.n
  
    while i&gt;=1 and k&lt;x.key_i
	  i = i-1
	i = i+1
	
	DISK-READ(x,c_i)
	
	if (x.c_i).n == 2t-1  // note this is an internal node
	  B-TREE-SPLIT-CHILD(x,i)
	  if k &gt; x.key_i
	    i = i+1
	
	B-TREE-INSERT-NONFULL(x.c_i, k)
</code></pre><h2 id="ex-3-2">Ex. 3-2<a hidden class="anchor" aria-hidden="true" href="#ex-3-2">#</a></h2>
<p>We implement the prescription described in p.500.</p>
<p>Note we haven&rsquo;t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.</p>
<pre tabindex="0"><code>B-TREE-DELETE(x, k)
  // check if k is in node x
  i = x.n
  while i&gt;=1 and x.key_i != k
    i = i-1

  // k is found
  if i&gt;=1

    // x is a leaf node
    if x.leaf
      key_i = NULL
      x.n = x.n - 1
      x.shiftKeysAndPointers()  // for brevity we ignore implementing this subroutine

    // x is an internal node
    else
	  y = x.c_i  // child preceeding k
	  z = x.c_i+1  // child following k
	  
	  // number of keys in child preceeding k is at least t
	  if y.n &gt;= t
	    k&#39; = y.lastKey()  // implementation is ignored
		B-TREE-DELETE(y, k&#39;)
        key_i = k = k&#39;
	
	  // number of keys in child following k is at least t
	  else if z.n &gt;= t
		// symmetrically replace k by k&#39;

      // number of keys in both child following and preceeding k, is less than t
      else 
        mergeInto([y, k, z])  // merge k and z into y. implementation is ignored
		x.c_i+1 = NULL
		B-TREE-DELETE(k)


  // k isn&#39;t found in x
  else
    // find k in children
	i = x.n
    while i &gt;= 1 and k &lt; x.key_i
	  i = i-1
    y = x.c_(i+1) // subtree y containing k

    // guarantee we descend to a node containing at least t keys
	if y.n == t-1
	
   	  if i+2 &lt;= x.n
	    z = x.c_(i+2)  // immediate forward sibling of y
	  if i &gt;= 1
	    r = x.c_(i)  // immediate preceeding sibling of y
	
	  // some sibling contains at least t keys
      if z and z.n &gt;= t
	    B-TREE-INSERT(y, key_i)
	    B-TREE-DELETE(key_i)
	    B-TREE-INSERT(x, z.firstKey())
	    B-TREE-DELETE(z, z.firstKey())
	    // don&#39;t get why a pointer from sibling should be moved to y
	  else if r and r.n &gt;= t
	    // symmetrically
	
	  // both immediate siblings have t-1 keys
	  else
	    mergeInto([r, key_i, y])
		x.c_(i+1) = NULL
        B-TREE-DELETE(x, key_i)
    
	// remove k from child y
    B-TREE-DELETE(y, k)  
</code></pre><hr>
<h2 id="problem-2-1">Problem 2-1<a hidden class="anchor" aria-hidden="true" href="#problem-2-1">#</a></h2>
<h3 id="a">a<a hidden class="anchor" aria-hidden="true" href="#a">#</a></h3>
<pre tabindex="0"><code>Match(S, P)
  n = S.length
  m = P.length
  
  M = []
  
  for i = 0..n-m+1
    flag = true
    for j = 0..m
	  if P[j] != S[i+j] flag = false
	if flag M.append(i)

  return M
</code></pre><h3 id="b">b<a hidden class="anchor" aria-hidden="true" href="#b">#</a></h3>
<p>Source string $S$ gets encoded as $S(x) = s_0x^0 + s_1x^1 + \dots + s_{n-1}x^{n-1}$, and pattern string $P$ as $P(x) = p_0x^{m-1} + p_1x^{m-2} + \dots + p_{m-1}x^0$, where $s_i$ and $p_i$ are, $1$ or $-1$, if characters $S[i]$ and $P[i]$, are $a$ or $b$, respectively. If $P[i] = *$, Then $p_i = 0$.</p>
<p>Observe $s_jp_k = 1$ if $S[j] = P[k]$, $s_jp_k = -1$ if $S[j] \neq P[k]$, and $s_jp_k = 0$ if $P[k] = \*$. Observe for resulting polynomial $(s \cdot p)(x) = r_0x^0 + r_1x^1 + \cdots + r_{m+n-2}x^{m+n-2}$, Coefficient $r_i = \sum_{j+k=i} s_jp_k$, Exactly matches the sum of multiplying $s_{i-m+1}$, $s_{i-m+2}$, $\dots$, $s_{i-1}$, $s_i$ with $p_0$, $p_1$, $\dots$, $p_{m-1}$, respectively, for $i = m-1, m, \dots, n-1$. If and only if, All corresponding alphabetic characters are equal, Then each contributes to the sum by $+1$. Asterik $*$ always contributes nothing to the sum. Therefore, if $k$ is the number of alphabetic character in $P$ (non asterik characters), Then $r_i = k$ if and only if $P$ matches substring $S[i-m+1..i]$.</p>
<p>Now we can set output $M$ to be the ordered list of $i$ such that $r_i = k$, Then subtract each entry by $m-1$, so that $i$ matches the position of the first character of the substring.</p>
<p>Note coefficients $r_0$, $r_1$, $\dots$, $r_{m-2}$ are irrelevant to our consideration, Since they do not consider a matching with the whole characters of pattern string $P$.</p>
<p>For the example, $S = ababbab$ and $P = ab*$,
\begin{align*}
S(x) &amp;= (1)x^0 + (-1)x^1 + (1)x^2 + (-1)x^3 + (-1)x^4 + (1)x^5 + (-1)x^6 \\
P(x) &amp;= (1)x^2 + (-1)x^1 + (0)x^0 \\
(S \cdot P)(x) &amp;= (-1)x^1 + (x)x^2 + (-2)x^3 + (2)x^4 + (1)x^7 + (-1)x^8 \\
M &amp;= [2, 4] \\
M &amp;= [2 - (m-1), 4 - (m-1)] = [2 - (3-1), 4 - (3-1)] \\
M &amp;= [0, 2]
\end{align*}</p>
<h3 id="c">c<a hidden class="anchor" aria-hidden="true" href="#c">#</a></h3>
<p>$\mathcal{O}(n \lg n)$, Since each operation of my algorithm requires at most a linear scan of complexity $\mathcal{O}(n)$</p>
<h3 id="d">d<a hidden class="anchor" aria-hidden="true" href="#d">#</a></h3>
<p>Exactly as $b$, but characters are encoded as</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>A</th>
          <th>C</th>
          <th>G</th>
          <th>T</th>
          <th>*</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>S</td>
          <td>1</td>
          <td>-1</td>
          <td>i</td>
          <td>-i</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>P</td>
          <td>1</td>
          <td>-1</td>
          <td>-i</td>
          <td>i</td>
          <td>0</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>Note if characters are matching, Then as before, each contributes to the sum by $+1$. In case of non-matching, A number less than $+1$ or an imaginary number is contributed.</p>
<h2 id="problem-2-2">Problem 2-2<a hidden class="anchor" aria-hidden="true" href="#problem-2-2">#</a></h2>
<h3 id="a-1">a<a hidden class="anchor" aria-hidden="true" href="#a-1">#</a></h3>
<p>Merge roots of $T_1$ and $T_2$, placing $k$ in between them. If new root&rsquo;s keys are greater than $2t-1$, Apply the standard operation of split and push median up.</p>
<p>Note roots of $T_1$ and $T_2$, each has at most $2t-1$ keys. When merging the new root is at most $(2t-1) + (2t-1) + 1 = 4t-1$. If we spllitted, We get a new root of key size exactly 1 and two childs, Each is of size at most $2t-1$.</p>
<h3 id="b-1">b<a hidden class="anchor" aria-hidden="true" href="#b-1">#</a></h3>
<p>Modify $T_1$ to decrease its height by one, Then apply the same procedure of <em>a</em>. That, by merging all of $T_1$&rsquo;s children into its root. In other words, $Merge(x.c_0, key_0, x.c_1, key_1, \dots, x.c_{n-1}, key_{n-1}, x.c_{n})$. Note new root of $T_1$ has at most $(2t-1) + (2t)(2t-1) = (2t+1)(2t-1) = 4t^2 - 1$ keys.</p>
<p>As in <em>a</em>, Merge $T_1$, $k$, and $T_2$. The new root has at most $(4t^2 - 1) + (2t-1) + 1 = (2t+2)(2t-1) + 1 = 4t^2 + 2t - 1$ keys. Hence we are going to split around $\mathcal{O}(\lg t^2) = \mathcal{O}(\lg t)$ times. Note that shall result in many one-key nodes. So, at most $\mathcal{O}(\lg t)$ merge of one-key nodes, to finally fix the tree. But since $t$ is assumed to be a constant, the total complexity is $\mathcal{O}(1)$.</p>
<h3 id="c-1">c<a hidden class="anchor" aria-hidden="true" href="#c-1">#</a></h3>
<p>The tree&rsquo;s height is increased only when the root has a full capacity of keys, and a new root is allocated.</p>
<pre tabindex="0"><code>B-TREE-INSERT(T,k)
r = T.root
if r.n == 2t-1
  s = ALLOCATE-NODE()
  T.root = s
  s.leaf = FALSE
  s.n = 0
  s.c1 = r
  s.height = r.height+1  // new root is of height +1 than the previous one
  B-TREE-SPLIT-CHILD(s,1)
  B-TREE-INSERT-NONFULL(s,k)
else
  B-TREE-INSERT-NONFULL(r,k)
</code></pre><p>Tree shrinks only when a merge happens with the root alongside its children. If we assumed the new root is updated to point to one of the children, Then no height variable needs to be updated.</p>
<h3 id="d-1">d<a hidden class="anchor" aria-hidden="true" href="#d-1">#</a></h3>
<p>Without the loss of generality assume $h_1 \geq h_2$. Then the procedure of $b$ is applied $h_1 - h_2$ times so $T_1$ and $T_2$ have the same weight. Then the procedure of <em>a</em> is applied to combine them. Each operation costs a constant time, Hence a complexity upperbounded by $\mathcal{O}((h_1 - h_2) + 1)$.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
