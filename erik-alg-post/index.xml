<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Erik's Algorithms on Mostafa Touny</title><link>https://mostafatouny.github.io/erik-alg-post/</link><description>Recent content in Erik's Algorithms on Mostafa Touny</description><generator>Hugo -- 0.136.5</generator><language>en-us</language><lastBuildDate>Sun, 06 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://mostafatouny.github.io/erik-alg-post/index.xml" rel="self" type="application/rss+xml"/><item><title>Problem Set 10</title><link>https://mostafatouny.github.io/erik-alg-post/pset10/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset10/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;p>Done&lt;/p>
&lt;h2 id="problems">Problems&lt;/h2>
&lt;h3 id="prob-1">Prob. 1&lt;/h3>
&lt;h4 id="a">a&lt;/h4>
&lt;p>The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.&lt;/p>
&lt;h4 id="b">b&lt;/h4>
&lt;p>A randomized algorithm identical to slide 18, satisfies all the problem&amp;rsquo;s requirements.&lt;/p>
&lt;p>The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r > 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.&lt;/p></description></item><item><title>Problem Set 09</title><link>https://mostafatouny.github.io/erik-alg-post/pset09/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset09/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;h3 id="ex-3">Ex. 3&lt;/h3>
&lt;h3 id="ex-4">Ex. 4&lt;/h3>
&lt;h2 id="problems">Problems&lt;/h2>
&lt;h3 id="prob-1">Prob. 1&lt;/h3>
&lt;h4 id="a">a&lt;/h4>
&lt;p>Consider &lt;/p>
$$\begin{aligned}
A &amp;= \{ 1, 2 \} \\\\
S &amp;= \{ 1, 50 \} \\\\
V &amp;= \{ 2, 50 \} \\\\
B &amp;= 50\end{aligned}$$&lt;p>
Observe the optimal solution is $C = 50$ while &lt;em>Alg1&lt;/em> is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.&lt;/p>
&lt;p>It is easy to see the number $50$ can be set arbitrarily larger, and
therefore we can reach the desired unbounded approximation ratio.&lt;/p></description></item><item><title>Problem Set 08</title><link>https://mostafatouny.github.io/erik-alg-post/pset08/</link><pubDate>Sun, 16 Jul 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset08/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;p>Done&lt;/p>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;p>\begin{aligned}
\text{Maximize } &amp;amp;d_y \\
\text{Subject to } &amp;amp;d_s = 0 \\
&amp;amp;d_t \leq d_s + w(s,t) \\
&amp;amp;d_y \leq d_s + w(s,y) \\
&amp;amp;d_y \leq d_t + w(t,y) \\
&amp;amp;d_x \leq d_t + w(t,x) \\
&amp;amp;d_t \leq d_y + w(y,t) \\
&amp;amp;d_x \leq d_y + w(y,x) \\
&amp;amp;d_z \leq d_y + w(y,z) \\
&amp;amp;d_z \leq d_x + w(x,z) \\
&amp;amp;d_x \leq d_z + w(z,x) \\
&amp;amp;d_s \leq d_z + w(z,s)
\end{aligned}&lt;/p></description></item><item><title>Problem Set 07</title><link>https://mostafatouny.github.io/erik-alg-post/pset07/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset07/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;p>Will do while solving the exercises.&lt;/p>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Definitions &amp;amp; Properties&lt;/th>
&lt;th>Extended&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Network&lt;/td>
&lt;td>Instructed below&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Source s&lt;/td>
&lt;td>Sources $\{s_1, s_2, \dots, s_{k_s}\}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Sink t&lt;/td>
&lt;td>Sinks $\{t_1, t_2, \dots, t_{k_t} \}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Capacity constraint&lt;/td>
&lt;td>Same&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Flow conservation&lt;/td>
&lt;td>V - {sources} - {sinks}&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>flow value $\|f\|$&lt;/td>
&lt;td>$\sum_{s_i} ( \sum_v f(s_i,v) - \sum_v f(v, s_i) )$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For brevity we illustrate the construction definition by the following
diagram.&lt;/p>
&lt;p>&lt;img loading="lazy" src="./0.jpg" alt="image" />
&lt;/p>
&lt;p>Observe $\sum_v f(s_{sup},v) = \sum_{s_i} \sum_v f(s_i, v)$ and $\sum_v f(v,s_{sup}) = \sum_{s_i} \sum_v f(v,s_i)$ which concludes our goal.&lt;/p></description></item><item><title>Problem Set 06</title><link>https://mostafatouny.github.io/erik-alg-post/pset06/</link><pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset06/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;p>skipped in hope of professionally read while solving the exercises, and
well-gain from lectures.&lt;/p>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;p>To definte shortest-path weight function $\delta$, which satisfies the triangle inequality, enabling the second property of $\overline{w}$.&lt;/p>
&lt;h3 id="ex-3">Ex. 3&lt;/h3>
&lt;p>For a cycle $c = v_0, v_1, \dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.&lt;/p>
&lt;p>Recall the facts&lt;/p>
&lt;ol>
&lt;li>$\overline{w}(u,v) \geq 0$&lt;/li>
&lt;li>$\overline{w}(u,v) = w(u,v) + h(u) - h(v)$&lt;/li>
&lt;li>$\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Lemma.&lt;/strong>   $\Sigma \overline{w}(v_i, v_{i+1}) = 0$&lt;br>
&lt;/p></description></item><item><title>Problem Set 05</title><link>https://mostafatouny.github.io/erik-alg-post/pset05/</link><pubDate>Sun, 07 May 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset05/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;p>Done.&lt;/p>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;p>&lt;strong>Definition.&lt;/strong>   &lt;em>coll&lt;/em>, $p[coll]$&lt;br>
We denote by &lt;em>coll&lt;/em> the collision event of $f(k_1) = f(k_2)$ for fixed
$k_1 \neq k_2$, and by $p[coll]$ the probability of that event
happening.&lt;/p>
&lt;p>&lt;strong>Definition.&lt;/strong>   $\{f_{coll-i,j}\}$&lt;br>
We denote all functions with a collision on $i, j \in U$ by
$\{f_{coll-i,j}\}$&lt;/p>
&lt;p>&lt;strong>Note.&lt;/strong>   It&amp;rsquo;s explicitly assumed\&lt;/p>
&lt;ol>
&lt;li>
&lt;p>\(i\) The given hash family $\mathcal{H}$ contains all possible
functions $f:U \rightarrow B$.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\(ii\) for any fixed $i$ and $j$,
$f(i), f(j) \in \{0, \dots, |B|-1\}$ are independently and randomly
assigned.&lt;/p></description></item><item><title>Problem Set 04</title><link>https://mostafatouny.github.io/erik-alg-post/pset04/</link><pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset04/</guid><description>&lt;p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$&lt;/p>
&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-1">Ex. 1&lt;/h3>
&lt;p>Done.&lt;/p>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;p>he amortized cost of n operations is upper-bounded by
\begin{align*}
&amp;amp;n + \sum_{i=1}^{\lfloor \lg n \rfloor} 2^i \\
&amp;amp;= n + \ddfrac{2(1-2^{\lfloor \lg n \rfloor})}{1-2} \\
&amp;amp;\leq n + \ddfrac{2(1-n)}{-1} \\
&amp;amp;= n - 2 + 2n \\
&amp;amp;= 3n - 2 \\
&amp;amp;= \mathcal{O}(n)
\end{align*}&lt;/p>
&lt;p>So the amortized cost of one operation is $\ddfrac{\mathcal{O}(n)}{n} = \mathcal{O}(1).$&lt;/p>
&lt;h3 id="ex-3">Ex. 3&lt;/h3>
&lt;p>We assign the following amortized costs:&lt;/p></description></item><item><title>Problem Set 03</title><link>https://mostafatouny.github.io/erik-alg-post/pset03/</link><pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset03/</guid><description>&lt;h2 id="exercises">Exercises&lt;/h2>
&lt;h3 id="ex-31">Ex. 3.1&lt;/h3>
&lt;p>Done.&lt;/p>
&lt;h3 id="ex-32">Ex. 3.2&lt;/h3>
&lt;p>Skipped; I don&amp;rsquo;t understand the problem.&lt;/p>
&lt;h3 id="ex-2">Ex. 2&lt;/h3>
&lt;p>Skipped; I don&amp;rsquo;t understand the problem.&lt;/p>
&lt;h2 id="problems">Problems&lt;/h2>
&lt;h3 id="prob-31">Prob. 3.1&lt;/h3>
&lt;p>psuedo-code changes; compare new complexity with old one&lt;/p>
&lt;h4 id="a">a&lt;/h4>
&lt;p>&lt;strong>Psuedo-code.&lt;/strong> No Changes at all. Note the sequence $2^9 \rightarrow 2^3 \rightarrow 2^1$, up to the base case of $u = 2$ as before, starting with total data of size $2^9 = 512$.&lt;/p>
&lt;p>&lt;strong>Complexity.&lt;/strong> Similarly $\mathcal{O}(\lg \lg u)$. We follow the same reasoning on the master method but on the case of a cluster size $u^{1/3}$. We gain $\lg_b a = \lg_3 1 = 0$, or more accurately $\lg_b a = \lg_{4/3} 1 = 0$, whereby $\lceil m/3 \rceil \leq 3m/4$. Thus, Reaching exactly the same complexity.&lt;/p></description></item><item><title>Problem Set 02</title><link>https://mostafatouny.github.io/erik-alg-post/pset02/</link><pubDate>Sun, 26 Feb 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset02/</guid><description>&lt;h2 id="ex-2-1">Ex. 2-1&lt;/h2>
&lt;p>done&lt;/p>
&lt;h2 id="ex-2-2">Ex. 2-2&lt;/h2>
&lt;p>For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.&lt;/p>
&lt;p>&lt;strong>Double-degree form&lt;/strong>&lt;/p>
&lt;p>$A(x) = -10 + x + 0x^2 + 0x^3$&lt;/p>
&lt;p>$B(x) = 3 - 6x + 0x^2 + 0x^3$&lt;/p>
&lt;p>&lt;strong>Computing A(x) on sample&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Recursive-FFT(-10, 1, 0, 0)
n = 4
w_4 = e^{2 pi i / 4}
w = w_4^0 = 1
a[even] = (-10, 0)
a[odd] = (1, 0)
y[even] = Recursive-FFT(-10, 0) = (-10, -10)
y[odd] = Recursive-FFT(1, 0) = (1, 1)
for k=0 to 1
k=0
y_0 = (-10) + (1)(1) = -9
y_2 = (-10) - (1)(1) = -11
w = w_4^1
k=1
y_1 = (-10) + (e^{1 2 pi i / 4})(1) = -10+i
y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i
w = w_4^2
return (-9, -10+i, -11, -10-i)
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>Recursive-FFT(-10, 0)
n = 2
w_2 = e^{2 pi i / 2}
w = w_2^0 = 1
a[even] = (-10)
a[odd] = (0)
y[even] = Recursive-FFT(-10) = (-10) // base case
y[odd] = Recursive-FFT(0) = (0)
for k=0 to 0
k=0
y_0 = (-10) + w (0) = -10
y_1 = (-10) - w (0) = -10
w = w_2^1
return (-10, -10)
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>Recursive-FFT(1, 0)
n = 2
w_2 = e^{2 pi i / 2}
w = w_2^0 = 1
a[even] = (1)
a[odd] = (0)
y[even] = Recursive-FFT(1) = (1) // base case
y[odd] = Recursive-FFT(0) = (0)
for k=0 to 0
k=0
y_0 = 1 + w(0) = 1
y_1 = 1 - w(0) = 1
w = w_2^1
return (1, 1)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Computing B(x) on sample&lt;/strong>&lt;/p></description></item><item><title>Problem Set 01</title><link>https://mostafatouny.github.io/erik-alg-post/pset01/</link><pubDate>Sun, 05 Feb 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/erik-alg-post/pset01/</guid><description>&lt;h2 id="problem-1">Problem 1&lt;/h2>
&lt;h3 id="a">a&lt;/h3>
&lt;p>Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges $\{v_1,v_2\}, \{v_2, v_3\}$.&lt;/p>
&lt;p>The optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.&lt;/p>
&lt;h3 id="b">b&lt;/h3>
&lt;p>Since the graph is given to be acyclic, Each neighbour of the graph&amp;rsquo;s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees.&lt;/p></description></item></channel></rss>