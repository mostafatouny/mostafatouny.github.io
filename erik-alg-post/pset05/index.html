<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 05 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done.
Ex. 2
Definition.   coll, $p[coll]$
We denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed
$k_1 \neq k_2$, and by $p[coll]$ the probability of that event
happening.
Definition.   $\{f_{coll-i,j}\}$
We denote all functions with a collision on $i, j \in U$ by
$\{f_{coll-i,j}\}$
Note.   It&rsquo;s explicitly assumed\


\(i\) The given hash family $\mathcal{H}$ contains all possible
functions $f:U \rightarrow B$.


\(ii\) for any fixed $i$ and $j$,
$f(i), f(j) \in \{0, \dots, |B|-1\}$ are independently and randomly
assigned."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/erik-alg-post/pset05/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/erik-alg-post/pset05/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 05"><meta property="og:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done.
Ex. 2
Definition.   coll, $p[coll]$
We denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed
$k_1 \neq k_2$, and by $p[coll]$ the probability of that event
happening.
Definition.   $\{f_{coll-i,j}\}$
We denote all functions with a collision on $i, j \in U$ by
$\{f_{coll-i,j}\}$
Note.   It&rsquo;s explicitly assumed\


\(i\) The given hash family $\mathcal{H}$ contains all possible
functions $f:U \rightarrow B$.


\(ii\) for any fixed $i$ and $j$,
$f(i), f(j) \in \{0, \dots, |B|-1\}$ are independently and randomly
assigned."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset05/"><meta property="article:section" content="erik-alg-post"><meta property="article:published_time" content="2023-05-07T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-07T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 05"><meta name=twitter:description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done.
Ex. 2
Definition.   coll, $p[coll]$
We denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed
$k_1 \neq k_2$, and by $p[coll]$ the probability of that event
happening.
Definition.   $\{f_{coll-i,j}\}$
We denote all functions with a collision on $i, j \in U$ by
$\{f_{coll-i,j}\}$
Note.   It&rsquo;s explicitly assumed\


\(i\) The given hash family $\mathcal{H}$ contains all possible
functions $f:U \rightarrow B$.


\(ii\) for any fixed $i$ and $j$,
$f(i), f(j) \in \{0, \dots, |B|-1\}$ are independently and randomly
assigned."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Erik's Algorithms","item":"https://mostafatouny.github.io/erik-alg-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 05","item":"https://mostafatouny.github.io/erik-alg-post/pset05/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 05","name":"Problem Set 05","description":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 Definition. coll, $p[coll]$\nWe denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed $k_1 \\neq k_2$, and by $p[coll]$ the probability of that event happening.\nDefinition. $\\{f_{coll-i,j}\\}$\nWe denote all functions with a collision on $i, j \\in U$ by $\\{f_{coll-i,j}\\}$\nNote. It\u0026rsquo;s explicitly assumed\\\n\\(i\\) The given hash family $\\mathcal{H}$ contains all possible functions $f:U \\rightarrow B$.\n\\(ii\\) for any fixed $i$ and $j$, $f(i), f(j) \\in \\{0, \\dots, |B|-1\\}$ are independently and randomly assigned.\n","keywords":[],"articleBody":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 Definition. coll, $p[coll]$\nWe denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed $k_1 \\neq k_2$, and by $p[coll]$ the probability of that event happening.\nDefinition. $\\{f_{coll-i,j}\\}$\nWe denote all functions with a collision on $i, j \\in U$ by $\\{f_{coll-i,j}\\}$\nNote. It’s explicitly assumed\\\n\\(i\\) The given hash family $\\mathcal{H}$ contains all possible functions $f:U \\rightarrow B$.\n\\(ii\\) for any fixed $i$ and $j$, $f(i), f(j) \\in \\{0, \\dots, |B|-1\\}$ are independently and randomly assigned.\nWe are not aware whether these properties are part of a hash’s family definition.\nLemma. For a family of functions $\\mathcal{H}$ whose functions are defined on $f:U \\rightarrow B$, $p[coll] = \\frac{\\displaystyle{1}}{\\displaystyle{|B|}}$\nFor a fixed $k \\in B$, $|\\{f_{coll-i,j} | f(i)=f(j)=k \\}| = |B|^{|U|-2}$ To see why, Think of $f(k_i)$ and $f(k_j)$ as a fixed determined values; As a deferred choice, how many choices we have for $f$, for the remaining of $|U|-2$ elements?\nConsidering all $x_i \\in \\{0, \\dots, |B|-1\\}$ for $f(k_i) = x_i = f(k_j)$, $|\\{f_{coll-i,j}\\}| = |B|^{|U|-2} + \\dots + |B|^{|U|-2} = |B| \\cdot |B|^{|U|-2} = |B|^{|U|-1}$.\nFinally, $\\frac{\\displaystyle{|\\{f_{coll-i,j}\\}|}}{\\displaystyle{|\\mathcal{H}|}} = \\frac{\\displaystyle{|B|^{|U|-1}}}{\\displaystyle{|B|^{|U|}}} = \\frac{\\displaystyle{1}}{\\displaystyle{|B|}}$. The result is concluded, recalling a function is drawn randomly from $\\mathcal{H}$.\nCorollarly. If $p[coll] \\leq \\epsilon$, Then $\\epsilon \\geq \\frac{\\displaystyle{1}}{\\displaystyle{|B|}}$.\nTheorem. If $p[coll] \\leq \\epsilon$, Then $\\epsilon \\geq \\frac{\\displaystyle{1}}{\\displaystyle{|B|}} - \\frac{\\displaystyle{1}}{\\displaystyle{U}}$. Note $\\epsilon \\geq \\frac{\\displaystyle{1}}{\\displaystyle{|B|}} - \\frac{\\displaystyle{1}}{\\displaystyle{U}}$ is equivalent to $|B| |U| \\epsilon + |B| \\geq |U|$ by trivial algebraic operations. It immediately follows from lemma 4, $|B| |U| \\epsilon + |B| \\geq |B| |U| \\frac{\\displaystyle{1}}{\\displaystyle{|B|}} = |U|+|B| \\geq |U|$, since $|B| \u003e 0$.\nEx. 3 Done.\nEx. 4 Fact. Trees’ Keys\nKeys of the tree are keyed on low endpoints. i.e nodes on the left subtree have low endpoints less than the root’s low endpoint and nodes on the right subtree have greater low endpoints.\nDefinition. Goodness\nBy an optimal-interval we mean an overlapping one with the lowest low endpoint. We say some interval is better when its low endpoint is strictly lower.\nLemma. No better-interval on the right subtree.\nIf any search algorithm terminated upon finding an overlapping interval $x$, Then for any other overlapping interval on the right subtree, Its low endpoint is going to be at least equal to $x$’s low endpoint. That due to Fact 1.\nObservation. Possible better-intervals on the left subtree.\nFor node $x$ whose interval overlaps with the queried interval $i$, The possible existince of a better-interval on the left subtree is justified by verifying $x.left.max$ to be at least $i.low$, and Fact 1.\nCorollary. If $x.left.max$ is less than queried $i.low$, Then the found overlapping interval in $x$ is the optimal.\nTinkering Search Algorithm. The previous discussion suggests a simple modification to solve our problem. The algorithm maintains a variable $bestInterval$, Updating it whenever a better overlapping interval is found. If the algorithm found an interval, and $x.left.max$ is less than $i.low$, It terminates. If $x.left.max$ were at least $i.low$, It steps to left subtree.\nINTERVAL-SEARCH(T, i) bestIntervalNode = nil x = T.root while x != T.nil if i overlaps with x.int and x.int is better than bestIntervalNode bestIntervalNode = x if x.left != T:nil and x.left.max \u003e= i.low x = x.left else if bestIntervalNode == nil x = x.right else return bestIntervalNode return bestIntervalNode Ex. 5 Done.\nEx. 6 In Memoized-Cut-Rod, Initalize a new binary array $c[0..n-1]$ where $c[i]=1$ if there’s a cut at the ith possible cut position. In Memoized-Cut-Rod-Aux, While computing the maximum $q$ in $i$’s loop, store $i_0$ value which corresponds to the maximum $q$. Then set $c[i_0]=1$.\nEx. 7 Postponed.\nEx. 8 Definition. Less-order Sequence\nA sequence A is less-order than sequence B if A is less in terms of the lexicographical order. For example, A C B is less-order than A D A.\nRemark. Misleading Equal Character\nConsider sequences A = 1 9 2 5 1 3 4 and B = 1 9 2 6 1 3 4. On A2 = 1 9 and B2 = 1 9, We have a subsequence 1 9. But since 9 is a huge number we can’t append subsequence 2 3 4. In fact the optimal subsequence of A and B is 1 2 3 4. Our algorithm must prefer less-order subsequences as they enable better chances of a longer subsequence.\nApproach. Same but tinkered\nFollowing exactly the same formulation and solution mentioned in CLRS but with a simple tinkering:\nA new character appended to a subsequence must be monotonically increasing. Otherwise the subsequence is passed as it is without appending the new character. if two subsequences collided in the same memoization-table entry, the less-order one is preferred. Example. A = 1 9 2 5 1 3 4\nB = 1 9 2 6 1 3 4\nEntry c\\[2,2\\] prefers 1 2 over 1 9. Entry c\\[4,4\\] does not append 1 conforming to the monotonic increase condition. Note. We rely on our intuition without rigorously proving the correctness of our solution.\nProblems Prob. 1 a We donte with high probability by w.h.p. As instructed in lectures, Proofs here are identical to them but on the case of nodes m rather than all n nodes. We follow the same assumptions. Namely, Total number of moves is, Moves until all head tosses (upward moves) are consumed.\nFinger-Search Algorithm\nWe define:\ncurN, As currently pointed node N.r, As the right node of node N N.d, As the downward node of node N N.u, As the upward node of node N N.l, As the left node of node N N.key, As the key of node N Finger-Search(x,k) curN = x while curN.key != k: if (curN.u != NULL) AND (curN.u.r.leftCount + counter \u003c= k), then curN = curN.u else if curN.r.key \u003c= k, then curN = curN.r else curN = curN.d Recall we are assuming a successful search, so the case of finding a key greater than k while we are in level-0 is impossible. So is the case of reaching +inf. So we omit those validations.\nLemma. The height, i.e maximum node’s upward levels, is bounded by $c\\lg m$ w.h.p\n$$\\begin{aligned} Pr[\\text{no node's height} \\leq c\\lg m] \u0026= 1 - Pr[\\text{some node's height} \u003e c\\lg m] \\\\\\\\ Pr[\\text{some node's height} \u003e c\\lg m] \u0026\\leq m \\cdot Pr[\\text{node x height} \u003e c\\lg m] \\textit{ (union bound)} \\\\\\\\ \u0026\\leq m \\cdot \\left (\\frac{\\displaystyle{1}}{\\displaystyle{2}} \\right )^{c \\lg m} = m \\cdot (2^{\\lg m})^{-c} = m \\cdot m^{-c} = \\frac{\\displaystyle{1}}{\\displaystyle{m^{c-1}}} \\\\\\\\ \u0026= \\frac{\\displaystyle{1}}{\\displaystyle{m^\\alpha}}, \\text{where} \\; \\alpha=c-1 \\\\\\\\ Pr[\\text{no node's height} \\leq c\\lg m] \u0026= 1 - \\frac{\\displaystyle{1}}{\\displaystyle{m^\\alpha}} \\end{aligned}$$Lemma. For every height $c\\lg m$ there is a total number of moves $d\\lg m$ such that $c\\lg m$ head tosses (upward moves) appears within the $d\\lg m$ moves w.h.p\nClearly, If we knew the maximum height of any node is $c\\lg m$, then the height of given node $x$ is upper-bounded by it.\nAs given in the lecture, We use Chernoff’s bound as our hammer: $$Pr[Y \\geq E[Y] + r] \\leq e^{\\frac{\\displaystyle{-2r^2}}{\\displaystyle{m}}}$$Observe among $d\\lg m$ total tosses, The following are equivalent:\n$\\geq c\\lg m$ heads w.h.p. $\u003c c\\lg m$ heads is bounded. $\\geq d \\lg m - c \\lg m$ tails is bounded Let $Y$ denote the number of tails. Note $Ex[Y] = \\frac{\\displaystyle{d\\lg m}}{\\displaystyle{2}}$ by linearity of expectation, and set $r = (d/2 - c) \\lg m$. Thus, $$ \\begin{aligned} Pr[Y \\geq \\frac{\\displaystyle{d\\lg m}}{\\displaystyle{2}} + (d/2 - c) \\lg m] \u0026\\leq e^{\\frac{\\displaystyle{-2(d/2 - c)^2 \\lg^2 m}}{\\displaystyle{d\\lg m}}}\\\\\\\\ Pr[Y \\geq (d-c) \\lg m] \u0026\\leq e^{-9/4 \\cdot c \\cdot \\lg m}, \\text{Setting d=8c}\\\\\\\\ \u0026\\leq (2^{\\lg m})^{-c}, \\text{As $e\u003e2$ and $9/4\u003e1$}\\\\\\\\ \u0026= \\frac{\\displaystyle{1}}{\\displaystyle{m^c}} \\end{aligned} $$ Therefore Pr\n\\[$\\geq c\\lg m$ heads\\] = 1 - $\\frac{\\displaystyle{1}}{\\displaystyle{m^c}}$. QED\nb We begin by augmenting node with data additional to mentioned ones in a. Namely, n.leftCount which denote the number of nodes additional to node n.l upto current n. Note the number considers all nodes in level-0.\nFor Search, Clearly augmenting new data on nodes do not influence the number or order of nodes in the skip list. So nothings needs to be done to prove the complexity is maintained.\nFor Insert and Delete, n.leftCount of some nodes must be updated. Those nodes are exactly characterized by the same line of reasoning mentioned in the lecture and in a. If Search is getting from a top-left node to some level-0 node, Then Reversed-Search is getting from a level-0 node to some top-right node. Nodes along that path are exactly the ones which need update. The proofs are identical to a. For the sake of brevity we omit them here and invite the reader to observe the following diagrams as a convincing evidence.\nc Compute-Rank(x) curN = x counter = 0 while curN != -inf: if curN.u != NULL, then curN = curN.u else counter = counter + curN.leftCount; curN = curN.l return counter Rank-Search(x,r) counter = Compute-Rank(curN) while counter != r: if (curN.u != NULL) AND (curN.u.r.leftCount + counter \u003c= k), then curN = curN.u else if curN.r.leftCount + counter \u003c= k, then curN = curN.r else curN = curN.d return curN Again, As we assume a succesful search we do not check the cases of +inf and stepping downward while being in level-0.\nAgain, Proofs are identical to a and they are omitted for brevity. `\nProb. 2 For the sake of brevity we only show the optimal-substructure and memoization-table, Whereby the algorithm should be clear enough.\na Optimal Substructure $$ maxSeq(, m) = max \\set{ \\begin{array}{lr} maxSeq(, m-1) + p_n,\\\\\\\\ maxSeq(, m) \\end{array} } $$Memoization Table. ith column denote the consideration of prizes $p_1, \\dots, p_i$, and ith row denote exactly i prizes.\nSince prizes’ values are non-negative, table\n\\[m,n\\] is the answer.\nComplexity. Both time and space complexity are $\\mathcal{O}(nm)$\nb Remark. Observe the given sequence $S$ and the optimal-subsequence $OptS$ can both be divided into two segments, $S1, S2$ and $OptS1, OptS2$, where $OptS1$ is a subsequence of $S1$ and $OptS2$ is a subsequence of $S2$.\nBut neither do we know where exactly $S$ is divided nor how many prizes are devoted to blues and reds. The solution is basically to brute-force all possible cases and apply (a) to solve a single case.\nOptimal Substructure\n\\begin{align} maxSeq(, m) = max_{0 \\leq i \\leq n \\wedge 0 \\leq j \\leq m} \\set{ maxSeq(, j) \\cdot maxSeq(, m-j) } \\end{align}\nWhere ‘$\\cdot$’ denotes a concatenation.\nComplexity. Time is $nm \\cdot \\mathcal{O}(nm) = \\mathcal{O}(n^2m^2)$. Space is the same as (a).\nc Remark\nWe can think of this problem as a generalization of (b) where the precedence of Reds over Blues is equivalent to prizes $p_i$ being all less than some prize $p_0$. This is the crux of our solution.\nWe introduce a trick to colour prizes. Pick-up some arbitrary prize $p_0$ and colour and all prizes $p_i \u003c p_0$ blue and all prizes $p_i \\geq p_0$ red. Call it prizes-colouring.\nRecursively apply prizes-colouring and (b) on the given sequence $S$. Note the base case is the same as (b), where a sequence consists only of prizes of an equal value.\nThe justification is clear since we are brute-forcing all possible cases.\nComplexity\nOn average we expect the recursion to count $\\log n$ iterations. The worst case is $n$. So we have time $n \\cdot \\mathcal{O}(n^2 m^2) = \\mathcal{O}(n^3m^2)$, and space same as (a).\nd ","wordCount":"1880","inLanguage":"en","datePublished":"2023-05-07T00:00:00Z","dateModified":"2023-05-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/erik-alg-post/pset05/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 05</h1><div class=post-meta><span title='2023-05-07 00:00:00 +0000 UTC'>May 7, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exercises aria-label=Exercises>Exercises</a><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a></li><li><a href=#ex-2 aria-label="Ex. 2">Ex. 2</a></li><li><a href=#ex-3 aria-label="Ex. 3">Ex. 3</a></li><li><a href=#ex-4 aria-label="Ex. 4">Ex. 4</a></li><li><a href=#ex-5 aria-label="Ex. 5">Ex. 5</a></li><li><a href=#ex-6 aria-label="Ex. 6">Ex. 6</a></li><li><a href=#ex-7 aria-label="Ex. 7">Ex. 7</a></li><li><a href=#ex-8 aria-label="Ex. 8">Ex. 8</a></li></ul></li><li><a href=#problems aria-label=Problems>Problems</a><ul><li><a href=#prob-1 aria-label="Prob. 1">Prob. 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li></ul></li><li><a href=#prob-2 aria-label="Prob. 2">Prob. 2</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li><li><a href=#c-1 aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p><h2 id=exercises>Exercises<a hidden class=anchor aria-hidden=true href=#exercises>#</a></h2><h3 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h3><p>Done.</p><h3 id=ex-2>Ex. 2<a hidden class=anchor aria-hidden=true href=#ex-2>#</a></h3><p><strong>Definition.</strong>   <em>coll</em>, $p[coll]$<br>We denote by <em>coll</em> the collision event of $f(k_1) = f(k_2)$ for fixed
$k_1 \neq k_2$, and by $p[coll]$ the probability of that event
happening.</p><p><strong>Definition.</strong>   $\{f_{coll-i,j}\}$<br>We denote all functions with a collision on $i, j \in U$ by
$\{f_{coll-i,j}\}$</p><p><strong>Note.</strong>   It&rsquo;s explicitly assumed\</p><ol><li><p>\(i\) The given hash family $\mathcal{H}$ contains all possible
functions $f:U \rightarrow B$.</p></li><li><p>\(ii\) for any fixed $i$ and $j$,
$f(i), f(j) \in \{0, \dots, |B|-1\}$ are independently and randomly
assigned.</p></li></ol><p>We are not aware whether these properties are part of a hash&rsquo;s family
definition.</p><p><strong>Lemma.</strong>   For a family of functions $\mathcal{H}$ whose functions are
defined on $f:U \rightarrow B$,
$p[coll] = \frac{\displaystyle{1}}{\displaystyle{|B|}}$<br>For a fixed $k \in B$, $|\{f_{coll-i,j} | f(i)=f(j)=k \}| = |B|^{|U|-2}$
To see why, Think of $f(k_i)$ and $f(k_j)$ as a fixed determined values;
As a deferred choice, how many choices we have for $f$, for the
remaining of $|U|-2$ elements?</p><p>Considering all $x_i \in \{0, \dots, |B|-1\}$ for
$f(k_i) = x_i = f(k_j)$,
$|\{f_{coll-i,j}\}| = |B|^{|U|-2} + \dots + |B|^{|U|-2} = |B| \cdot |B|^{|U|-2} = |B|^{|U|-1}$.</p><p>Finally,
$\frac{\displaystyle{|\{f_{coll-i,j}\}|}}{\displaystyle{|\mathcal{H}|}} = \frac{\displaystyle{|B|^{|U|-1}}}{\displaystyle{|B|^{|U|}}} = \frac{\displaystyle{1}}{\displaystyle{|B|}}$.
The result is concluded, recalling a function is drawn randomly from
$\mathcal{H}$.</p><p><strong>Corollarly.</strong>   If $p[coll] \leq \epsilon$, Then
$\epsilon \geq \frac{\displaystyle{1}}{\displaystyle{|B|}}$.</p><p><strong>Theorem.</strong>   If $p[coll] \leq \epsilon$, Then
$\epsilon \geq \frac{\displaystyle{1}}{\displaystyle{|B|}} - \frac{\displaystyle{1}}{\displaystyle{U}}$.
Note
$\epsilon \geq \frac{\displaystyle{1}}{\displaystyle{|B|}} - \frac{\displaystyle{1}}{\displaystyle{U}}$
is equivalent to $|B| |U| \epsilon + |B| \geq |U|$ by trivial algebraic
operations. It immediately follows from <em>lemma 4</em>,
$|B| |U| \epsilon + |B| \geq |B| |U| \frac{\displaystyle{1}}{\displaystyle{|B|}} = |U|+|B| \geq |U|$,
since $|B| > 0$.</p><h3 id=ex-3>Ex. 3<a hidden class=anchor aria-hidden=true href=#ex-3>#</a></h3><p>Done.</p><h3 id=ex-4>Ex. 4<a hidden class=anchor aria-hidden=true href=#ex-4>#</a></h3><p><strong>Fact.</strong>   Trees&rsquo; Keys<br>Keys of the tree are keyed on low endpoints. i.e nodes on the left
subtree have low endpoints less than the root&rsquo;s low endpoint and nodes
on the right subtree have greater low endpoints.</p><p><strong>Definition.</strong>   Goodness<br>By an <em>optimal-interval</em> we mean an overlapping one with the lowest low
endpoint. We say some interval is <em>better</em> when its low endpoint is
strictly lower.</p><p><strong>Lemma.</strong>   No <em>better-interval</em> on the right subtree.<br>If any search algorithm terminated upon finding an overlapping interval
$x$, Then for any other overlapping interval on the right subtree, Its
low endpoint is going to be at least equal to $x$&rsquo;s low endpoint. That
due to <em>Fact 1</em>.</p><p><strong>Observation.</strong>   Possible <em>better-intervals</em> on the left subtree.<br>For node $x$ whose interval overlaps with the queried interval $i$, The
possible existince of a <em>better-interval</em> on the left subtree is
justified by verifying $x.left.max$ to be at least $i.low$, and <em>Fact
1</em>.</p><p><strong>Corollary.</strong>   If $x.left.max$ is less than queried $i.low$, Then the found overlapping interval in $x$ is the <em>optimal</em>.</p><p><strong>Tinkering Search Algorithm.</strong> The previous discussion suggests a
simple modification to solve our problem. The algorithm maintains a
variable $bestInterval$, Updating it whenever a better overlapping
interval is found. If the algorithm found an interval, and $x.left.max$
is less than $i.low$, It terminates. If $x.left.max$ were at least
$i.low$, It steps to left subtree.</p><pre tabindex=0><code>INTERVAL-SEARCH(T, i)
  bestIntervalNode = nil
  x = T.root

  while x != T.nil
    if i overlaps with x.int and x.int is better than bestIntervalNode
      bestIntervalNode = x

    if x.left != T:nil and x.left.max &gt;= i.low
      x = x.left
    else
      if bestIntervalNode == nil
        x = x.right
      else return bestIntervalNode
  return bestIntervalNode
</code></pre><h3 id=ex-5>Ex. 5<a hidden class=anchor aria-hidden=true href=#ex-5>#</a></h3><p>Done.</p><h3 id=ex-6>Ex. 6<a hidden class=anchor aria-hidden=true href=#ex-6>#</a></h3><p>In <em>Memoized-Cut-Rod</em>, Initalize a new binary array $c[0..n-1]$ where
$c[i]=1$ if there&rsquo;s a cut at the ith possible cut position. In
<em>Memoized-Cut-Rod-Aux</em>, While computing the maximum $q$ in $i$&rsquo;s loop,
store $i_0$ value which corresponds to the maximum $q$. Then set
$c[i_0]=1$.</p><h3 id=ex-7>Ex. 7<a hidden class=anchor aria-hidden=true href=#ex-7>#</a></h3><p>Postponed.</p><h3 id=ex-8>Ex. 8<a hidden class=anchor aria-hidden=true href=#ex-8>#</a></h3><p><strong>Definition.</strong>   Less-order Sequence<br>A sequence <em>A</em> is <em>less-order</em> than sequence <em>B</em> if <em>A</em> is less in terms
of the lexicographical order. For example, <em>A C B</em> is <em>less-order</em> than
<em>A D A</em>.</p><p><strong>Remark.</strong>   Misleading Equal Character<br>Consider sequences <em>A = 1 9 2 5 1 3 4</em> and <em>B = 1 9 2 6 1 3 4</em>. On <em>A2 =
1 9</em> and <em>B2 = 1 9</em>, We have a subsequence <em>1 9</em>. But since <em>9</em> is a
huge number we can&rsquo;t append subsequence <em>2 3 4</em>. In fact the optimal
subsequence of <em>A</em> and <em>B</em> is <em>1 2 3 4</em>. Our algorithm must prefer
<em>less-order</em> subsequences as they enable better chances of a longer
subsequence.</p><p><strong>Approach.</strong>   Same but tinkered<br>Following exactly the same formulation and solution mentioned in CLRS
but with a simple tinkering:</p><ul><li>A new character appended to a subsequence must be monotonically
increasing. Otherwise the subsequence is passed as it is without
appending the new character.</li><li>if two subsequences collided in the same memoization-table entry,
the <em>less-order</em> one is preferred.</li></ul><p><strong>Example.</strong>  <br><em>A = 1 9 2 5 1 3 4</em><br><em>B = 1 9 2 6 1 3 4</em></p><p><img loading=lazy src=table.jpg alt=image></p><ul><li>Entry <em>c\[2,2\]</em> prefers <em>1 2</em> over <em>1 9</em>.</li><li>Entry <em>c\[4,4\]</em> does not append <em>1</em> conforming to the monotonic
increase condition.</li></ul><p><strong>Note.</strong>  <br>We rely on our intuition without rigorously proving the correctness of
our solution.</p><h2 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h2><h3 id=prob-1>Prob. 1<a hidden class=anchor aria-hidden=true href=#prob-1>#</a></h3><h4 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h4><p>We donte <em>with high probability</em> by <em>w.h.p</em>. As instructed in lectures,
Proofs here are identical to them but on the case of nodes m rather than
all n nodes. We follow the same assumptions. Namely, Total number of
moves is, Moves until all head tosses (upward moves) are consumed.</p><p><strong>Finger-Search Algorithm</strong></p><p>We define:</p><ul><li><code>curN</code>, As currently pointed node</li><li><code>N.r</code>, As the right node of node <code>N</code></li><li><code>N.d</code>, As the downward node of node <code>N</code></li><li><code>N.u</code>, As the upward node of node <code>N</code></li><li><code>N.l</code>, As the left node of node <code>N</code></li><li><code>N.key</code>, As the key of node <code>N</code></li></ul><pre tabindex=0><code>Finger-Search(x,k)
  curN = x
  while curN.key != k:
    if (curN.u != NULL) AND (curN.u.r.leftCount + counter &lt;= k), then curN = curN.u
    else if curN.r.key &lt;= k, then curN = curN.r
    else curN = curN.d
</code></pre><p>Recall we are assuming a successful search, so the case of finding a key
greater than <em>k</em> while we are in <em>level-0</em> is impossible. So is the case
of reaching <em>+inf</em>. So we omit those validations.</p><p><strong>Lemma.</strong>   The height, i.e maximum node&rsquo;s upward levels, is bounded by
$c\lg m$ <em>w.h.p</em><br></p>$$\begin{aligned}
Pr[\text{no node's height} \leq c\lg m] &= 1 - Pr[\text{some node's height} > c\lg m] \\\\
Pr[\text{some node's height} > c\lg m] &\leq m \cdot Pr[\text{node x height} > c\lg m] \textit{ (union bound)} \\\\
&\leq m \cdot \left (\frac{\displaystyle{1}}{\displaystyle{2}} \right )^{c \lg m} = m \cdot (2^{\lg m})^{-c} = m \cdot m^{-c} = \frac{\displaystyle{1}}{\displaystyle{m^{c-1}}} \\\\
&= \frac{\displaystyle{1}}{\displaystyle{m^\alpha}}, \text{where} \; \alpha=c-1 \\\\
Pr[\text{no node's height} \leq c\lg m] &= 1 - \frac{\displaystyle{1}}{\displaystyle{m^\alpha}} \end{aligned}$$<p><strong>Lemma.</strong>   For every height $c\lg m$ there is a total number of moves
$d\lg m$ such that $c\lg m$ head tosses (upward moves) appears within
the $d\lg m$ moves <em>w.h.p</em><br>Clearly, If we knew the maximum height of any node is $c\lg m$, then the
height of given node $x$ is upper-bounded by it.</p><p>As given in the lecture, We use <em>Chernoff&rsquo;s bound</em> as our hammer:</p>$$Pr[Y \geq E[Y] + r] \leq e^{\frac{\displaystyle{-2r^2}}{\displaystyle{m}}}$$<p>Observe among $d\lg m$ total tosses, The following are equivalent:</p><ul><li>$\geq c\lg m$ heads <em>w.h.p</em>.</li><li>$< c\lg m$ heads is bounded.</li><li>$\geq d \lg m - c \lg m$ tails is bounded</li></ul><p>Let $Y$ denote the number of tails. Note
$Ex[Y] = \frac{\displaystyle{d\lg m}}{\displaystyle{2}}$ by <em>linearity of expectation</em>, and set $r = (d/2 - c) \lg m$. Thus,</p>$$
\begin{aligned}
Pr[Y \geq \frac{\displaystyle{d\lg m}}{\displaystyle{2}} + (d/2 - c) \lg m] &\leq e^{\frac{\displaystyle{-2(d/2 - c)^2 \lg^2 m}}{\displaystyle{d\lg m}}}\\\\
Pr[Y \geq (d-c) \lg m] &\leq e^{-9/4 \cdot c \cdot \lg m}, \text{Setting d=8c}\\\\
&\leq (2^{\lg m})^{-c}, \text{As $e>2$ and $9/4>1$}\\\\
&= \frac{\displaystyle{1}}{\displaystyle{m^c}}
\end{aligned}
$$<p>Therefore Pr</p>\[$\geq c\lg m$ heads\]<p>= 1 - $\frac{\displaystyle{1}}{\displaystyle{m^c}}$. <em>QED</em></p><h4 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h4><p>We begin by augmenting <em>node</em> with data additional to mentioned ones in
<strong>a</strong>. Namely, <em>n.leftCount</em> which denote the number of nodes additional
to node <em>n.l</em> upto current <em>n</em>. Note the number considers all nodes in
<em>level-0</em>.</p><p>For <em>Search</em>, Clearly augmenting new data on nodes do not influence the
number or order of nodes in the skip list. So nothings needs to be done
to prove the complexity is maintained.</p><p>For <em>Insert</em> and <em>Delete</em>, <em>n.leftCount</em> of some nodes must be updated.
Those nodes are exactly characterized by the same line of reasoning
mentioned in the lecture and in <strong>a</strong>. If <em>Search</em> is getting from a
top-left node to some level-0 node, Then <em>Reversed-Search</em> is getting
from a level-0 node to some top-right node. Nodes along that path are
exactly the ones which need update. The proofs are identical to <strong>a</strong>.
For the sake of brevity we omit them here and invite the reader to
observe the following diagrams as a convincing evidence.</p><p><img loading=lazy src=d1.png alt=image>
<img loading=lazy src=d2.png alt=image></p><h4 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h4><pre tabindex=0><code>Compute-Rank(x)
  curN = x
  counter = 0
  while curN != -inf:
    if curN.u != NULL, then curN = curN.u
    else counter = counter + curN.leftCount; curN = curN.l
  return counter
</code></pre><pre tabindex=0><code>Rank-Search(x,r)
  counter = Compute-Rank(curN)
  while counter != r:
    if (curN.u != NULL) AND (curN.u.r.leftCount + counter &lt;= k), then curN = curN.u
    else if curN.r.leftCount + counter &lt;= k, then curN = curN.r
    else curN = curN.d
    return curN
</code></pre><p>Again, As we assume a succesful search we do not check the cases of
<em>+inf</em> and stepping downward while being in <em>level-0</em>.</p><p>Again, Proofs are identical to <strong>a</strong> and they are omitted for brevity.
`</p><h3 id=prob-2>Prob. 2<a hidden class=anchor aria-hidden=true href=#prob-2>#</a></h3><p>For the sake of brevity we only show the <em>optimal-substructure</em> and
<em>memoization-table</em>, Whereby the algorithm should be clear enough.</p><h4 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h4><p><strong>Optimal Substructure</strong></p>$$
maxSeq(<p_1, \dots, p_n>, m) = max
\set{
\begin{array}{lr}
maxSeq(<p_1, \dots, p_{n-1}>, m-1) + p_n,\\\\
maxSeq(<p_1, \dots, p_{n-1}>, m)
\end{array}
}
$$<p><strong>Memoization Table.</strong> ith column denote the consideration of prizes $p_1, \dots, p_i$, and ith
row denote exactly i prizes.</p><p><img loading=lazy src=a.jpg alt=image></p><p>Since prizes&rsquo; values are non-negative, table</p>\[m,n\]<p>is the answer.</p><p><strong>Complexity.</strong> Both time and space complexity are $\mathcal{O}(nm)$</p><h4 id=b-1>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h4><p><strong>Remark.</strong> Observe the given sequence $S$ and the optimal-subsequence $OptS$ can
both be divided into two segments, $S1, S2$ and $OptS1, OptS2$, where
$OptS1$ is a subsequence of $S1$ and $OptS2$ is a subsequence of $S2$.<br>But neither do we know where exactly $S$ is divided nor how many prizes
are devoted to <em>blues</em> and <em>reds</em>. The solution is basically to
brute-force all possible cases and apply <em>(a)</em> to solve a single case.</p><p><strong>Optimal Substructure</strong></p><p>\begin{align}
maxSeq(&lt;p_1, \dots, p_n>, m) = max_{0 \leq i \leq n \wedge 0 \leq j \leq m}
\set{ maxSeq(&lt;p_1, \dots, p_i>, j) \cdot maxSeq(&lt;p_1, \dots, p_{n-i}>, m-j) }
\end{align}</p><p>Where &lsquo;$\cdot$&rsquo; denotes a concatenation.</p><p><strong>Complexity.</strong> Time is $nm \cdot \mathcal{O}(nm) = \mathcal{O}(n^2m^2)$. Space is the same as <em>(a)</em>.</p><h4 id=c-1>c<a hidden class=anchor aria-hidden=true href=#c-1>#</a></h4><p><strong>Remark</strong></p><p>We can think of this problem as a generalization of <em>(b)</em> where the
precedence of <em>Reds</em> over <em>Blues</em> is equivalent to prizes $p_i$ being
all less than some prize $p_0$. This is the crux of our solution.</p><p>We introduce a trick to colour prizes. Pick-up some arbitrary prize
$p_0$ and colour and all prizes $p_i < p_0$ blue and all prizes
$p_i \geq p_0$ red. Call it <em>prizes-colouring</em>.</p><p>Recursively apply <em>prizes-colouring</em> and <em>(b)</em> on the given sequence
$S$. Note the base case is the same as <em>(b)</em>, where a sequence consists
only of prizes of an equal value.</p><p>The justification is clear since we are brute-forcing all possible
cases.</p><p><strong>Complexity</strong></p><p>On average we expect the recursion to count $\log n$ iterations. The
worst case is $n$. So we have time
$n \cdot \mathcal{O}(n^2 m^2) = \mathcal{O}(n^3m^2)$, and space same as
<em>(a)</em>.</p><h4 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h4></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>