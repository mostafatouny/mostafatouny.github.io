<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 10 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done
Problems
Prob. 1
a
The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.
b
A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.
The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r > 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/erik-alg-post/pset10/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/erik-alg-post/pset10/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 10"><meta property="og:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done
Problems
Prob. 1
a
The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.
b
A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.
The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r > 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/erik-alg-post/pset10/"><meta property="article:section" content="erik-alg-post"><meta property="article:published_time" content="2023-08-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 10"><meta name=twitter:description content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done
Problems
Prob. 1
a
The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.
b
A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.
The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r > 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Erik's Algorithms","item":"https://mostafatouny.github.io/erik-alg-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 10","item":"https://mostafatouny.github.io/erik-alg-post/pset10/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 10","name":"Problem Set 10","description":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nProblems Prob. 1 a The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.\nb A randomized algorithm identical to slide 18, satisfies all the problem\u0026rsquo;s requirements.\nThe sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r \u003e 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.\n","keywords":[],"articleBody":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nProblems Prob. 1 a The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.\nb A randomized algorithm identical to slide 18, satisfies all the problem’s requirements.\nThe sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r \u003e 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.\nThat subroutine consumes $\\mathcal{O}(n)$ rounds and $\\mathcal{O}(n^2)$ messages.\nc I conjecture the answer there is no such algorithm; I couldn’t come-up with a rigorous proof. Here is an insight justifying my stance.\nThe only way processes can know each other’s UIDs is by circulating their UIDs. They cannot ever know whether the whole ring is covered. For example, If a process recorded $(a,b,c,a)$ then it can be tricked by the actual complete ring $(a,b,c,a,d)$ whose size is $5$. It is trivial to generalize the trick to accommodate any number of loops of $a$, like $(a,b,c,a,b,c,a)$ tricked by ring $(a,b,c,a,b,c,a,d)$.\nProb. 2 a I am not sure what is the sufficent degree of clarity the instructor is looking for. Neither do I claim my argument to be formally rigorous or even convincing. However, We hope it fulfills all the practical purposes of two introductory lectures.\nThe key idea is for processes, not to send search unless the root $v_0$ broadcasts ready. Also, ready is broadcasted by $v_0$ only if all of its neighbours signaled level $i$ updated their parents.\nb Time. For each level, the root $v_0$ broadcasts ready and receives a response, Accounting for $diam \\cdot 2(diam)$ edges traversed. That concludes the desired $\\mathcal{O}(diam^2 \\cdot d)$ upper-bound.\nMessages. For each level, At most all vertices, both receive and send a message, Accounting for $diam \\cdot 2n$.\n","wordCount":"344","inLanguage":"en","datePublished":"2023-08-06T00:00:00Z","dateModified":"2023-08-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/erik-alg-post/pset10/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 10</h1><div class=post-meta><span title='2023-08-06 00:00:00 +0000 UTC'>August 6, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exercises aria-label=Exercises>Exercises</a><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a></li></ul></li><li><a href=#problems aria-label=Problems>Problems</a><ul><li><a href=#prob-1 aria-label="Prob. 1">Prob. 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li></ul></li><li><a href=#prob-2 aria-label="Prob. 2">Prob. 2</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p><h2 id=exercises>Exercises<a hidden class=anchor aria-hidden=true href=#exercises>#</a></h2><h3 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h3><p>Done</p><h2 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h2><h3 id=prob-1>Prob. 1<a hidden class=anchor aria-hidden=true href=#prob-1>#</a></h3><h4 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h4><p>The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.</p><h4 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h4><p>A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.</p><p>The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r > 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.</p><p>That subroutine consumes $\mathcal{O}(n)$ rounds and $\mathcal{O}(n^2)$ messages.</p><h4 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h4><p>I conjecture the answer there is no such algorithm; I couldn&rsquo;t come-up with a rigorous proof. Here is an insight justifying my stance.</p><p>The only way processes can know each other&rsquo;s UIDs is by circulating their UIDs. They cannot ever know whether the whole ring is covered. For example, If a process recorded $(a,b,c,a)$ then it can be tricked by the actual complete ring $(a,b,c,a,d)$ whose size is $5$. It is trivial to generalize the trick to accommodate any number of loops of $a$, like $(a,b,c,a,b,c,a)$ tricked by ring $(a,b,c,a,b,c,a,d)$.</p><h3 id=prob-2>Prob. 2<a hidden class=anchor aria-hidden=true href=#prob-2>#</a></h3><h4 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h4><p>I am not sure what is the sufficent degree of clarity the instructor is looking for. Neither do I claim my argument to be formally rigorous or even convincing. However, We hope it fulfills all the practical purposes of two introductory lectures.</p><p>The key idea is for processes, not to send <em>search</em> unless the root $v_0$ broadcasts <em>ready</em>. Also, <em>ready</em> is broadcasted by $v_0$ only if all of its neighbours signaled level $i$ updated their parents.</p><h4 id=b-1 class=unnumbered>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h4><p><strong>Time.</strong> For each level, the root $v_0$ broadcasts <em>ready</em> and receives a response, Accounting for $diam \cdot 2(diam)$ edges traversed. That concludes the desired $\mathcal{O}(diam^2 \cdot d)$ upper-bound.</p><p><strong>Messages.</strong> For each level, At most all vertices, both receive and send a message, Accounting for $diam \cdot 2n$.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>