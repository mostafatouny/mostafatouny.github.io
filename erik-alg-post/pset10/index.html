<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Problem Set 10 | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done
Problems
Prob. 1
a
The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.
b
A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.
The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r &gt; 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/erik-alg-post/pset10/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/erik-alg-post/pset10/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Problem Set 10" />
<meta property="og:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done
Problems
Prob. 1
a
The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.
b
A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.
The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r &gt; 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/erik-alg-post/pset10/" /><meta property="article:section" content="erik-alg-post" />
<meta property="article:published_time" content="2023-08-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-08-06T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Problem Set 10"/>
<meta name="twitter:description" content="$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$
Exercises
Ex. 1
Done
Problems
Prob. 1
a
The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.
b
A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.
The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r &gt; 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Erik's Algorithms",
      "item": "https://www.mostafatouny.github.io/erik-alg-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Problem Set 10",
      "item": "https://www.mostafatouny.github.io/erik-alg-post/pset10/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Problem Set 10",
  "name": "Problem Set 10",
  "description": "$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nProblems Prob. 1 a The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.\nb A randomized algorithm identical to slide 18, satisfies all the problem\u0026rsquo;s requirements.\nThe sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r \u003e 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.\n",
  "keywords": [
    
  ],
  "articleBody": "$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nProblems Prob. 1 a The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.\nb A randomized algorithm identical to slide 18, satisfies all the problem’s requirements.\nThe sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r \u003e 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.\nThat subroutine consumes $\\mathcal{O}(n)$ rounds and $\\mathcal{O}(n^2)$ messages.\nc I conjecture the answer there is no such algorithm; I couldn’t come-up with a rigorous proof. Here is an insight justifying my stance.\nThe only way processes can know each other’s UIDs is by circulating their UIDs. They cannot ever know whether the whole ring is covered. For example, If a process recorded $(a,b,c,a)$ then it can be tricked by the actual complete ring $(a,b,c,a,d)$ whose size is $5$. It is trivial to generalize the trick to accommodate any number of loops of $a$, like $(a,b,c,a,b,c,a)$ tricked by ring $(a,b,c,a,b,c,a,d)$.\nProb. 2 a I am not sure what is the sufficent degree of clarity the instructor is looking for. Neither do I claim my argument to be formally rigorous or even convincing. However, We hope it fulfills all the practical purposes of two introductory lectures.\nThe key idea is for processes, not to send search unless the root $v_0$ broadcasts ready. Also, ready is broadcasted by $v_0$ only if all of its neighbours signaled level $i$ updated their parents.\nb Time. For each level, the root $v_0$ broadcasts ready and receives a response, Accounting for $diam \\cdot 2(diam)$ edges traversed. That concludes the desired $\\mathcal{O}(diam^2 \\cdot d)$ upper-bound.\nMessages. For each level, At most all vertices, both receive and send a message, Accounting for $diam \\cdot 2n$.\n",
  "wordCount" : "344",
  "inLanguage": "en",
  "datePublished": "2023-08-06T00:00:00Z",
  "dateModified": "2023-08-06T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/erik-alg-post/pset10/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Problem Set 10
    </h1>
    <div class="post-meta"><span title='2023-08-06 00:00:00 +0000 UTC'>August 6, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#exercises" aria-label="Exercises">Exercises</a><ul>
                        
                <li>
                    <a href="#ex-1" aria-label="Ex. 1">Ex. 1</a></li></ul>
                </li>
                <li>
                    <a href="#problems" aria-label="Problems">Problems</a><ul>
                        
                <li>
                    <a href="#prob-1" aria-label="Prob. 1">Prob. 1</a><ul>
                        
                <li>
                    <a href="#a" aria-label="a">a</a></li>
                <li>
                    <a href="#b" aria-label="b">b</a></li>
                <li>
                    <a href="#c" aria-label="c">c</a></li></ul>
                </li>
                <li>
                    <a href="#prob-2" aria-label="Prob. 2">Prob. 2</a><ul>
                        
                <li>
                    <a href="#a-1" aria-label="a">a</a></li>
                <li>
                    <a href="#b-1" aria-label="b">b</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>$\newcommand{\ddfrac}[2]{\frac{\displaystyle{#1}}{\displaystyle{#2}}}$</p>
<h2 id="exercises">Exercises<a hidden class="anchor" aria-hidden="true" href="#exercises">#</a></h2>
<h3 id="ex-1">Ex. 1<a hidden class="anchor" aria-hidden="true" href="#ex-1">#</a></h3>
<p>Done</p>
<h2 id="problems">Problems<a hidden class="anchor" aria-hidden="true" href="#problems">#</a></h2>
<h3 id="prob-1">Prob. 1<a hidden class="anchor" aria-hidden="true" href="#prob-1">#</a></h3>
<h4 id="a">a<a hidden class="anchor" aria-hidden="true" href="#a">#</a></h4>
<p>The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.</p>
<h4 id="b">b<a hidden class="anchor" aria-hidden="true" href="#b">#</a></h4>
<p>A randomized algorithm identical to slide 18, satisfies all the problem&rsquo;s requirements.</p>
<p>The sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r > 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.</p>
<p>That subroutine consumes $\mathcal{O}(n)$ rounds and $\mathcal{O}(n^2)$ messages.</p>
<h4 id="c">c<a hidden class="anchor" aria-hidden="true" href="#c">#</a></h4>
<p>I conjecture the answer there is no such algorithm; I couldn&rsquo;t come-up with a rigorous proof. Here is an insight justifying my stance.</p>
<p>The only way processes can know each other&rsquo;s UIDs is by circulating their UIDs. They cannot ever know whether the whole ring is covered. For example, If a process recorded $(a,b,c,a)$ then it can be tricked by the actual complete ring $(a,b,c,a,d)$ whose size is $5$. It is trivial to generalize the trick to accommodate any number of loops of $a$, like $(a,b,c,a,b,c,a)$ tricked by ring $(a,b,c,a,b,c,a,d)$.</p>
<h3 id="prob-2">Prob. 2<a hidden class="anchor" aria-hidden="true" href="#prob-2">#</a></h3>
<h4 id="a-1">a<a hidden class="anchor" aria-hidden="true" href="#a-1">#</a></h4>
<p>I am not sure what is the sufficent degree of clarity the instructor is looking for. Neither do I claim my argument to be formally rigorous or even convincing. However, We hope it fulfills all the practical purposes of two introductory lectures.</p>
<p>The key idea is for processes, not to send <em>search</em> unless the root $v_0$ broadcasts <em>ready</em>. Also, <em>ready</em> is broadcasted by $v_0$ only if all of its neighbours signaled level $i$ updated their parents.</p>
<h4 id="b-1" class="unnumbered">b<a hidden class="anchor" aria-hidden="true" href="#b-1">#</a></h4>
<p><strong>Time.</strong> For each level, the root $v_0$ broadcasts <em>ready</em> and receives a response, Accounting for $diam \cdot 2(diam)$ edges traversed. That concludes the desired $\mathcal{O}(diam^2 \cdot d)$ upper-bound.</p>
<p><strong>Messages.</strong> For each level, At most all vertices, both receive and send a message, Accounting for $diam \cdot 2n$.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
