<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 04 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="Ex. 1
a
Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It&rsquo;s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.
b
Obviously a verifier is some input $x_0$ such that $C_1(x_0) \neq C_2(x_0)$. It&rsquo;s easy to  compute both circuits and check their unequal output.
Ex. 2
Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/odonnell-undergrad-post/pset04/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/odonnell-undergrad-post/pset04/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 04"><meta property="og:description" content="Ex. 1
a
Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It&rsquo;s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.
b
Obviously a verifier is some input $x_0$ such that $C_1(x_0) \neq C_2(x_0)$. It&rsquo;s easy to  compute both circuits and check their unequal output.
Ex. 2
Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/odonnell-undergrad-post/pset04/"><meta property="article:section" content="odonnell-undergrad-post"><meta property="article:published_time" content="2023-04-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 04"><meta name=twitter:description content="Ex. 1
a
Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It&rsquo;s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.
b
Obviously a verifier is some input $x_0$ such that $C_1(x_0) \neq C_2(x_0)$. It&rsquo;s easy to  compute both circuits and check their unequal output.
Ex. 2
Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Odonnell's Undergrad Complexity","item":"https://mostafatouny.github.io/odonnell-undergrad-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 04","item":"https://mostafatouny.github.io/odonnell-undergrad-post/pset04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 04","name":"Problem Set 04","description":"Ex. 1 a Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It\u0026rsquo;s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.\nb Obviously a verifier is some input $x_0$ such that $C_1(x_0) \\neq C_2(x_0)$. It\u0026rsquo;s easy to compute both circuits and check their unequal output.\nEx. 2 Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree.\n","keywords":[],"articleBody":"Ex. 1 a Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It’s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.\nb Obviously a verifier is some input $x_0$ such that $C_1(x_0) \\neq C_2(x_0)$. It’s easy to compute both circuits and check their unequal output.\nEx. 2 Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree.\nI am not aware of any more rigorous proof.\nEx. 3 a For clarity and brevity we list all cases:\nunit clause $x_i$ delete any clause containing $x_i$ delete $\\neg x_i$ from any clase unit clause $\\neg x_i$ delete any clause containing $\\neg x_i$ delete $x_i$ from any clause Due to symmetry we mention only the case of unit clause $x_i$.\nWe prove the new propagated $C'$ is satisfiable if and only if the given $C$ is satisfiable.\n$(\\leftarrow)$ Necessarily $x_i = True$. Hence any clause containing $x_i$ is immediately evaluated to $True$ as well. Since $\\neg x_i = False$ one of the remaining units of the clause containing $\\neg x_i$ must be evaluated to $True$.\n$(\\rightarrow)$ Following the same reasoning, Since $x_i = True$, adding any clause containig $x_i$ is still going to be true regardless of other units boolean values. Also adding $\\neg x_i = False$ to any clause evaluated to $True$ won’t change the whole clause’s boolean value.\nb We give a constructive polynomial-time algorithm. We follow the hint mentioned in the problem statement.\nFor case (ii), Loop on clauses, and for each:\nIf no negative literal is assigned any value, Conveniently pick-up the first negative literal $\\neg x_k$ and assign $x_k = False$. If a negative literal $\\neg x_k$ is assigned $x_k = False$, Continue to the next clause. Observe we only assign $x_k = False$. As a result, the case of a negative literal $\\neg x_k$ assigned $x_k = True$ won’t ever be encountered.\nFor case (i), Keep applying the process of $a$, Until all unit-clauses are eliminated. If any clause is empty, It’s concluded the given $C$ is unsatisfiable. Now we know every clause contains at least two literals, Including a negative literal. Case (i) is now reduced to case (ii).\nEx. 4 a Clearly, If literals $x_i$ which are assigned to $1$ are even, Then they can re-arranged as pairs, Each yielding $0$, and in turn all pairs yield $0$. Observe for an even number, $2k$ mod 2 = 0.\nSimilarly, if literals $x_i$ which are assigned to $1$ are odd, Then we obtain 1 XOR 0 = 1, by separating one literal from the remaining even literals.\nb We define summation as, $\\epsilon_1 + \\epsilon_2 = c_1 + c_2 + 1$ where are $\\sum_i x_{1i} = c_1$ mod $2$ and $\\sum_i x_{2i} = c_2$ mod $2$. Note if $c_1 = c_2 = 1$, Then $c_1 + c_2 + 1 = 1 + 1 + 1 = 1$ mod $2$ and hence $(\\epsilon_1 + \\epsilon_2)(x) = 1$. On the other hand, If $1 + c_2 + 1 = 1$ mod $2$, Then $c_2 = -1 = 1$ mod $2$. Hence, $\\epsilon_2(x) = 1$.\nc Consider $k_1$ to be the number of equations in which $x_{11}$ appreas.\n\\begin{align*} \\text{Update $x_{11}$ to} \\hspace{10mm} { \\begin{array}{lr} 0, \u0026\\text{if $k_1$ is even} \\\\ k_1 x_{11}, \u0026\\text{if $k_1$ is odd} \\end{array} } \\end{align*}\nRemark in case $k_1 = 2m$ is even, Then $\\sum_{j=1}^{2m} x_{1j} = 2(m x_{11}) = 0$ mod $2$. That, Regardless of $x_{1j}$ values, as we would always obtain an even number.\nNow consider the whole system of equations by summing all equations as we defined in b. In case $k_1$ is even, Then we know $x_{1j}$ evaluates to zero, and hence their removal from the system doesn’t affect. In case $k_1$ is odd, Then $k_1 x_{11}$ is exactly equivalent to $x_{11} + x_{12} + \\dots + x_{1n}$. Think of redistributing $x_{1j}$ to reconstruct the original equations before the transformation, which clarifies why the new system is equivalent to the original one.\nd If at any stage $0 = 1$ is concluded, Then no matter what $x$ is inputted, The system won’t be satisfied. Since the transformed system is equivalent to the original one, It’s trivial why the original system is unsatisfiable.\nObserve in modulus 2, the only possible evaluation outcomes are $0$ or $1$. So if $LHS \\neq RHS$, then necessarily we get $0 = 1$. If we don’t get $0 = 1$, then all equations’ evaluations are satisfied.\nObserve also if $k_{ii} x_{ii} = c \\, mod \\, 2$ then by our definitions we know $k_{ii}$ is odd. It follows there’s exactly one unique solution for $x_ii$.\nAs the instructor hinted, back-substitution can be applied recursively to compute $x_{nn}$, $x_{n-1 \\, n-1}$, .., $x_{11}$ where once $x_{ii}$ is computed, For all the above equations, Their number of variables are reduced by one. Only one literal $x_{i-1 \\, i-1}$ is left for the next equation.\nAs a valid assignment $x$ for the transformed system is constructed, The original system is satisfied by $x$ also.\n","wordCount":"893","inLanguage":"en","datePublished":"2023-04-09T00:00:00Z","dateModified":"2023-04-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/odonnell-undergrad-post/pset04/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 04</h1><div class=post-meta><span title='2023-04-09 00:00:00 +0000 UTC'>April 9, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li></ul></li><li><a href=#ex-2 aria-label="Ex. 2">Ex. 2</a></li><li><a href=#ex-3 aria-label="Ex. 3">Ex. 3</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li></ul></li><li><a href=#ex-4 aria-label="Ex. 4">Ex. 4</a><ul><li><a href=#a-2 aria-label=a>a</a></li><li><a href=#b-2 aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h2><h3 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h3><p>Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It&rsquo;s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.</p><h3 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h3><p>Obviously a verifier is some input $x_0$ such that $C_1(x_0) \neq C_2(x_0)$. It&rsquo;s easy to compute both circuits and check their unequal output.</p><h2 id=ex-2>Ex. 2<a hidden class=anchor aria-hidden=true href=#ex-2>#</a></h2><p>Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree.</p><p>I am not aware of any more rigorous proof.</p><h2 id=ex-3>Ex. 3<a hidden class=anchor aria-hidden=true href=#ex-3>#</a></h2><h3 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h3><p>For clarity and brevity we list all cases:</p><ul><li>unit clause $x_i$<ul><li>delete any clause containing $x_i$</li><li>delete $\neg x_i$ from any clase</li></ul></li><li>unit clause $\neg x_i$<ul><li>delete any clause containing $\neg x_i$</li><li>delete $x_i$ from any clause</li></ul></li></ul><p>Due to symmetry we mention only the case of unit clause $x_i$.</p><p>We prove the new propagated $C'$ is satisfiable if and only if the given $C$ is satisfiable.</p><p>$(\leftarrow)$ Necessarily $x_i = True$. Hence any clause containing $x_i$ is immediately evaluated to $True$ as well. Since $\neg x_i = False$ one of the remaining units of the clause containing $\neg x_i$ must be evaluated to $True$.</p><p>$(\rightarrow)$ Following the same reasoning, Since $x_i = True$, adding any clause containig $x_i$ is still going to be true regardless of other units boolean values. Also adding $\neg x_i = False$ to any clause evaluated to $True$ won&rsquo;t change the whole clause&rsquo;s boolean value.</p><h3 id=b-1>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h3><p>We give a constructive polynomial-time algorithm. We follow the hint mentioned in the problem statement.</p><p>For case (ii), Loop on clauses, and for each:</p><ul><li>If no negative literal is assigned any value, Conveniently pick-up the first negative literal $\neg x_k$ and assign $x_k = False$.</li><li>If a negative literal $\neg x_k$ is assigned $x_k = False$, Continue to the next clause.</li></ul><p>Observe we only assign $x_k = False$. As a result, the case of a negative literal $\neg x_k$ assigned $x_k = True$ won&rsquo;t ever be encountered.</p><p>For case (i), Keep applying the process of $a$, Until all unit-clauses are eliminated. If any clause is empty, It&rsquo;s concluded the given $C$ is unsatisfiable. Now we know every clause contains at least two literals, Including a negative literal. Case (i) is now reduced to case (ii).</p><h2 id=ex-4>Ex. 4<a hidden class=anchor aria-hidden=true href=#ex-4>#</a></h2><h3 id=a-2>a<a hidden class=anchor aria-hidden=true href=#a-2>#</a></h3><p>Clearly, If literals $x_i$ which are assigned to $1$ are even, Then they can re-arranged as pairs, Each yielding $0$, and in turn all pairs yield $0$. Observe for an even number, $2k$ mod 2 = 0.</p><p>Similarly, if literals $x_i$ which are assigned to $1$ are odd, Then we obtain 1 XOR 0 = 1, by separating one literal from the remaining even literals.</p><h3 id=b-2>b<a hidden class=anchor aria-hidden=true href=#b-2>#</a></h3><p>We define summation as, $\epsilon_1 + \epsilon_2 = c_1 + c_2 + 1$ where are $\sum_i x_{1i} = c_1$ mod $2$ and $\sum_i x_{2i} = c_2$ mod $2$. Note if $c_1 = c_2 = 1$, Then $c_1 + c_2 + 1 = 1 + 1 + 1 = 1$ mod $2$ and hence $(\epsilon_1 + \epsilon_2)(x) = 1$. On the other hand, If $1 + c_2 + 1 = 1$ mod $2$, Then $c_2 = -1 = 1$ mod $2$. Hence, $\epsilon_2(x) = 1$.</p><h3 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h3><p>Consider $k_1$ to be the number of equations in which $x_{11}$ appreas.</p><p>\begin{align*}
\text{Update $x_{11}$ to} \hspace{10mm}
{
\begin{array}{lr}
0, &\text{if $k_1$ is even} \\
k_1 x_{11}, &\text{if $k_1$ is odd}
\end{array}
}
\end{align*}</p><p>Remark in case $k_1 = 2m$ is even, Then $\sum_{j=1}^{2m} x_{1j} = 2(m x_{11}) = 0$ mod $2$. That, Regardless of $x_{1j}$ values, as we would always obtain an even number.</p><p>Now consider the whole system of equations by summing all equations as we defined in <em>b</em>. In case $k_1$ is even, Then we know $x_{1j}$ evaluates to zero, and hence their removal from the system doesn&rsquo;t affect. In case $k_1$ is odd, Then $k_1 x_{11}$ is exactly equivalent to $x_{11} + x_{12} + \dots + x_{1n}$. Think of redistributing $x_{1j}$ to reconstruct the original equations before the transformation, which clarifies why the new system is equivalent to the original one.</p><h3 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h3><p>If at any stage $0 = 1$ is concluded, Then no matter what $x$ is inputted, The system won&rsquo;t be satisfied. Since the transformed system is equivalent to the original one, It&rsquo;s trivial why the original system is unsatisfiable.</p><p>Observe in <em>modulus 2</em>, the only possible evaluation outcomes are $0$ or $1$. So if $LHS \neq RHS$, then necessarily we get $0 = 1$. If we don&rsquo;t get $0 = 1$, then all equations&rsquo; evaluations are satisfied.</p><p>Observe also if $k_{ii} x_{ii} = c \, mod \, 2$ then by our definitions we know $k_{ii}$ is odd. It follows there&rsquo;s exactly one unique solution for $x_ii$.</p><p>As the instructor hinted, back-substitution can be applied recursively to compute $x_{nn}$, $x_{n-1 \, n-1}$, .., $x_{11}$ where once $x_{ii}$ is computed, For all the above equations, Their number of variables are reduced by one. Only one literal $x_{i-1 \, i-1}$ is left for the next equation.</p><p>As a valid assignment $x$ for the transformed system is constructed, The original system is satisfied by $x$ also.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>