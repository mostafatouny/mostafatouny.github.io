<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Problem Set 06, | Mostafa Touny</title>
<meta name="keywords" content="">
<meta name="description" content="Ex. 1
Here is a very illustrative example.


The procedure of encoding 3COL-UNARY to 3COL is as:

\(i\) For each group of nodes labeled with some colour x, create
two additional connected nodes x1 and x2, and connect each node
coloured x to both of them.
\(ii\) For each two distinct groups of colours x and y, connect
some node from x with some node from y.

When encoded input is run on 3COL,">
<meta name="author" content="">
<link rel="canonical" href="https://www.mostafatouny.github.io/odonnell-undergrad-post/pset06/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css" integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.mostafatouny.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.mostafatouny.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.mostafatouny.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.mostafatouny.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.mostafatouny.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.mostafatouny.github.io/odonnell-undergrad-post/pset06/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Problem Set 06," />
<meta property="og:description" content="Ex. 1
Here is a very illustrative example.


The procedure of encoding 3COL-UNARY to 3COL is as:

\(i\) For each group of nodes labeled with some colour x, create
two additional connected nodes x1 and x2, and connect each node
coloured x to both of them.
\(ii\) For each two distinct groups of colours x and y, connect
some node from x with some node from y.

When encoded input is run on 3COL," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mostafatouny.github.io/odonnell-undergrad-post/pset06/" /><meta property="article:section" content="odonnell-undergrad-post" />
<meta property="article:published_time" content="2023-05-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-05-21T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Problem Set 06,"/>
<meta name="twitter:description" content="Ex. 1
Here is a very illustrative example.


The procedure of encoding 3COL-UNARY to 3COL is as:

\(i\) For each group of nodes labeled with some colour x, create
two additional connected nodes x1 and x2, and connect each node
coloured x to both of them.
\(ii\) For each two distinct groups of colours x and y, connect
some node from x with some node from y.

When encoded input is run on 3COL,"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Odonnell's Undergrad Complexity",
      "item": "https://www.mostafatouny.github.io/odonnell-undergrad-post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Problem Set 06,",
      "item": "https://www.mostafatouny.github.io/odonnell-undergrad-post/pset06/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Problem Set 06,",
  "name": "Problem Set 06,",
  "description": "Ex. 1 Here is a very illustrative example.\nThe procedure of encoding 3COL-UNARY to 3COL is as:\n\\(i\\) For each group of nodes labeled with some colour x, create two additional connected nodes x1 and x2, and connect each node coloured x to both of them. \\(ii\\) For each two distinct groups of colours x and y, connect some node from x with some node from y. When encoded input is run on 3COL,\n",
  "keywords": [
    
  ],
  "articleBody": "Ex. 1 Here is a very illustrative example.\nThe procedure of encoding 3COL-UNARY to 3COL is as:\n\\(i\\) For each group of nodes labeled with some colour x, create two additional connected nodes x1 and x2, and connect each node coloured x to both of them. \\(ii\\) For each two distinct groups of colours x and y, connect some node from x with some node from y. When encoded input is run on 3COL,\nProcedure (i) ensures all nodes coloured x will have the same colour, even if that colour is not exactly x. Procedure (ii) ensures groups of labeled nodes will have different colours. Notably the colours outputted by 3COL may not match the given original labeled colours. Since colours are symmetric, i.e can be exchanged without tampering any required condition, an encoded graph $f(w)$ is accepted by 3COL if and only if graph $w$ is accepted by 3COL-UNARY.\nEx. 2 The goal is to show any language in NP can be polynomially reduced to IMPLICIT-4COL. The exponentiality of number of vertices of graph $G_C$ is the central key of testing all possible certificates and in turn determining whether a given w belongs to L language.\nBy cook-levin we know any NP language can be encoded in terms of SAT, and hence we can construct a corresponding circuit. Since the circuit’s input is of length 2n, we can think of it as partitioned into two n-length inputs. The first one is problem’s input (like a graph) and the second is a potential certificate (like a graph-route). The circuit evaluates whether a given input along some literals assignments (cirtificate) yields true (satisfiable).\nWe assume any language input is prefixed with 0, and any certificate input is prefixed with 1. If the circuit is given an invalid encoding it immediately outputs FALSE. In other words, If a circuit accepts some input pair, we are ensured the first one indicates a language input and the second indicates a possible certificate.\nNow we can think of graph $G_C$ as being partitioned into two groups; One for language inputs and the other for all possible certificates. If a vertix prefixed with 0 is connected to a vertix prefixed with 1, we can immediately conclude the language input is satisfiable, and otherwise it is unsatisfiable.\nGiven any language $L$ we can construct a corresponding $C$, and by IMPLICIT-4COL a corresponding $G_C$. For any input $w$ which we wish to check whether it belongs to $L$, We can see whether its encoded vertex in $G_C$ is connected to any other vertex.\nEx. 3 Notation.\nNAE-Constraint: $N_i = (x_1, x_2, x_3)$ $XOR(x_i, x_j) = (x_i \\vee x_j) \\wedge (\\neg x_i \\vee \\neg x_j)$ $GXOR(x_i, x_j, x_k) = XOR(x_i, x_j) \\wedge XOR(x_i, x_k) \\wedge XOR(x_j, x_k)$ Recall an $XOR$ means exactly one of two literals is true\nLemma. $GXOR$ is unsatisfiable.\nObserve each two $XORs$ intersect a literal $x_i$. So either:\n$x_i$ is False, and $x_j$ and $x_k$ are both True. Or $x_i$ is True, and $x_j$ and $x_k$ are both False But that contradicts the third $XOR$ stipulating exactly one of $x_j$ and $x_k$ is True.\nLemma. 5 clauses of $GXOR$ are satisfiable.\nFollowing the same line of reasoning of the previous lemma, It’s clear by ignoring some clause of the 6 clauses of $GXOR$, we can have $x_j$ and $x_k$ both assigned to the same boolean value.\nLemma. Equivalence of NAE constraint and 5 clauses of $GXOR$.\nIt is clear from the previous discussion that satisfying any 5 clauses of $GXOR$ is equivalent to satisfying an NAE constraint. Clearly, Not-All-Equal constraint is exactly the same as either two literals are True and one is False, or two literals are False and one is True.\nTheorem. An NAE-3SAT: $N_1, N_2, \\dots, N_r$ is equivalent to corresponding MAX-2SAT: $GXOR_1, GXOR_2, \\dots, GXOR_r$ with at least $5r$ clauses to be satisfied.\nIf MAX-2SAT is going to satisfy exactly 5 clauses of each $GXOR_i$, Then we are guaranteed of satisfying all $N_i$. In fact, This is the only feasible distribution of satisfied clauses. Otherwise all 6 clauses of some $GXOR_i$ must be satisfied, contradicting Lemma 2.\nOn the other hand, It’s clear if a given NAE-3SAT instance is satisfiable, then so is the corresponding MAX-2SAT.\nEx. 4 “not confident of the solution”\na As mentioned by the instructor we follow the verifier-based definition of NP. Our goal is to show $$\\begin{aligned} \\in TS \\leftrightarrow \\exists u \\, s.t \\, S(, u) \\, \\text{certifies} \\, \\in TS\\end{aligned}$$By $S$ we mean an algorithm which simulates $M$ on $(x, u)$, untill it accepts on $t$ steps.\nThe definition trivially concludes our intended goal. Note if $ \\, \\not\\in \\, TS$ then obviously there’s no any certificate $u$, such that any $M$ computes $(x, u)$ in time bounded by $t$.\n",
  "wordCount" : "796",
  "inLanguage": "en",
  "datePublished": "2023-05-21T00:00:00Z",
  "dateModified": "2023-05-21T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.mostafatouny.github.io/odonnell-undergrad-post/pset06/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mostafa Touny",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.mostafatouny.github.io/favicon.ico"
    }
  }
}
</script>

    
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ],  
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]      
    }
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.mostafatouny.github.io/" accesskey="h" title="Mostafa Touny (Alt + H)">Mostafa Touny</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.mostafatouny.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.mostafatouny.github.io/post" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Problem Set 06,
    </h1>
    <div class="post-meta"><span title='2023-05-21 00:00:00 +0000 UTC'>May 21, 2023</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#ex-1" aria-label="Ex. 1">Ex. 1</a></li>
                <li>
                    <a href="#ex-2" aria-label="Ex. 2">Ex. 2</a></li>
                <li>
                    <a href="#ex-3" aria-label="Ex. 3">Ex. 3</a></li>
                <li>
                    <a href="#ex-4" aria-label="Ex. 4">Ex. 4</a><ul>
                        
                <li>
                    <a href="#a" aria-label="a">a</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="ex-1">Ex. 1<a hidden class="anchor" aria-hidden="true" href="#ex-1">#</a></h2>
<p>Here is a very illustrative example.</p>
<p><img loading="lazy" src="example.jpg" alt="image"  />
</p>
<p>The procedure of encoding <em>3COL-UNARY</em> to <em>3COL</em> is as:</p>
<ul>
<li>\(i\) For each group of nodes labeled with some colour <em>x</em>, create
two additional connected nodes <em>x1</em> and <em>x2</em>, and connect each node
coloured <em>x</em> to both of them.</li>
<li>\(ii\) For each two distinct groups of colours <em>x</em> and <em>y</em>, connect
some node from <em>x</em> with some node from <em>y</em>.</li>
</ul>
<p>When encoded input is run on <em>3COL</em>,</p>
<ul>
<li>Procedure (i) ensures all nodes coloured <em>x</em> will have the same
colour, even if that colour is not exactly <em>x</em>.</li>
<li>Procedure (ii) ensures groups of labeled nodes will have different
colours.</li>
</ul>
<p>Notably the colours outputted by <em>3COL</em> may not match the given original
labeled colours. Since colours are symmetric, i.e can be exchanged
without tampering any required condition, an encoded graph $f(w)$ is
accepted by <em>3COL</em> if and only if graph $w$ is accepted by <em>3COL-UNARY</em>.</p>
<h2 id="ex-2">Ex. 2<a hidden class="anchor" aria-hidden="true" href="#ex-2">#</a></h2>
<p>The goal is to show any language in NP can be polynomially reduced to
<em>IMPLICIT-4COL</em>. The exponentiality of number of vertices of graph $G_C$
is the central key of testing all possible certificates and in turn
determining whether a given <em>w</em> belongs to <em>L</em> language.</p>
<p>By cook-levin we know any NP language can be encoded in terms of SAT,
and hence we can construct a corresponding circuit. Since the circuit&rsquo;s
input is of length 2n, we can think of it as partitioned into two
n-length inputs. The first one is problem&rsquo;s input (like a graph) and the
second is a potential certificate (like a graph-route). The circuit
evaluates whether a given input along some literals assignments
(cirtificate) yields true (satisfiable).</p>
<p>We assume any language input is prefixed with 0, and any certificate
input is prefixed with 1. If the circuit is given an invalid encoding it
immediately outputs <em>FALSE</em>. In other words, If a circuit accepts some
input pair, we are ensured the first one indicates a language input and
the second indicates a possible certificate.</p>
<p>Now we can think of graph $G_C$ as being partitioned into two groups;
One for language inputs and the other for all possible certificates. If
a vertix prefixed with 0 is connected to a vertix prefixed with 1, we
can immediately conclude the language input is satisfiable, and
otherwise it is unsatisfiable.</p>
<p>Given any language $L$ we can construct a corresponding $C$, and by
<em>IMPLICIT-4COL</em> a corresponding $G_C$. For any input $w$ which we wish
to check whether it belongs to $L$, We can see whether its encoded
vertex in $G_C$ is connected to any other vertex.</p>
<h2 id="ex-3">Ex. 3<a hidden class="anchor" aria-hidden="true" href="#ex-3">#</a></h2>
<p><strong>Notation.</strong></p>
<ul>
<li>NAE-Constraint: $N_i = (x_1, x_2, x_3)$</li>
<li>$XOR(x_i, x_j) = (x_i \vee x_j) \wedge (\neg x_i \vee \neg x_j)$</li>
<li>$GXOR(x_i, x_j, x_k) = XOR(x_i, x_j) \wedge XOR(x_i, x_k) \wedge XOR(x_j, x_k)$</li>
</ul>
<p>Recall an $XOR$ means exactly one of two literals is true</p>
<p><strong>Lemma.</strong>   $GXOR$ is unsatisfiable.<br>
Observe each two $XORs$ intersect a literal $x_i$. So either:</p>
<ul>
<li>$x_i$ is <em>False</em>, and $x_j$ and $x_k$ are both <em>True</em>. Or</li>
<li>$x_i$ is <em>True</em>, and $x_j$ and $x_k$ are both <em>False</em></li>
</ul>
<p>But that contradicts the third $XOR$ stipulating exactly one of $x_j$
and $x_k$ is <em>True</em>.</p>
<p><strong>Lemma.</strong>   5 clauses of $GXOR$ are satisfiable.<br>
Following the same line of reasoning of the previous lemma, It&rsquo;s clear
by ignoring some clause of the 6 clauses of $GXOR$, we can have $x_j$
and $x_k$ both assigned to the same boolean value.</p>
<p><strong>Lemma.</strong>   Equivalence of NAE constraint and 5 clauses of $GXOR$.<br>
It is clear from the previous discussion that satisfying any 5 clauses
of $GXOR$ is equivalent to satisfying an NAE constraint. Clearly,
<em>Not-All-Equal</em> constraint is exactly the same as either two literals
are <em>True</em> and one is <em>False</em>, or two literals are <em>False</em> and one is
<em>True</em>.</p>
<p><strong>Theorem.</strong>   An <em>NAE-3SAT:</em> $N_1, N_2, \dots, N_r$ is equivalent to
corresponding <em>MAX-2SAT:</em> $GXOR_1, GXOR_2, \dots, GXOR_r$ with at least
$5r$ clauses to be satisfied.<br>
<br>
If <em>MAX-2SAT</em> is going to satisfy exactly 5 clauses of each $GXOR_i$,
Then we are guaranteed of satisfying all $N_i$. In fact, This is the
only feasible distribution of satisfied clauses. Otherwise all 6 clauses
of some $GXOR_i$ must be satisfied, contradicting <em>Lemma 2</em>.</p>
<p>On the other hand, It&rsquo;s clear if a given <em>NAE-3SAT</em> instance is
satisfiable, then so is the corresponding <em>MAX-2SAT</em>.</p>
<h2 id="ex-4">Ex. 4<a hidden class="anchor" aria-hidden="true" href="#ex-4">#</a></h2>
<p>&ldquo;not confident of the solution&rdquo;</p>
<h3 id="a">a<a hidden class="anchor" aria-hidden="true" href="#a">#</a></h3>
<p>As mentioned by the instructor we follow the verifier-based definition
of NP. Our goal is to show </p>
$$\begin{aligned}
<M, x, 1^w, 1^t> \in TS \leftrightarrow \exists u \, s.t \, S(<M, x, 1^w, 1^t>, u)   \, \text{certifies} \, <M, x, 1^w, 1^t> \in TS\end{aligned}$$<p>By $S$ we mean an algorithm which simulates $M$ on $(x, u)$, untill it
accepts on $t$ steps.</p>
<p>The definition trivially concludes our intended goal. Note if
$<M, x, 1^w, 1^t> \, \not\in \, TS$ then obviously there&rsquo;s no any
certificate $u$, such that any $M$ computes $(x, u)$ in time bounded by
$t$.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://www.mostafatouny.github.io/">Mostafa Touny</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
