<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Set 02 | Mostafa Touny</title>
<meta name=keywords content><meta name=description content="Ex. 1
The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn&rsquo;t recognizable by any turing machine.
Let&rsquo;s prove uncountability of unary languages. Observe the set $\Sigma^\*$ equals
\begin{align*}
&\epsilon \quad &amp;s_1\\
&amp;1 \quad &amp;s_2\\
&amp;11 \quad &amp;s_3\\
&amp;111 \quad &amp;s_4\\
&.. \quad &..\\
\end{align*}
Any unary language is a subset of $\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite."><meta name=author content><link rel=canonical href=https://mostafatouny.github.io/odonnell-undergrad-post/pset02/><link crossorigin=anonymous href=/assets/css/stylesheet.e6ee52f0fc7c2e3dbd78858fc1b3e06fb86a3c6ee38d351342e06e23a24d02d6.css integrity="sha256-5u5S8Px8Lj29eIWPwbPgb7hqPG7jjTUTQuBuI6JNAtY=" rel="preload stylesheet" as=style><link rel=icon href=https://mostafatouny.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mostafatouny.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mostafatouny.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mostafatouny.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mostafatouny.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mostafatouny.github.io/odonnell-undergrad-post/pset02/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Problem Set 02"><meta property="og:description" content="Ex. 1
The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn&rsquo;t recognizable by any turing machine.
Let&rsquo;s prove uncountability of unary languages. Observe the set $\Sigma^\*$ equals
\begin{align*}
&\epsilon \quad &amp;s_1\\
&amp;1 \quad &amp;s_2\\
&amp;11 \quad &amp;s_3\\
&amp;111 \quad &amp;s_4\\
&.. \quad &..\\
\end{align*}
Any unary language is a subset of $\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite."><meta property="og:type" content="article"><meta property="og:url" content="https://mostafatouny.github.io/odonnell-undergrad-post/pset02/"><meta property="article:section" content="odonnell-undergrad-post"><meta property="article:published_time" content="2023-02-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Problem Set 02"><meta name=twitter:description content="Ex. 1
The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn&rsquo;t recognizable by any turing machine.
Let&rsquo;s prove uncountability of unary languages. Observe the set $\Sigma^\*$ equals
\begin{align*}
&\epsilon \quad &amp;s_1\\
&amp;1 \quad &amp;s_2\\
&amp;11 \quad &amp;s_3\\
&amp;111 \quad &amp;s_4\\
&.. \quad &..\\
\end{align*}
Any unary language is a subset of $\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Odonnell's Undergrad Complexity","item":"https://mostafatouny.github.io/odonnell-undergrad-post/"},{"@type":"ListItem","position":2,"name":"Problem Set 02","item":"https://mostafatouny.github.io/odonnell-undergrad-post/pset02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Problem Set 02","name":"Problem Set 02","description":"Ex. 1 The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn\u0026rsquo;t recognizable by any turing machine.\nLet\u0026rsquo;s prove uncountability of unary languages. Observe the set $\\Sigma^\\*$ equals \\begin{align*} \u0026amp;\\epsilon \\quad \u0026amp;s_1\\\\ \u0026amp;1 \\quad \u0026amp;s_2\\\\ \u0026amp;11 \\quad \u0026amp;s_3\\\\ \u0026amp;111 \\quad \u0026amp;s_4\\\\ \u0026amp;.. \\quad \u0026amp;..\\\\ \\end{align*} Any unary language is a subset of $\\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite.\n","keywords":[],"articleBody":"Ex. 1 The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn’t recognizable by any turing machine.\nLet’s prove uncountability of unary languages. Observe the set $\\Sigma^\\*$ equals \\begin{align*} \u0026\\epsilon \\quad \u0026s_1\\\\ \u00261 \\quad \u0026s_2\\\\ \u002611 \\quad \u0026s_3\\\\ \u0026111 \\quad \u0026s_4\\\\ \u0026.. \\quad \u0026..\\\\ \\end{align*} Any unary language is a subset of $\\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite.\nEx. 2 a Assume the input is conveniently given as *w#, and machine’s tape-1 is on first character of w (or on # if $w$ is $\\epsilon$). Assume also tape-2 is given with * character at its beginning, and tape-2 head is one-step right to it. For brevity we ignore such implementation details.\nInitial state is $q_{\\text{rightDouble1}}$. We assume characters of the alphabet have corresponding other marked characters. e.g 1 has 1’. We indicate by saying marking a character, replacing it with its corresponding marked one.\n$q_{\\text{leftUntill*}}:$ move tape-1 left untill * is read, Then move right and $q_{\\text{rightDouble1}}$.\n$q_{\\text{rightDouble1}}:$ sequentially, move tape-1 right once, write 1 in tape-2 twice in two sequential slots, untill # is read by tape-1 then move left and $q_{\\text{isAllMarked}}$.\n$q_{\\text{isAllMarked}}:$ if a marked character or * is read by tape-1, then $q_{\\text{unmarkInput}}$. if a non-marked character is read, then $q_{\\text{leftUntill*}}$.\n$q_{\\text{unmarkInput}}:$ move tape-1 left replacing marked characters by their unmarked counterparts untill * is read, then move right and $q_{\\text{lefttape2}}$.\n$q_{\\text{lefttape2}}:$ move tape-2 left untill * is read, then move right.\nIt is easy to transform tape-1 to be exactly w and tape-2 to be popped out of * at its left-most. We ignore these implementation details.\nb From a, We know there’s a 2-tape turing machine $T$ that can prepare tape-2 with string $1^{2|w|^2}$. We wish to think of this string as a counter of number of steps taken by the machine. It is possible for it to be augmented, to simulate machine $M$, while ticking tape-2, Accepting if $M$ accepts and tape-2 isn’t completely ticked, and rejecting otherwise. The 1-tape turing machine $M$ can be constructed by simulating $T$.\n$T$ runs in polynomial time, since preparing tape-2 is upperbounded by $n^2$, and ticking tape-2 while simulating $M$ doesn’t cost any more steps. The simulation of $T$ by $M'$ is polynomially overheaded by $T$, and hence $M'$ is polynomially upperbounded.\nEx. 3 a Let $T$ be the turing machine recognizing $L$. It is possible to construct another turing machine $T'$ whose accept and reject states are swapped. So, $w \\in L$ iff $T$ accepts $w$ iff $T'$ rejects $w$ iff $w \\not\\in L^c$.\nThe number of steps made by $T'$ is exactly the same as $T$, and hence of a polynomial complexity.\nb Let $T_1$ and $T_2$ be two turing machines recognizing $L_1$ and $L_2$ respectively. It is possible to construct a new turing machine $T$ that simulates $T_1$ and memorizes its result, Then instead of termination, simulates $T_2$ on the same input and memorizes its result also. It is easy for $T$ to be designed such that it accepts input $w$ if and only if either the simulation of $T_1$ or $T_1$ accepted.\nThe complexity of $T$ is $\\mathcal{O}(poly(n)) + \\mathcal{O}(poly(n)) + C = \\mathcal{O}(poly(n))$\nc Similarly to b, but $T$ accepts input $w$ if and only if both the simulations of $T_1$ and $T_2$ are accepted.\nd Similarly to b, but $T$ accepts input $w$ if and only if at least two out of the three simulations of $T_1$, $T_2$, and $T_3$ accepts.\ne Let $T$ be the turing machine recognizing $L$. For any $m \\in \\mathcal{N}$, It is possible to construct a m-tape turing machine $T_m$, that simulates $T$ on $w_i$ on the ith tape. Hence, complexity of $T_m$ is $\\sum_{i=0}^m \\mathcal{O}(poly(|w_i|)) = \\mathcal{O}(poly(|w|))$. Clearly the processing required to copy substrings $w_i$ on ith tapes is polynomial also, Hence $T_m$’s established upperbound remains the same.\nEx. 4 Any turing machine needs at least a linear scan of cost $n$, to behave in number of steps, as a function of $n$. In other words, number of steps $T$, must be $T(n) \\geq n$, so that $T = f(n)$ for some function $f$. Since $T$ is upperbounded by $\\sqrt{n} = \\mathcal{o}(n)$, $T(n) \\neq f(n)$ for any $f$. In other words, $T$ isn’t based on input size $n$. Therefore, must be a constant.\nThe intuition is very strong that a turing machine cannot behave in relation to $n$ if its memory doesn’t contain $n$’s value; I am not aware of a more rigorous proof.\nAs final note, For any constant $C$, we can always find some $n$, such that $C \\sqrt{n} \u003c n$. Hence, always guaranteeing the turing machine can’t read its whole input.\n","wordCount":"825","inLanguage":"en","datePublished":"2023-02-20T00:00:00Z","dateModified":"2023-02-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mostafatouny.github.io/odonnell-undergrad-post/pset02/"},"publisher":{"@type":"Organization","name":"Mostafa Touny","logo":{"@type":"ImageObject","url":"https://mostafatouny.github.io/favicon.ico"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"],["\\[","\\]"]],inlineMath:[["$","$"],["\\(","\\)"]]}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mostafatouny.github.io/ accesskey=h title="Mostafa Touny (Alt + H)">Mostafa Touny</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mostafatouny.github.io/about title=About><span>About</span></a></li><li><a href=https://mostafatouny.github.io/post title=Blog><span>Blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Problem Set 02</h1><div class=post-meta><span title='2023-02-20 00:00:00 +0000 UTC'>February 20, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ex-1 aria-label="Ex. 1">Ex. 1</a></li><li><a href=#ex-2 aria-label="Ex. 2">Ex. 2</a><ul><li><a href=#a aria-label=a>a</a></li><li><a href=#b aria-label=b>b</a></li></ul></li><li><a href=#ex-3 aria-label="Ex. 3">Ex. 3</a><ul><li><a href=#a-1 aria-label=a>a</a></li><li><a href=#b-1 aria-label=b>b</a></li><li><a href=#c aria-label=c>c</a></li><li><a href=#d aria-label=d>d</a></li><li><a href=#e aria-label=e>e</a></li></ul></li><li><a href=#ex-4 aria-label="Ex. 4">Ex. 4</a></li></ul></div></details></div><div class=post-content><h2 id=ex-1>Ex. 1<a hidden class=anchor aria-hidden=true href=#ex-1>#</a></h2><p>The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn&rsquo;t recognizable by any turing machine.</p><p>Let&rsquo;s prove uncountability of unary languages. Observe the set $\Sigma^\*$ equals
\begin{align*}
&\epsilon \quad &amp;s_1\\
&amp;1 \quad &amp;s_2\\
&amp;11 \quad &amp;s_3\\
&amp;111 \quad &amp;s_4\\
&.. \quad &..\\
\end{align*}
Any unary language is a subset of $\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite.</p><h2 id=ex-2>Ex. 2<a hidden class=anchor aria-hidden=true href=#ex-2>#</a></h2><h3 id=a>a<a hidden class=anchor aria-hidden=true href=#a>#</a></h3><p>Assume the input is conveniently given as *w#, and machine&rsquo;s tape-1 is on first character of w (or on # if $w$ is $\epsilon$). Assume also tape-2 is given with * character at its beginning, and tape-2 head is one-step right to it. For brevity we ignore such implementation details.</p><p>Initial state is $q_{\text{rightDouble1}}$. We assume characters of the alphabet have corresponding other marked characters. e.g 1 has 1&rsquo;. We indicate by saying marking a character, replacing it with its corresponding marked one.</p><p>$q_{\text{leftUntill*}}:$ move tape-1 left untill * is read, Then move right and $q_{\text{rightDouble1}}$.</p><p>$q_{\text{rightDouble1}}:$ sequentially, move tape-1 right once, write 1 in tape-2 twice in two sequential slots, untill # is read by tape-1 then move left and $q_{\text{isAllMarked}}$.</p><p>$q_{\text{isAllMarked}}:$ if a marked character or * is read by tape-1, then $q_{\text{unmarkInput}}$. if a non-marked character is read, then $q_{\text{leftUntill*}}$.</p><p>$q_{\text{unmarkInput}}:$ move tape-1 left replacing marked characters by their unmarked counterparts untill * is read, then move right and $q_{\text{lefttape2}}$.</p><p>$q_{\text{lefttape2}}:$ move tape-2 left untill * is read, then move right.</p><p>It is easy to transform tape-1 to be exactly w and tape-2 to be popped out of * at its left-most. We ignore these implementation details.</p><h3 id=b>b<a hidden class=anchor aria-hidden=true href=#b>#</a></h3><p>From <em>a</em>, We know there&rsquo;s a 2-tape turing machine $T$ that can prepare tape-2 with string $1^{2|w|^2}$. We wish to think of this string as a counter of number of steps taken by the machine. It is possible for it to be augmented, to simulate machine $M$, while ticking tape-2, Accepting if $M$ accepts and tape-2 isn&rsquo;t completely ticked, and rejecting otherwise. The 1-tape turing machine $M$ can be constructed by simulating $T$.</p><p>$T$ runs in polynomial time, since preparing tape-2 is upperbounded by $n^2$, and ticking tape-2 while simulating $M$ doesn&rsquo;t cost any more steps. The simulation of $T$ by $M'$ is polynomially overheaded by $T$, and hence $M'$ is polynomially upperbounded.</p><h2 id=ex-3>Ex. 3<a hidden class=anchor aria-hidden=true href=#ex-3>#</a></h2><h3 id=a-1>a<a hidden class=anchor aria-hidden=true href=#a-1>#</a></h3><p>Let $T$ be the turing machine recognizing $L$. It is possible to construct another turing machine $T'$ whose <em>accept</em> and <em>reject</em> states are swapped. So, $w \in L$ iff $T$ accepts $w$ iff $T'$ rejects $w$ iff $w \not\in L^c$.</p><p>The number of steps made by $T'$ is exactly the same as $T$, and hence of a polynomial complexity.</p><h3 id=b-1>b<a hidden class=anchor aria-hidden=true href=#b-1>#</a></h3><p>Let $T_1$ and $T_2$ be two turing machines recognizing $L_1$ and $L_2$ respectively. It is possible to construct a new turing machine $T$ that simulates $T_1$ and memorizes its result, Then instead of termination, simulates $T_2$ on the same input and memorizes its result also. It is easy for $T$ to be designed such that it accepts input $w$ if and only if either the simulation of $T_1$ or $T_1$ accepted.</p><p>The complexity of $T$ is $\mathcal{O}(poly(n)) + \mathcal{O}(poly(n)) + C = \mathcal{O}(poly(n))$</p><h3 id=c>c<a hidden class=anchor aria-hidden=true href=#c>#</a></h3><p>Similarly to <em>b</em>, but $T$ accepts input $w$ if and only if both the simulations of $T_1$ and $T_2$ are accepted.</p><h3 id=d>d<a hidden class=anchor aria-hidden=true href=#d>#</a></h3><p>Similarly to <em>b</em>, but $T$ accepts input $w$ if and only if at least two out of the three simulations of $T_1$, $T_2$, and $T_3$ accepts.</p><h3 id=e>e<a hidden class=anchor aria-hidden=true href=#e>#</a></h3><p>Let $T$ be the turing machine recognizing $L$. For any $m \in \mathcal{N}$, It is possible to construct a m-tape turing machine $T_m$, that simulates $T$ on $w_i$ on the ith tape. Hence, complexity of $T_m$ is $\sum_{i=0}^m \mathcal{O}(poly(|w_i|)) = \mathcal{O}(poly(|w|))$. Clearly the processing required to copy substrings $w_i$ on ith tapes is polynomial also, Hence $T_m$&rsquo;s established upperbound remains the same.</p><h2 id=ex-4>Ex. 4<a hidden class=anchor aria-hidden=true href=#ex-4>#</a></h2><p>Any turing machine needs at least a linear scan of cost $n$, to behave in number of steps, as a function of $n$. In other words, number of steps $T$, must be $T(n) \geq n$, so that $T = f(n)$ for some function $f$. Since $T$ is upperbounded by $\sqrt{n} = \mathcal{o}(n)$, $T(n) \neq f(n)$ for any $f$. In other words, $T$ isn&rsquo;t based on input size $n$. Therefore, must be a constant.</p><p>The intuition is very strong that a turing machine cannot behave in relation to $n$ if its memory doesn&rsquo;t contain $n$&rsquo;s value; I am not aware of a more rigorous proof.</p><p>As final note, For any constant $C$, we can always find some $n$, such that $C \sqrt{n} < n$. Hence, always guaranteeing the turing machine can&rsquo;t read its whole input.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mostafatouny.github.io/>Mostafa Touny</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>