<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Odonnell's Undergrad Complexity on Mostafa Touny</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/</link><description>Recent content in Odonnell's Undergrad Complexity on Mostafa Touny</description><generator>Hugo -- 0.136.5</generator><language>en-us</language><lastBuildDate>Sun, 21 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://mostafatouny.github.io/odonnell-undergrad-post/index.xml" rel="self" type="application/rss+xml"/><item><title>Problem Set 06,</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/pset06/</link><pubDate>Sun, 21 May 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/odonnell-undergrad-post/pset06/</guid><description>&lt;h2 id="ex-1">Ex. 1&lt;/h2>
&lt;p>Here is a very illustrative example.&lt;/p>
&lt;p>&lt;img loading="lazy" src="example.jpg" alt="image" />
&lt;/p>
&lt;p>The procedure of encoding &lt;em>3COL-UNARY&lt;/em> to &lt;em>3COL&lt;/em> is as:&lt;/p>
&lt;ul>
&lt;li>\(i\) For each group of nodes labeled with some colour &lt;em>x&lt;/em>, create
two additional connected nodes &lt;em>x1&lt;/em> and &lt;em>x2&lt;/em>, and connect each node
coloured &lt;em>x&lt;/em> to both of them.&lt;/li>
&lt;li>\(ii\) For each two distinct groups of colours &lt;em>x&lt;/em> and &lt;em>y&lt;/em>, connect
some node from &lt;em>x&lt;/em> with some node from &lt;em>y&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>When encoded input is run on &lt;em>3COL&lt;/em>,&lt;/p></description></item><item><title>Problem Set 05</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/pset05/</link><pubDate>Sun, 30 Apr 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/odonnell-undergrad-post/pset05/</guid><description>&lt;h2 id="ex-0">Ex. 0&lt;/h2>
&lt;p>Naively we guess any transformation $f$ of Boolean formulas preserves the property of satisfiability. Hence it would always be the case
&lt;/p>
$$
\begin{aligned}
w \not\in \textit{UNSAT} \leftrightarrow f(w) \in \textit{SAT}
\end{aligned}
$$&lt;h2 id="ex-1">Ex. 1&lt;/h2>
&lt;p>Since the questions is about factor $a$ we can ignore constants. $n^r + {(n^l)}^b = n^{r+lb}$. So $a = r+lb$.&lt;/p>
&lt;h2 id="ex-2">Ex. 2&lt;/h2>
&lt;p>following NTM simulation by DTM, partition states into H1 and H2 subsets, and apply the same procedure on each. now the combination of delta1 and delta2 reaches all possible states of NTM.&lt;/p></description></item><item><title>Problem Set 04</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/pset04/</link><pubDate>Sun, 09 Apr 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/odonnell-undergrad-post/pset04/</guid><description>&lt;h2 id="ex-1">Ex. 1&lt;/h2>
&lt;h3 id="a">a&lt;/h3>
&lt;p>Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It&amp;rsquo;s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.&lt;/p>
&lt;h3 id="b">b&lt;/h3>
&lt;p>Obviously a verifier is some input $x_0$ such that $C_1(x_0) \neq C_2(x_0)$. It&amp;rsquo;s easy to compute both circuits and check their unequal output.&lt;/p>
&lt;h2 id="ex-2">Ex. 2&lt;/h2>
&lt;p>Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree.&lt;/p></description></item><item><title>Problem Set 03</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/pset03/</link><pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/odonnell-undergrad-post/pset03/</guid><description>&lt;h2 id="ex-1">Ex. 1&lt;/h2>
&lt;p>The proof is already mentioned in sipser. We can easily reprove it using the diagonalization argument.&lt;/p>
&lt;h2 id="ex-2">Ex. 2&lt;/h2>
&lt;p>Enumerate all the two choices of a node colored in (red or blue), or colored in yellow, on all nodes. Consider the two subgraphs separately; If the yellow subgraph contains any edge reject the instance. Check if the other subgraph is 2-colorable. Only if yes, accept as the whole graph as 3-colorable.&lt;/p></description></item><item><title>Problem Set 02</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/pset02/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/odonnell-undergrad-post/pset02/</guid><description>&lt;h2 id="ex-1">Ex. 1&lt;/h2>
&lt;p>The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn&amp;rsquo;t recognizable by any turing machine.&lt;/p>
&lt;p>Let&amp;rsquo;s prove uncountability of unary languages. Observe the set $\Sigma^\*$ equals
\begin{align*}
&amp;amp;\epsilon \quad &amp;amp;s_1\\
&amp;amp;1 \quad &amp;amp;s_2\\
&amp;amp;11 \quad &amp;amp;s_3\\
&amp;amp;111 \quad &amp;amp;s_4\\
&amp;amp;.. \quad &amp;amp;..\\
\end{align*}
Any unary language is a subset of $\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite.&lt;/p></description></item><item><title>Problem Set 01</title><link>https://mostafatouny.github.io/odonnell-undergrad-post/pset01/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://mostafatouny.github.io/odonnell-undergrad-post/pset01/</guid><description>&lt;h2 id="ex-1">Ex. 1&lt;/h2>
&lt;p>skipped&lt;/p>
&lt;h2 id="ex-2">Ex. 2&lt;/h2>
&lt;h3 id="a">a&lt;/h3>
&lt;p>As the recipe is deterministic, i.e generates only one output given the same input, The assignment is valid and the function is well-defined.&lt;/p>
&lt;p>For injectivity, we prove the contrapositive; Namely, if $x_0 \neq x_1 \rightarrow f(x_0) \neq f(x_1)$. Since, $x_0 + 1 \neq x_1 + 1$, Their binary representation differs in either the number of bits or in some bit not matching. That unmatching bit cannot be the most significant bit as it&amp;rsquo;s always 1. Therefore, resulting strings, $f(x_0)$ and $f(x_1)$ are not the same.&lt;/p></description></item></channel></rss>