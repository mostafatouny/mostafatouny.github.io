
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"Currently\nResearch \u0026amp; Teaching Assistant at MSA university with Islam El-Shaarawy. CS312x Introduction to Algorithms \u0026amp; CS475 Data Mining. Auditing Modern Algebra with Daoud Siniora. Interests\nComputational Social Choice, and broadly economics \u0026amp; computation theory. Computing on and learning from non-combinatorial structures. Learning-augmented algorithms. Trustworthy and Machine Learning Theory. Vision\nThe internet revolutionized humanity’s connectivity, and AI revolutionized information flow, and yet rarely do we cooperate. Socialists have ambitions for Collective Intelligence, A paradigm of AI which enables coherent cooperation among the crowd, but it is not recognized in technical communities.\nTheoretical research of optimization, fairness, and social-choice is active on combinatorial structures, but their applicability is limited. Practitioners train predictive models on crowds’ data, but their pragmatic methods lack theoretical understanding.\nI aspire to:\nStudy social choice on structures other than combinatorics, Probably on continuous data, Expanding novel ideas, techniques, and applications. I liked Generative Social Choice.\nExtend learning-augmented algorithms on computational social choice and algorithmic game theory, Utilizing data to shed new lights on algorithmic fairness and economics. I liked Learning-Augmented Mechanism Design: Leveraging Predictions for Facility Location.\nBoth of which, Emphasized on theoretical foundations and provably guaranteed frameworks using proof and logic techniques.\nI will always be remembering Oded and Avi’s 1996 essay.\nSociety \u0026amp; Community. I am delighted to moderate TCS’s subreddit and TCS’s awesome list, Getting the chance to meet students from all over the world.\nGood Memories.\nAsking Gkatzelis about Learning-Augmentation for Voting and Fairness Chi-Ning Chou’s Minicourse (course details here) COLT 2021 Mentorship Workshop Rahul Llango’s talk, Towards Hardness for the Minimum Circuit Size Problem qEgypt’s First Workshop on Quantum Computing My Poly Hong Kong Talk Toric Quantum Error Correction Codes, Quantum Discord Server Honors Linear Algebra, UCLA 4-player chess with Ewin Tang, Kuikui Liu, and Ansh Nagda. Yael Kalai’s QnA on obfuscation’s breakthrough. FOCS 2020 (I was granted registration fee waiver). see: 1, 2, 3, 4. I learned about it through twitter. Scott Aaronson’s QnA. Family. Mum \u0026amp; Dad (Lawyer), Brother (Athlete Coach), Sister (Passed out aged 14).\nNon-Serious. If I am not doing any serious work, I would probably be listening to Taylor Davis.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Currently\nResearch \u0026 Teaching Assistant at MSA university with Islam El-Shaarawy. CS312x Introduction to Algorithms \u0026 CS475 Data Mining. Auditing Modern Algebra with Daoud Siniora. Interests\nComputational Social Choice, and broadly economics \u0026 computation theory.","tags":null,"title":"Mostafa Touny","type":"authors"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 1 No. The statement holds if and only if $x$ is not integer. For example $\\lceil 1 \\rceil = 1 \\neq 1 + \\lfloor 1 \\rfloor = 2$.\nLet $x = z + y$ where $z$ is integer and $0 \u0026lt; y \u0026lt; 1$. Then $\\lceil x \\rceil = z + 1 = \\lfloor x \\rfloor + 1$.\n","date":1706054400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1706054400,"objectID":"c1f3c01125b9b9aa2326a679a7e9622c","permalink":"https://mostafatouny.github.io/vraj-kni-post/ch02-sec01/","publishdate":"2024-01-24T00:00:00Z","relpermalink":"/vraj-kni-post/ch02-sec01/","section":"vraj-kni-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 1 No. The statement holds if and only if $x$ is not integer. For example $\\lceil 1 \\rceil = 1 \\neq 1 + \\lfloor 1 \\rfloor = 2$.","tags":null,"title":"Chapter 02 - Section 01","type":"vraj-kni-post"},{"authors":null,"categories":null,"content":"Exercises B Ex. 2 $(\\rightarrow)$ Trivial.\n$(\\leftarrow)$ Consider $$ v_i = \\begin{bmatrix} 0 \\\\ \\vdots \\\\ 1 \\\\ \\vdots \\\\ 0 \\end{bmatrix} $$ Where only ith position is $1$. Then \\begin{align*} (Av_i)[Col \\ i] \u0026amp;= (Bv_i)[Col \\ i] \\quad \\text{By hypothesis} \\\\ \u0026amp;= A[Col \\ i] \\quad \\text{Multiplication by 1} \\end{align*} Then it follows $A[Col \\ i] = B[Col \\ i]$ for all $i$.\n","date":1705795200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1705795200,"objectID":"853e7127f59bf216dd63057730da5d7a","permalink":"https://mostafatouny.github.io/henry-linear-post/ch03-sec02/","publishdate":"2024-01-21T00:00:00Z","relpermalink":"/henry-linear-post/ch03-sec02/","section":"henry-linear-post","summary":"Exercises B Ex. 2 $(\\rightarrow)$ Trivial.\n$(\\leftarrow)$ Consider $$ v_i = \\begin{bmatrix} 0 \\\\ \\vdots \\\\ 1 \\\\ \\vdots \\\\ 0 \\end{bmatrix} $$ Where only ith position is $1$. Then \\begin{align*} (Av_i)[Col \\ i] \u0026= (Bv_i)[Col \\ i] \\quad \\text{By hypothesis} \\\\ \u0026= A[Col \\ i] \\quad \\text{Multiplication by 1} \\end{align*} Then it follows $A[Col \\ i] = B[Col \\ i]$ for all $i$.","tags":null,"title":"Chapter 03 - Section 02","type":"henry-linear-post"},{"authors":null,"categories":null,"content":"Materials Book: Henry Ricardo. A Modern Introduction to Linear Algebra. CRC. Problem Set Chapter Content Chapter 03, Section 02 PDF, HTML Chapter 04, Section 05 PDF, HTML ","date":1705795200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1705795200,"objectID":"fc1fbb63161052e160c145e3cb11f30f","permalink":"https://mostafatouny.github.io/post/henry-linear-pset/","publishdate":"2024-01-21T00:00:00Z","relpermalink":"/post/henry-linear-pset/","section":"post","summary":"Self-studying linear algebra by Henry","tags":null,"title":"Henry's Linear Algebra","type":"post"},{"authors":null,"categories":null,"content":"Exercises B Ex. 1 If $A$ is diagonalizable, then $A = P^{-1} D P$ for some diagonal matrix $D$. It follows \\begin{aligned} A^T \u0026amp;= (P^{-1} D P)^T \\\\ \u0026amp;= P^T D^T (P^{-1})^T \\\\ \u0026amp;= Q D Q^{-1} \\end{aligned} Where we defined $Q = P^T$.\nEx. 2 If $A$ is diagonal, then $A = P^{-1} D P$ for some diagonal matrix $D$. It follows \\begin{aligned} A^{-1} \u0026amp;= (P^{-1} D P)^{-1} \\\\ \u0026amp;= P^{-1} D^{-1} P \\\\ \u0026amp;= P^{-1} D P \\end{aligned}\n","date":1705363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1705363200,"objectID":"82370e78181bdd22208445609d02e449","permalink":"https://mostafatouny.github.io/henry-linear-post/ch04-sec05/","publishdate":"2024-01-16T00:00:00Z","relpermalink":"/henry-linear-post/ch04-sec05/","section":"henry-linear-post","summary":"Exercises B Ex. 1 If $A$ is diagonalizable, then $A = P^{-1} D P$ for some diagonal matrix $D$. It follows \\begin{aligned} A^T \u0026= (P^{-1} D P)^T \\\\ \u0026= P^T D^T (P^{-1})^T \\\\ \u0026= Q D Q^{-1} \\end{aligned} Where we defined $Q = P^T$.","tags":null,"title":"Chapter 04 - Section 05","type":"henry-linear-post"},{"authors":null,"categories":null,"content":"Materials Book: Bartle \u0026amp; Sherbert. Introduction to Real Analysis. Wiley. Problem Set Chapter Content Chapter 08, Section 01 PDF, HTML Chapter 10, Section 01 PDF, HTML ","date":1704844800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704844800,"objectID":"ee6fd4e754b0589917d8b88fa67a5b40","permalink":"https://mostafatouny.github.io/post/bartle-analysis-pset/","publishdate":"2024-01-10T00:00:00Z","relpermalink":"/post/bartle-analysis-pset/","section":"post","summary":"Self-studying real analysis by Bartle \u0026 Sherbert","tags":null,"title":"Bartle \u0026 Sherbert's Real Analysis","type":"post"},{"authors":null,"categories":null,"content":"Exercises Ex. 11 For $f_n(x) = \\frac{\\displaystyle{x}}{\\displaystyle{x+n}}$, and $f = 0$, Clearly\n$||f_n - f ||_{[0,a]} = ||f_n||_{[0,a]} = \\frac{\\displaystyle{a}}{\\displaystyle{a+n}}$. But $\\lim_{n \\rightarrow \\infty} \\frac{\\displaystyle{a}}{\\displaystyle{a+n}} = 0$. Hence by lemma 8.1.8 (page 244), The uniform convergence on $[0,a]$ follows.\nWe follow Lemma 8.1.5 (page 244). Consider subsequences $n_k = x_k = k$. Then $f_{n_k}(x_k) = \\frac{\\displaystyle{k + k}}{\\displaystyle{k}} = \\frac{\\displaystyle{1}}{\\displaystyle{2}}$. Therefore $|f_{n_k}(x_k) - f(x_k)| = |f_{n_k}(x_k)| = \\frac{\\displaystyle{1}}{\\displaystyle{2}} = \\epsilon_0$.\nEx. 18 We use lemma 8.1.8 (page 244). Note $f_n(x) = xe^{-nx}$ and $f = 0$. Then $||f_n - f||{[0,\\infty)} = ||f_n||{[0,\\infty)} = 1/n$.\nTo see why, Observe $f_n’(x) = (e^{-nx})(1-nx)$, and setting $f_n’(x) = 0$ yields local max/min at $x = 0$ and $x = 1/n$. That justifies the supremum we aforementioned.\nBut $\\lim_{n \\rightarrow \\infty} 1/n = 0$, Concluding uniform convergence.\nEx. 21 Observe $| (f_n(x) + g_n(x) ) - ( f(x) + g(x) ) | \\leq |f_n(x) - f(x)| + |g_n(x) - g(x)| \u0026lt; \\epsilon/2 + \\epsilon/2 = \\epsilon$, Following by the triangle inequality.\n","date":1704844800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704844800,"objectID":"086dcaa5181319421c1b216c8e87ec3c","permalink":"https://mostafatouny.github.io/bartle-analysis-post/ch08-sec01/","publishdate":"2024-01-10T00:00:00Z","relpermalink":"/bartle-analysis-post/ch08-sec01/","section":"bartle-analysis-post","summary":"Exercises Ex. 11 For $f_n(x) = \\frac{\\displaystyle{x}}{\\displaystyle{x+n}}$, and $f = 0$, Clearly\n$||f_n - f ||_{[0,a]} = ||f_n||_{[0,a]} = \\frac{\\displaystyle{a}}{\\displaystyle{a+n}}$. But $\\lim_{n \\rightarrow \\infty} \\frac{\\displaystyle{a}}{\\displaystyle{a+n}} = 0$. Hence by lemma 8.","tags":null,"title":"Chapter 08 - Section 01","type":"bartle-analysis-post"},{"authors":null,"categories":null,"content":"Exercises 1 a By definition of a gauge, we have \\begin{aligned} t_i - \\delta(t_i) \u0026amp;\\leq x_{i-1} \\\\ x_i \u0026amp;\\leq t_i + \\delta(t_i) \\end{aligned} Implying, \\begin{aligned} x_i - x_{i-1} \\leq t_i + \\delta(t_i) - x_{i-1} \\\\ -t_i + \\delta(t_i) \\geq -x_{i-1} \\end{aligned} Concluding for all $i \\in { 1,2, \\dots, n }$, \\begin{aligned} x_i - x_{i-1} \u0026amp;\\leq t_i + \\delta(t_i) - t_i + \\delta(t_i) \\\\ \u0026amp;\\leq 2 \\delta(t_i) \\end{aligned}\nb Clearly $x_i - x_{i-1} \\leq 2 \\delta^*$ for all $i \\in {1, 2, \\dots, n}$. Then $\\max \\\\{x_i - x_{i-1}\\\\} = ||\\dot{p}|| \\leq 2 \\delta^*$.\nc $\\max \\{ x_i - x_{i-1} \\} \\leq \\delta_* = inf \\{ \\delta(t) \\}$. Then $x_i - x_{i-1} \\leq \\delta_*$ \\begin{aligned} x_i \u0026amp;\\leq \\delta(t_i) + x_{i-1} \\\\ \u0026amp;\\leq \\delta(t_i) + t_i \\qquad \\text{by def } x_{i-1} \\leq t_i \\\\ \\end{aligned} Analogously, \\begin{aligned} x_{i-1} \u0026amp;\\geq - \\delta_*(t_i) + x_i \\\\\\\\ \u0026amp;\\geq - \\delta_*(t_i) + t_i \\qquad \\text{by def } x_i \\geq t_i \\end{aligned} Therefore, $[x_{i-1}, x_i] \\subset [ t_i - \\delta(t_i), t_i + \\delta(t_i) ]$, i.e $Q$ is $\\delta-$fine.\nd 2 a Observe for interval $[x_{i-1}, x_i]$ for any partition, \\begin{aligned} \\forall i,j, \\quad [x_{i-1}, x_i] \\cap [x_{j-1}, x_j] = \\begin{cases} [x_{i-1}, x_i]\\qquad \u0026amp; i = j \\\\\\\\ \\{ x_i \\} \\qquad \u0026amp;j = i + 1 \\\\\\\\ \\{ x_{i-1} \\} \\qquad \u0026amp;j= i - 1 \\\\\\\\ \\phi \\qquad \u0026amp;\\text{otherwise} \\end{cases} \\end{aligned} It is easy to see considering any third interval containing a point $x$, necessarily implies two intervals share an intermediary point, violating the partitioning condition.\nb Yes. For example, on $[0,1]$, we have the partition: \\begin{aligned} \u0026amp;([0, 1/4], 1/4), \\\\ \u0026amp;([1/4, 1/2], 1/4), \\\\ \u0026amp;([1/2, 3/4], 3/4), \\\\ \u0026amp;([3/4, 1], 3/4) \\end{aligned}\n3 a For every intervals $I_1, I_2$ with a common tag $t_1 = t_2$, subtitute them by a single interval $I$ with tag $t = t_1 = t_2$.\nClearly $S(f,{I}) = S(f, {I_1, I_2})$.\nb Yes.\nc For every interval $I$ with a tag $t$ contained only in it, Partition $I$ to $I_1, I_2$ separated at $t$, with tags $t_1 = t_2 = t$.\n4 a Let $I$ be an interval containing $1$. Denote its tag by $t = 1 + x$. As both $1$ and $1 + x$ are in $I$, $|I| \\geq x$. But by definition $\\delta(t) = \\delta(1+x) = 0.5 x \u0026lt; x$, Contradiction. Therefore the tag of $I$ is necessarily $1$.\nb At maximum two intervals $I_1$ and $I_2$ can contain $1$. From a, their tags are $t_1 = t_1 = 1$. By definition $\\delta(1) = 0.01$, So $|I_1| + |I_2| \\leq 0.01 + 0.01 = 0.02$.\n","date":1704844800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704844800,"objectID":"a4eecd458dcea2fdb227071b02b7a19c","permalink":"https://mostafatouny.github.io/bartle-analysis-post/ch10-sec01/","publishdate":"2024-01-10T00:00:00Z","relpermalink":"/bartle-analysis-post/ch10-sec01/","section":"bartle-analysis-post","summary":"Exercises 1 a By definition of a gauge, we have \\begin{aligned} t_i - \\delta(t_i) \u0026\\leq x_{i-1} \\\\ x_i \u0026\\leq t_i + \\delta(t_i) \\end{aligned} Implying, \\begin{aligned} x_i - x_{i-1} \\leq t_i + \\delta(t_i) - x_{i-1} \\\\ -t_i + \\delta(t_i) \\geq -x_{i-1} \\end{aligned} Concluding for all $i \\in { 1,2, \\dots, n }$, \\begin{aligned} x_i - x_{i-1} \u0026\\leq t_i + \\delta(t_i) - t_i + \\delta(t_i) \\\\ \u0026\\leq 2 \\delta(t_i) \\end{aligned}","tags":null,"title":"Chapter 10 - Section 01","type":"bartle-analysis-post"},{"authors":null,"categories":null,"content":"Materials Book: Linear Algebra Done Right by Sheldon Axler, 3rd ed. Exercises Section Source Solution Ch. 03, Sec. E Page 98 PDF, HTML Ch. 07, Sec. A Page 214 PDF, HTML Ch. 07, Sec. B Page 223 PDF, HTML ","date":1704672000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704672000,"objectID":"b658240abaedc017328ef258d36eb5a4","permalink":"https://mostafatouny.github.io/post/axler-linear-pset/","publishdate":"2024-01-08T00:00:00Z","relpermalink":"/post/axler-linear-pset/","section":"post","summary":"Self-studying Linear Algebra by Sheldon Axler.","tags":null,"title":"Axler's Linear Algebra","type":"post"},{"authors":null,"categories":null,"content":"Exercises Ex. 02 It follows immediately by dimension of a product theorem (page 92), As any $dim V_j$ must be upper-bounded by a finite number.\n","date":1704672000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704672000,"objectID":"8770e4508b2f03725b1f6c565c67be89","permalink":"https://mostafatouny.github.io/axler-linear-post/ch03-sece/","publishdate":"2024-01-08T00:00:00Z","relpermalink":"/axler-linear-post/ch03-sece/","section":"axler-linear-post","summary":"Exercises Ex. 02 It follows immediately by dimension of a product theorem (page 92), As any $dim V_j$ must be upper-bounded by a finite number.","tags":null,"title":"Ch. 03, Sec. E","type":"axler-linear-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 3 Fact. Given a set $A$ of distinct elements in a random order, The positition of the maximum element of a subset $S \\subset A$ is uniform in $S$.\nDefine indicator random variables $L_i$ as $$ L_i = \\begin{cases} 1 \u0026amp; a_i \u0026gt; a_{i-1}, a_{i-2}, \\dots, a_{1} \\\\ 0 \u0026amp; a_i \u0026lt; a_j, \\text{ for some } j = 1,2, \\dots, i-1 \\end{cases} $$ So $L_i = 1$ if and only if the ith item $a_i$ is the maximum in subset $A[1:i]$.\nIt follows $Pr[L_i = 1] = 1/i$ and $Ex[Li] = 1/i$.\nLet $X$ be a random variable for the number of times the line a[first] \u0026gt; a[max_loc] returns True. Observe $X = L_2 + L_3 + \\dots + L_n$. So $Ex[X] = 1/2 + \\dots + 1/n = H(n) - 1 \\approx \\ln n - 1$.\n$H(n)$ here is the nth harmonic sum.\n4 a Note. Our solution was initially flawed until we read the description of exercise 6 which gave the correct answer. We only reconstructred the proof given the answer.\nFact 1. On the ith step of the first pass of bubble-sort, $A[i]$ is the maximum element among $A[0:i]$.\nFact 2. Given $A$ is a set of distinct elements in a random order, The probability of $A[i]$ being the maximum element of $A[0:i]$ is $\\frac{\\displaystyle{1}}{\\displaystyle{i+1}}$.\nLet $R_i$ be an indicator random variable, Indicating whether $A[i] \u0026gt; A[i+1]$, at the ith step of the loop. From Fact 1, $R_i = 1$ if and only if $A[i+1]$ is not the maximum among $A[0:i+1]$. The probability of that event is $\\frac{\\displaystyle{i+1}}{\\displaystyle{i+2}}$ from Fact 2.\nClearly $Ex[R_i] = \\frac{\\displaystyle{i+1}}{\\displaystyle{i+2}}$. It follows $W = \\sum_{i=0}^{n-2} R_i = \\frac{\\displaystyle{1}}{\\displaystyle{2}} + \\frac{\\displaystyle{2}}{\\displaystyle{3}} + \\dots + \\frac{\\displaystyle{n-1}}{\\displaystyle{n}} = (n-1) - \\left ( \\nfrac{1}{2} + \\nfrac{1}{3} + \\dots + \\nfrac{1}{n} \\right ) = n - 1 - H_n + 1 \\approx n - \\lg n$.\nb That event happens if and only if\n$max(A[1], A[2]) \u0026lt; A[3]$. Its probability is $\\frac{\\displaystyle{2}}{\\displaystyle{3}}$. Or $max(A[1], A[2]) \u0026gt; A[3]$ and $A[1] \u0026lt; A[3]$. Its probability is $\\frac{\\displaystyle{1}}{\\displaystyle{3}} \\cdot \\frac{\\displaystyle{1}}{\\displaystyle{2}} = \\frac{\\displaystyle{1}}{\\displaystyle{6}}$. So the probability $A[1] \u0026lt; A[2]$ after the first pass of bubble-sort is $\\frac{\\displaystyle{2}}{\\displaystyle{3}} + \\frac{\\displaystyle{1}}{\\displaystyle{6}} = \\frac{\\displaystyle{4}}{\\displaystyle{6}} = \\frac{\\displaystyle{2}}{\\displaystyle{3}}$.\n5 Fact. Given a randomly ordered $A$, Any $A[:K]$ is also randomly ordered.\nFact. Uniformly $A[k] \\in { q_1, q_2, \\dots, q_k }$ where $q_i \\in A[:k]$ and $q_1 \u0026gt; q_2 \u0026gt; \\dots \u0026gt; q_k$.\nIn kth iteration, $A[1:k-1]$ is sorted, and $A[k]$ will be uniformly displaced to\nposition $k, k-1, \\dots, 1$. Respectively, #comparisons $= 1,2, \\dots, k$. Respectively, #assignments $= 0, 1, \\dots, k-1$. Denote total number of comparisons by $C$ and comparisons in kth iteration by $C_k$. Similarly $A$ and $A_k$ for assignments. In expectation \\begin{aligned} Ex[C_k] \u0026amp;= \\nfrac{1}{k} (1 + \\dots + k) = \\nfrac{1}{k} \\nfrac{k \\cdot k+1}{2} = \\nfrac{k+1}{2} \\\\ Ex[A_k] \u0026amp;= \\nfrac{1}{k} (1 + \\dots + k-1) = \\nfrac{1}{k} \\nfrac{(k-1)k}{2} = \\nfrac{k-1}{2} \\end{aligned} Clearly $C = \\sum_{k=2}^n C_k$ and $A = \\sum_{k=2}^n A_k$. So \\begin{aligned} Ex[C] \u0026amp;= \\sum_{k=2}^n \\nfrac{k+1}{2} \\\\ \u0026amp;= \\nfrac{1}{2} \\sum_{k=2}^n k+1 \\\\ \u0026amp;= \\nfrac{1}{2} \\left [ ( \\sum_{k=1}^{n+1} k) - 1 - 2 \\right ] \\\\ \u0026amp;= \\nfrac{1}{2} \\left [ \\nfrac{(n+1)(n+2)}{2} - 3 \\right ] \\\\ \u0026amp;= \\nfrac{(n+1)(n+2)}{4} - \\nfrac{3}{2} \\\\ Ex[A] \u0026amp;= \\sum_{k=2}^n \\nfrac{k-1}{2} \\\\ \u0026amp;= \\nfrac{1}{2} \\sum_{k=2}^n k-1 \\\\ \u0026amp;= \\nfrac{1}{2} \\sum_{k=1}^{n-1} k \\\\ \u0026amp;= \\nfrac{1}{2} \\nfrac{n(n-1)}{2} \\\\ \u0026amp;= \\nfrac{n(n-1)}{4} \\end{aligned}\n6 The fact $Ex[W_n] = n - H(n)$ rests on the assumption array $A$ is randomly ordered. That is not the case after the first pass. This is clear from our answer in Ex. 4, b.\n9 Fact 1. The number of comparisons took by the algorithm is decided by the smaller-position target.\nFact 2. Given $A$ is randomly ordered, target $t_1$ is uniform among all $n$ positions, and target $t_2$ is uniform among all remaining $n-1$ positions.\nFact 3. Since we are operating on remaining $n-1$ positions, The choice of $t_1$ is irrelevant. In other words the two events independent.\nLet $R$ be the number of algorithm’s comparisons. Let $W$ be the position of smaller-position target. By Fact 1 $R = W+1$. Observe $Pr[W=0] = Pr[R=1] = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot \\frac{\\displaystyle{n-1}}{\\displaystyle{n-1}}$, $Pr[W=1] = Pr[R=2] = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot \\frac{\\displaystyle{n-2}}{\\displaystyle{n-1}}$\nGenerally, for $k \\in { 0, 1, \\dots, n-1 }$, $Pr[R=k] = \\frac{\\displaystyle{n-k}}{\\displaystyle{n-1}}$. So by definition, \\begin{aligned} Ex[R] \u0026amp;= \\sum_{k=1}^{n-1} i \\cdot \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot \\frac{\\displaystyle{n-i}}{\\displaystyle{n-1}} \\\\ \u0026amp;= \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot …","date":1704672000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704672000,"objectID":"b9bb05e294fa7142e4d75a51ba6c0c2b","permalink":"https://mostafatouny.github.io/vraj-kni-post/ch06-sec07/","publishdate":"2024-01-08T00:00:00Z","relpermalink":"/vraj-kni-post/ch06-sec07/","section":"vraj-kni-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 3 Fact. Given a set $A$ of distinct elements in a random order, The positition of the maximum element of a subset $S \\subset A$ is uniform in $S$.","tags":null,"title":"Chapter 06 - Section 07","type":"vraj-kni-post"},{"authors":null,"categories":null,"content":"Materials Book: Vrajitoru \u0026amp; Knight. Practical Analysis of Algorithms. Springer. Problem Set Chapter Content Chapter 02, Section 01 PDF, HTML Chapter 06, Section 07 PDF, HTML ","date":1704153600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704153600,"objectID":"e5750966a974df1f3f66cfbc1c7b4583","permalink":"https://mostafatouny.github.io/post/vraj-kni-pset/","publishdate":"2024-01-02T00:00:00Z","relpermalink":"/post/vraj-kni-pset/","section":"post","summary":"Self-studying probabilistic analysis of algorithms by Vrajitoru \u0026 Knight","tags":null,"title":"Vrajitoru \u0026 Knight's Probabilistic Analysis of Algorithms","type":"post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 01 False. If there is a basis consisting of eigenvectors of $T$, Then $M(T)$ is diagonal. It follows $M(T) M(T)^* = M(T)^* M(T)$, Equivalently $TT^* = T^*T$, So $T$ is self-adjoint.\nEx. 02 Assume $F = \\mathbb{R}$.\nObservation. $p(x) = x^2 -5x + 6 = (x-2)(x-3)$. $p(T) = T^2 -5T + 6I = (T-2I)(T-3I)$\nThe goal is $p(T) = 0$. It suffices to show $p(T)v = 0$ for any vector $v$.\nBy Real Spectral Theorem (p. 221), There is a basis of eigenvectors of $T$ corresponding to eigenvalues $\\lambda_1, .., \\lambda_n$. By hypothesis we know $\\lambda_i = 2$ or $\\lambda_i = 3$.\nLet $v$ be an arbitrary vector $v$. Then $v = a_1v_1 + \\dots + a_nv_n$. Observe $p(T)(v) = p(T)(a_1v_1) + \\dots + p(T)(a_nv_n) = a_1p(\\lambda_1)v_1 + \\dots + a_np(\\lambda_n)v_n$. But $p(\\lambda_i) = 0$, so $p(T)v = 0$.\n","date":1704067200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704067200,"objectID":"16fc05d41de47c769dc3a20deb1a6d1e","permalink":"https://mostafatouny.github.io/axler-linear-post/ch07-secb/","publishdate":"2024-01-01T00:00:00Z","relpermalink":"/axler-linear-post/ch07-secb/","section":"axler-linear-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 01 False. If there is a basis consisting of eigenvectors of $T$, Then $M(T)$ is diagonal. It follows $M(T) M(T)^* = M(T)^* M(T)$, Equivalently $TT^* = T^*T$, So $T$ is self-adjoint.","tags":null,"title":"Ch. 07, Sec. B","type":"axler-linear-post"},{"authors":null,"categories":null,"content":"Problems 1 We use Theorem 9.1 (page 175) to show the answer is NO. $(2 3) \\in S_3$ and yet, $(2 3)H(2 3) = { (2 3)(1)(2 3), (2 3)(1 2)(2 3) } = { (1), (1 3)} \\not\\subset H$.\n2 We use Theorem 9.1 (page 174). We know from earlier chapters, $A_n$ is a subgroup of $S_n$. Then for any $x \\in S_n$ and any $h \\in A_n$, we get a permutation $xhx^{1}$ consisting of even 2-cycles. To see why, Observe we know $x^{-1}$ has the same number of 2-cycles as $x$. Whether $x$ consists of even or odd number of 2-cycles, The contribution of 2-cycles of both $x$ and $x^{-1}$ is even.\n6 NO. It suffices to take some matrix $h \\in H$ and a matrix $x \\in GL(2,R)$, and show $xhx^{-1} \\not\\in H$. Clearly:\n$$ \\begin{bmatrix} 2 \u0026amp; 1 \\\\ 1 \u0026amp; 2 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026amp; 1 \\\\ 1 \u0026amp; 2 \\end{bmatrix}^{-1} \\\\ = \\begin{bmatrix} 2 \u0026amp; 1 \\\\ 1 \u0026amp; 2 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 2/3 \u0026amp; -1/3 \\\\ -1/3 \u0026amp; 2/3 \\end{bmatrix} = \\begin{bmatrix} 4/3 \u0026amp; -1 \\\\ -1/3 \u0026amp; 2 \\end{bmatrix} \\not\\in H $$\n8 We immediately prove the general case of $\\langle k \\rangle / \\langle n \\rangle \\cong \\mathcal{Z}_{n/k}$, given $k$ divides $n$.\nFor arbitrary two elements of under the operation: \\begin{aligned} (k^a \\langle n \\rangle) (k^b \\langle n \\rangle) \u0026amp;= k^{a+b} \\langle n \\rangle \\qquad \u0026amp;\\text{Definition} \\\\ \u0026amp;= k^{\\frac{n}{k} q + r} \\langle n \\rangle, 0 \\leq r \u0026lt; n/k \\qquad \u0026amp;\\text{Euclidean Division} \\\\ \u0026amp;= k^{\\frac{n}{k} q} k^r \\langle n \\rangle \\\\ \u0026amp;= k^r (k^{\\frac{n}{k} q} \\langle n \\rangle) \\qquad \u0026amp;\\text{Commutativity and Associativity of $\\mathcal{Z}$} \\\\ \u0026amp;= k^r (n \\langle n \\rangle) \\\\ \u0026amp;= k^r \\langle n \\rangle \\end{aligned}\nBut in $\\mathcal{Z}_{n/k}$, $ab = a + b \\mod \\frac{n}{k}$, which corresponds to $(k^a \\langle n \\rangle) (k^b \\langle n \\rangle) = k^{a + b \\mod r} \\langle n \\rangle$.\n9 Fact. Citing from the course TA, Ibrahim, left/right cosets parition the group $G$. (msh naseek ya bob).\nSince the index is given to be $2$, We know $G/H = { H, g_0 H } = { H, Hg_0}$.\nConsider arbitrary $x \\in G$. If $x \\in H$ then $xH = H = Hx$ from Lemma (page 139). If $x \\not\\in H$, Then $x \\in g_0H$ and $x \\in Hg_0$ by our Fact. It follows $g_0h_0 = x = h_1g_0$ for some $h_0, h_1 \\in H$, and in turn $xH = g_0H = Hg_0 = Hx$.\nIt follows $H$ is normal.\n10 (a).\nBy Theorem 9.1 (page 175), We construct $xhx^{-1} \\not\\in H$ for some $x \\in A_4$ and $h \\in H$.\nLet $h = (1 2)(3 4)$ and $x = (1 3)(2 3)$. Then $x^{-1} = (2 3)(1 3)$, and in turn $xhx^{-1} = (1 3)(2 3)(1 2)(3 4)(2 3)(1 3)$. In other notation,\n$$ xhx^{-1} = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\\\ 3 \u0026amp; 4 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix} \\neq (1 2)(3 4) $$\n12 For arbitrary abelian group $G$ with elements $a_0$ and $a_1$, and factor group $G/H$, We have: \\begin{aligned} (a_0 H)(a_1 H) \u0026amp;= (a_0 a_1) H \\qquad \u0026amp;\\text{Definition} \\\\ \u0026amp;= (a_1 a_0) H \\qquad \u0026amp;\\text{$G$ is Abelian} \\\\ \u0026amp;= (a_1 H)(a_0 H) \\end{aligned}\n14 We know the identity of $\\mathcal{Z}_{24}/ \\langle 8 \\rangle$ is $0 + \\langle 8 \\rangle$. We are looking for smallest $k$ satisfying \\begin{aligned} (14 + \\langle 8 \\rangle)^k \u0026amp;= 0 + \\langle 8 \\rangle \\\\ 14^k + \\langle 8 \\rangle \u0026amp;= \\end{aligned} Thanks for the course TA, Ibrahim, That can be satisfied while $14^k \\neq 0$.\nFrom the lemma (page 139), This is true if and only if $14^k \\in \\langle 8 \\rangle$. In other words, We want smallest positive $k$, such that $14^k = 8^m$ for some integer $m$. By computation, $k = 3$ as $14^3 = 8$.\n22 Observe $(Z \\oplus Z) / \\langle (2,2) \\rangle = \\{ (0,0)+\\langle (2,2) \\rangle, (0,1)+\\langle (2,2) \\rangle), (1,0)+\\langle (2,2) \\rangle, (1,1)+\\langle (2,2) \\rangle \\}$.\nTo see why consider arbitrary $(a,b) \\in Z \\oplus Z$ and apply Euclid’s division theorem to get $a = 2k_0 + r_0$ and $b = 2k_1 +r_1$ where $0 \\leq r_0,r_1 \u0026lt; 2$.\nThen the order is $4$.\nIt is not cyclic as no single $(a,b)$ can generate all of $(0,0), (0,1), (1,0), (1,1)$.\n37 Recall the notation of $|g|$ as the order of element $g$. By definition $g^{|g|} = 0$. Then $(gH)^{|g|} = g^{|g|}H = H$. By Corollary 2 (page 77), $|gH|$ divides $|g|$.\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"377db0d74c23957f1427385b6d80c43b","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset09/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset09/","section":"siniora-algebra-post","summary":"Problems 1 We use Theorem 9.1 (page 175) to show the answer is NO. $(2 3) \\in S_3$ and yet, $(2 3)H(2 3) = { (2 3)(1)(2 3), (2 3)(1 2)(2 3) } = { (1), (1 3)} \\not\\subset H$.","tags":null,"title":"Chapter 09","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 8 Homomorphism. If $\\sigma_1$ and $\\sigma_2$ are both even or both odd, then $\\sigma_1 \\sigma_2$ is even and $sgn(\\sigma_1) sgn(\\sigma_2) = 1$. If one of them is even and the other is odd, then $\\sigma_1 \\sigma_2$ is odd and $sgn(\\sigma_1) sgn(\\sigma_2) = 1 * -1 = -1$.\nKernel. $Ker , sgn$ is the subgroup of even permutations of $G$.\n$A_n$ is a normal subgroup of $S_n$. When $G = S_n$, $Ker , sgn = A_n$. By corollary (page 198), $Ker , sgn$ is a normal subgroup.\nEx 23 in Ch 05. Now consider the homomorphism $sgn$ on arbitrary subgroup $H$. We know the identity must be $sgn(H)$. If $sgn(H) = { 1 }$ then all permutations of H are even. Otherwise $sgn(H) = { 0, 1}$. By property 5 in theorem 10.2 (page 197), we have n-to-1 mapping from even permutations, and n-to-1 mapping from odd permutations. Hence exactly half of $H$ are even.\n12 By definition, $Z_n/\\langle k \\rangle = { x + \\langle k \\rangle \\mid x \\in \\mathcal{Z}_n }$. But by Euclid’s Division, $x + \\langle k \\rangle = (kq + r) + \\langle k \\rangle = r + (kq + \\langle k \\rangle) = r + \\langle k \\rangle$. It follows $\\mathcal{Z}_n / \\langle k \\rangle = { x + \\langle k \\rangle \\mid x \\in \\mathcal{Z}_k }$.\nNow define $\\phi: \\mathcal{Z}_n / \\langle k \\rangle \\rightarrow \\mathcal{Z}_k$ by $\\phi(x + \\langle k \\rangle) = x$. It is injective as $\\phi(x + \\langle k \\rangle) = \\phi(y + \\langle k \\rangle)$ implies $x = y$. Surjective as for any $y \\in \\mathcal{Z}_k$ we have $\\phi(y + \\langle k \\rangle = y$. Finally it preservers the operation as $\\phi(x + \\langle k \\rangle) + \\phi(y + \\langle k \\rangle) = x + y = \\phi( (x+y) + \\langle k \\rangle )$.\n15 Let $x$ be arbitrary such that $\\phi(x) = 9$. Then \\begin{aligned} \\phi(x) - \\phi(23) \u0026amp;= 9 - 9 = 0 \\\\ \\phi(x - 23) \u0026amp;= 0 \\\\ x - 23 \u0026amp;\\in \\{ 0, 10, 20 \\} \\\\ x + 7 \u0026amp;\\in \\{ 0, 10, 20 \\} \\\\ x \u0026amp;\\in \\{ 23, 3, 13 \\} \\end{aligned}\n16 Let $\\phi$ be an arbitrary homomorphism.\nSince both $\\mathcal{Z}_8 \\oplus \\mathcal{Z}_2$ and $\\mathcal{Z}_4 \\oplus \\mathcal{Z}_4$ have exactly 16 elements, the surjectivity of homomorphism $\\phi$ implies isomorphism.\nRecall property 5, of Theorem 6.2 (page 126) which states isomorphism preserves orders. So $8 = |(1,0)| = |\\phi(1,0)|$. So there is some element in $\\mathcal{Z}_4 \\oplus \\mathcal{Z}_4$ which is of order 8. Contradiction.\nObserve all elements of $Z_4$ are of orders $1,2,4$. Since all of them divides $4$, The order of any element of $\\mathcal{Z}_4 \\oplus \\mathcal{Z}_4$ is at most $4$.\n20 (1). $\\mathcal{Z}_{20}$ onto $\\mathcal{Z}_8$.\nLet $\\phi$ be an arbitrary homomorphism. By surjectivity we know $\\phi(\\mathcal{Z}_{20}) = \\mathcal{Z}_8$. By theorem 10.2, 5 (page 197), $20$ is a multiple of $8$. Contradiction. It follows the number of homomorphisms is zero.\nP.S. The TA Ibrahim notified me Math is not about hacking puzzles but seeing the structure behind. He told me an alternative proof by cosets and quotient groups. For academic integrity I present the proof I discovered on my own.\n(2). $\\mathcal{Z}_{20}$ to $\\mathcal{Z}_8$.\nLet $\\phi: \\mathcal{Z}_{20} \\rightarrow \\mathcal{Z}_8$ be an arbitrary homomorphism. We follow the procedure of example 10 (page 199). Let $\\phi(1) = a$. Then $|a|$ divides both $20$ and $8$. It follows $|a| \\in {1, 2, 4}$ and in turn $a \\in { 0, 2, 4, 6 }$. Since $\\phi(1)$ decides the homomorphism, There are 4 possible homomorphisms.\n24 (a). In light of property 2 of theorem 10.1 (page 196), Observe $6 = \\phi(7) = \\phi(7 \\cdot 1) = 7 \\cdot \\phi(1)$. But $13 \\cdot 7 \\mod 15 = 1$. It follows $\\phi(1) = 13 \\cdot 6 = 3$. Therefore $\\phi(x) = \\phi(1 \\cdot x) = \\phi(1) \\cdot x = 3x$.\n(b). The image is all multiples of 3 strictly less than 15.\n(c). By definition we are looking for $x \\in \\mathcal{Z}_{50}$ such that $\\phi(x) = 3x = 0$. But $3x \\equiv 0$ if and only if $3x - 0 = 3x$ is a multiple of $15$ if and only if $x = 5i$. In other words the kernel are multiples of 5 strictly less than $50$.\n(d). We want to characterize $x$ such that $\\phi(x) = 3$. But by definition we know $\\phi(x) = 3x$. Then \\begin{aligned} 3 \u0026amp;\\equiv 3x \\mod 15 \\\\ 3x - 3 \u0026amp;= 15i \\\\ x - 1 \u0026amp;= 5i \\\\ x \u0026amp;= 5i + 1 \\end{aligned} So $\\phi^{-1}(3) = \\{ 5i + 1 \\mid 0 \\leq i \\leq 9 \\}$\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"2f2d04b63bfe34fddde269e5c4c3750c","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset10/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset10/","section":"siniora-algebra-post","summary":"Problems 8 Homomorphism. If $\\sigma_1$ and $\\sigma_2$ are both even or both odd, then $\\sigma_1 \\sigma_2$ is even and $sgn(\\sigma_1) sgn(\\sigma_2) = 1$. If one of them is even and the other is odd, then $\\sigma_1 \\sigma_2$ is odd and $sgn(\\sigma_1) sgn(\\sigma_2) = 1 * -1 = -1$.","tags":null,"title":"Chapter 10","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 2 $n = 3$.\nThe table in page 213 shows that.\n5 $45 = 3^2 \\cdot 5^1$. By the fundamental theorem of finite abelian groups, All possible groups are \\begin{aligned} Z_9 \\oplus Z_5 \u0026amp;\\approx Z_{45} \\\\ Z_3 \\oplus Z_3 \\oplus Z_5 \u0026amp;\\approx Z_3 \\oplus Z_{15} \\end{aligned}\nGroup $(1)$ has element $3$ whose order is $|3| = 15$. Group $(2)$ has element $(0,1)$ whose order is $|(0,1)| = 15$. Therefore, Any finite abelian group of order $45$ has an element of order $15$.\nBy The fundamental theorem of cyclic groups (page 81) we know all elements orders of $Z_3$ are: $1, 3$, and all elements orders of $Z_{15}$ are: $1, 3, 5$. But by Theorem 8.1 (page 158) all elements’ orders of $Z_3 \\oplus Z_{15}$ are: $1, 3, 5, 15$, by computing $lcm$ of all possible pairs of elements orders. Therefore, It is not necessarily the case any finite abelian group of order $45$ has an element of order $9$.\n10 $360 = 2^3 \\cdot 3^2 \\cdot 5^1$.\nFor $2^3$, $k = 3$, \\begin{aligned} 3 \u0026amp;\\qquad Z_8 \\\\ 2 + 1 \u0026amp;\\qquad Z_4 \\oplus Z_2 \\\\ 1 + 1 + 1 \u0026amp;\\qquad Z_2 \\oplus Z_2 \\oplus Z_2 \\end{aligned}\nFor $3^2$, $k = 2$, \\begin{aligned} 2 \u0026amp;\\qquad Z_9 \\\\ 1 + 1 \u0026amp;\\qquad Z_3 \\oplus Z_3 \\end{aligned}$$\nFor $5^1$, $k = 1$, \\begin{aligned} 1 \\qquad Z_5 \\end{aligned}\nIt follows all groups are \\begin{aligned} \u0026amp;Z_8 \\oplus Z_9 \\oplus Z_5 \\\\ \u0026amp;Z_8 \\oplus Z_3 \\oplus Z_3 \\oplus Z_5 \\\\ \u0026amp;Z_4 \\oplus Z_2 \\oplus Z_9 \\oplus Z_5 \\\\ \u0026amp;Z_4 \\oplus Z_2 \\oplus Z_3 \\oplus Z_3 \\oplus Z_5 \\\\ \u0026amp;Z_2 \\oplus Z_2 \\oplus Z_2 \\oplus Z_9 \\oplus Z_5 \\\\ \u0026amp;Z_2 \\oplus Z_2 \\oplus Z_2 \\oplus Z_3 \\oplus Z_3 \\oplus Z_5 \\end{aligned}\n22 By the fundamental theorem of finite abelian groups, $G \\approx Z_{p_1^{n_1}} \\oplus Z_{p_2^{n_2}} \\oplus \\dots \\oplus Z_{p_k^{n_k}}$ where $|G| = p_1^{n_1} \\cdot .. \\cdot p_k^{n_k}$. We claim $n_1 = n_2 = \\dots = n_k = 1$.\nAssume for contradiction some $n_i \u0026gt; 1$. Then by the theorem we can substitute $Z_{p_i^{n_i}}$ by $Z_{p_i^1} \\oplus Z_{p_i^1} \\oplus Z_{p_i^{n_i-2}}$. If $n_i = 2$ then just ignore the third term. It follows we have two distinct subgroups of cardinality $p_i$. In other words, two distinct subgroups of the same order of divisor $p_i$ of $|G|$. Contradiction.\nTherefore $G \\approx Z_{p_1^1} \\oplus Z_{p_2^1} \\oplus \\dots \\oplus Z_{p_k^1}$. But all $p_i$s are coprime, So $G \\approx Z_{p_1 \\cdot .. \\cdot p_k}$, Concluding it is cyclic.\n31 If $a = b$ then $a^2 = b^2$. So $a$ and $b$ are distinct. Moreover $(a^2)^2 = a^4 = e$ and $(b^2)^2 = b^4 = e$. So we have distinct elements $a^2$ and $b^2$ of order 2.\nBy the fundamental theorem of finite abelian groups, All possible classes are: \\begin{aligned} \u0026amp;Z_{16} \\\\ \u0026amp;Z_8 \\oplus Z_2 \\\\ \u0026amp;Z_4 \\oplus Z_4 \\\\ \u0026amp;Z_4 \\oplus Z_2 \\oplus Z_2 \\\\ \u0026amp;Z_2 \\oplus Z_2 \\oplus Z_2 \\oplus Z_2 \\end{aligned}\n$(3)$ is excluded as it has only one element of order $2$, namely $8$.\n$(4)$ is excluded. All orders of elements are $1,2,4,8$ and $1,2$ respectively. Elements of order $4$ in group $(4)$ can be only obtained by an element of order $4$ in $Z_8$. Otherwise the $lcm$ would be $1,2,8$. There are only two elements of order $4$ in $Z_8$, namely $2$ and $6$. So all possible elements of order $4$ in group $(4)$ are $(2,0), (6,0), (2,1), (6,1)$. But the square of any of them is $(4,0)$, Violating the given condition $a^2 \\neq b^2$.\n$(6)$ is excluded. All orders of elements are $1,2,4$ and $1,2$ respectively. There are only two elements in $Z_8$ of order $4$, namely $1$ and $3$. So all possible elements of order $4$ in group $(4)$ are $(1,0), (3,0), (1,1), (3,1)$. But the square of any of them is $(2,0)$, Violating the given condition of $a^2 \\neq b^2$.\n$(7)$ is excluded as all elements orders of $Z_2$ are $1,2$, So taking $lcm$ would always be $1,2$. So it has no element of order $4$.\nTherefore the class is group $(5)$.\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"222b57c04f98b04af83d8d76fae83b24","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset11/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset11/","section":"siniora-algebra-post","summary":"Problems 2 $n = 3$.\nThe table in page 213 shows that.\n5 $45 = 3^2 \\cdot 5^1$. By the fundamental theorem of finite abelian groups, All possible groups are \\begin{aligned} Z_9 \\oplus Z_5 \u0026\\approx Z_{45} \\\\ Z_3 \\oplus Z_3 \\oplus Z_5 \u0026\\approx Z_3 \\oplus Z_{15} \\end{aligned}","tags":null,"title":"Chapter 11","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 2 It is $6$. For any $i \\in \\{ 0,2,4,6,8 \\}$, $6i \\mod 10 = i$.\n3 It suffices to find a ring with a subgroup which in turn is not closed under multiplication. Particularly the ring of rationals $\\mathbb{Q}$ and its subset $S = \\{ \\nfrac{x}{2} \\mid x \\in \\mathbb{Z} \\} = \\{ x\\ \\nfrac{r}{2} \\mid x \\in \\mathbb{Z}, y = 0,1 \\}$. It is a subgroup as $\\nfrac{x_0}{2} + \\nfrac{x_1}{2} = \\nfrac{x_0 + x_1}{2}$ where $x_0 + x_1 \\in \\mathbb{Z}$, and for $\\nfrac{x_0}{2}$ there is $\\nfrac{-x_0}{2}$ such that $\\nfrac{x_0}{2} + \\nfrac{-x_0}{2} = 0$. Observe $\\nfrac{1}{2} \\cdot \\nfrac{1}{2} = \\nfrac{1}{4} \\notin S$, So $S$ is not closed under multiplication.\nP.S.\nAny subgroup under addition of a ring, satisfies the ring’s definition, except for being closed under multiplication. Any set $S$ closed under usual addition of integers, is also closed under usual multiplication of integers, Since $ab = \\underbrace{a + a + \\dots + a}_{b \\text{ times}} \\in S$. 5 Unity’s uniqueness. Let $1$ and $1’$ be two unities. Then by definition $11’ = 1\u0026#39;1 = 1’$, and $1\u0026#39;1 = 11’ = 1$. So $1 = 1’$.\nMultiplicative inverse uniqueness. Fix $a_0$. Let $b_0$ and $b_1$ be two multiplicative inverses of $a_0$. Then $b_0a_0 = a_0b_0 = 1$, and $b_1a_0 = a_0b_1 = 1$. So \\begin{aligned} a_0b_0 \u0026amp;= a_0b_1 \\\\ b_0(a_0b_0) \u0026amp;= b_0(a_0b_1) \\\\ (b_0a_0)b_0 \u0026amp;= (b_0a_0)b_1 \\\\ b_0 \u0026amp;= b_1 \\end{aligned}\n6 a. For $Z_6$, $3^2 = 3$ but $3 \\neq 0$ and $3 \\neq 1$.\nb. For $Z_4$, $3 \\cdot 3 = 0$ but $3 \\neq 0$.\nc. For $Z_4$, $2 \\cdot 1 = 2 = 2 \\cdot 3$ and $2 \\neq 0$ but $1 \\neq 3$.\n12 $(\\rightarrow)$. By definition for some $k$, \\begin{aligned} bk \u0026amp;= c \\\\ bk \\cdot 1 \u0026amp;= \\\\ bk \\cdot aa^{-1} \u0026amp;= \\\\ ab \\cdot ka^{-1} \u0026amp;= \\end{aligned}\n$(\\leftarrow)$. By definition for some $k$, \\begin{aligned} ab \\cdot k \u0026amp;= c \\\\ a \\cdot bk \u0026amp;= \\end{aligned}\n39 Consider arbitrary $ar_0a, ar_1a \\in S$. Then \\begin{aligned} ar_0a \\cdot ar_1a \\\\ \u0026amp;= ar_0a^2r_1a \\\\ \u0026amp;= ar_0r_1a \\in S \\end{aligned} As $r_0r_1 \\in R$. Also, \\begin{aligned} ar_0a - ar_1a \\\\ \u0026amp;= a [r_0a - r_1a] \\\\ \u0026amp;= a \\left [ (r_0 - r_1) a \\right ] \\\\ \u0026amp;= a(r_0 - r_1)a \\in S \\end{aligned} As $r_0 - r_1 \\in R$.\nSince $1 \\in R$, $a1a \\in S$ but $a1a = a^2 = 1$.\n40 (1), (2), (3), (5), (6) of a ring’s definition in page 227 are satisfied by the usual properties of matrix algebra and integers.\nNote the additive identity is the matrix \\begin{bmatrix} 0 \u0026amp; 0+0 \\\\ 0+0 \u0026amp; 0 \\end{bmatrix}\nWe show (4). For any matrix $M \\in R$, where $$ M = \\begin{bmatrix} a \u0026amp; a+b \\\\ a+b \u0026amp; b \\end{bmatrix} $$ The matrix $-M$ defined as $$ -M = \\begin{bmatrix} -a \u0026amp; -a+(-b) \\\\ -a+(-b) \u0026amp; -b \\end{bmatrix} $$ is in $M_2(Z)$, as $-a \\in Z$ whenever $a \\in Z$. Clearly $M - M$ is the additive identity.\n46 $2 \\in 2Z$ and $3 \\in 3Z$ but $2+3 = 5 \\not\\in 2Z \\cup 3Z$, so $2Z \\cup 3Z$ is not closed under addition.\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"5fcaf2e17af2b76956377af501630007","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset12/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset12/","section":"siniora-algebra-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 2 It is $6$. For any $i \\in \\{ 0,2,4,6,8 \\}$, $6i \\mod 10 = i$.\n3 It suffices to find a ring with a subgroup which in turn is not closed under multiplication.","tags":null,"title":"Chapter 12","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 3 Let $R$ be a commutative ring with the cancellation property. Assume for contradiction $a$ is a zero-divisor. Then $a \\neq 0$ and there’s $b \\neq 0$ such that $ab = 0$. By theorem 12.1 (page 229) It follows: \\begin{aligned} ab - ab \u0026amp;= 0 \\\\ a(b-b) \u0026amp;= 0 \\\\ \u0026amp;= 0 \\cdot 0 \\\\ \u0026amp;= 0 \\cdot (b-b) \\\\ a \u0026amp;= 0 \\end{aligned} Contradiction.\n4 Zero-divisors are $2, 4, 6, 8, 10, 12, 14, 15, 16, 18, 5, 15$. To see why assume $ab \\mod 20 \\equiv 0 \\mod 20$. Then $ab - 0 = ab = 20k$ for some $k$. $a$ must contain a common factor with $20$, as otherwise $b \\geq 20$. So zero-divisors are multiples of a factor of $20$.\nUnities are $1, 3, 7, 9, 11, 13, 17, 19$. No proof is found.\nZero-divisors and unities partition $\\mathbb{Z}_{20}$.\n9 We call $a \\in Z \\oplus Z \\oplus Z$ strictZero if some component of $a$ is $0$ like $(x, y, 0)$ but $a \\neq (0,0,0)$.\nClearly $a$ is a zero-divisor if and only if $a$ is a strictZero.\nFor $a,b,c \\in Z \\oplus Z \\oplus Z$, if $ab, ac, bc$ are zero-divisors then they are strictZeros. If $abc$ is not a zero-divisor then it is not a strictZero, in other words either $abc = (0,0,0)$, or $abc = (x, y, z)$ where $x,y,z \\neq 0$. The latter case cannot happen as $ab$ is a a strictZero so some component must be zero in $abc$. Therefore $abc = (0,0,0)$.\nSince $Z$ has no zero-divisor, it follows each component is zero in one of $a,b,c$. In other words, The $a,b,c$ we are characterizing, are strictZeros, such that no component is non-zero in the three of them.\n18 Let $R$ be an integral domain and $a^2 = a$. Then \\begin{aligned} a^2 - a \u0026amp;= 0 \\\\ a(a-1) \u0026amp;= 0 \\end{aligned} Since there are no zero-divisors, either $a = 0$ or $a - 1 = 0$.\n32 We know $R$ is a group. By usual properties of addition and multiplication, It is a commutative ring.\n$6$ is unity as \\begin{aligned} 6 \\cdot 0 = 0 \\\\ 6 \\cdot 2 = 2 \\\\ 6 \\cdot 4 = 4 \\\\ 6 \\cdot 6 = 6 \\\\ 6 \\cdot 8 = 8 \\end{aligned}\nEach non-zero element has a unit as \\begin{aligned} 2 \\cdot 8 = 6 \\\\ 4 \\cdot 4 = 6 \\\\ 6 \\cdot 6 = 6 \\\\ 8 \\cdot 2 = 6 \\end{aligned}\n57 Observe by distributivity of rings $x^2 -5x + 6 = (x-3)(x-2)$.\na By the corollary (page 239) $\\mathbb{Z}_7$ is a field, and hence has no zero-divisors. It follows either $x-3 = 0$ or $x-2 = 0$ so $x = 3$ or $x = 2$. Exactly two solutions.\nb By computation $2$ and $3$ are the solutions.\nNote nothing certifies $\\mathbb{Z}_8$ is an integral domain.\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"9f19bb2a9b09e1fb5ea1af2987c86476","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset13/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset13/","section":"siniora-algebra-post","summary":"Problems 3 Let $R$ be a commutative ring with the cancellation property. Assume for contradiction $a$ is a zero-divisor. Then $a \\neq 0$ and there’s $b \\neq 0$ such that $ab = 0$.","tags":null,"title":"Chapter 13","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 1 We use Theorem 14.1 (ideal test) (page 249).\nFor $r_0 a, r_1 a \\in \\langle a \\rangle$, We have $r_0 a - r_1 a = (r_0 - r_1) a \\in \\langle a \\rangle$ by distributivity and $r_0 - r_1 \\in R$.\nFor $r \\in R$ and $r_0 a \\in \\langle a \\rangle$, We have $r(r_0 a) = (rr_0)a \\in \\langle a \\rangle$ by associativity and $r r_0 \\in R$. Also $(r_0 a)r = r_0(ar) = r_0(ra) = (r_0 r) a$ by associativity and commutativity and $r_0 r \\in R$.\n3 The proof $I$ is ideal by Theorem 14.1 (ideal test) (page 249) is nearly identical to Ex. 1.\nLet $J$ be an arbitrary ideal that contains $a_1,a_2, \\dots, a_n$. Then by definition $r a_i \\in J$. Since it’s a group $r_1 a_1 + \\dots + r_n a_n \\in J$ for any $r_i \\in R$.\n4 By the subring test (page 230), $S = \\{ (x,x) \\mid x \\in Z \\}$ is a subring as $(x,x) - (y,y) = (x-y, x-y) \\in S$ and $(x,x) (y,y) = (xy,xy) \\in S$.\n$S$ is not an ideal as $(1,1) \\in S$ and $(1,2) \\in \\mathbb{Z} \\oplus \\mathbb{Z}$ but $(1,2) (1,1) = (1,2) \\notin S$. In other words, $(1,1)$ did not absorb $(1,2)$.\n5 We use Theorem 12.3 (subring test) (page 230). $(a+bi) - (a’+b’i) = (a-a’) + (b-b’)i \\in S$ as $b-b’$ is even. $(a+bi) (a’+b’i) = (aa’ - bb’) + (ab’ + a’b)i \\in S$ as $ab’ + a’b$ is even.\n$1 + 2i \\in S$ and $1 + 1i \\in Z[i]$ but $(1 + 1i)(1 + 2i) = -1 + 3i \\not\\in S$ as $3$ is not even. A counter-example of $S$ being an ideal.\n11 a $\\langle a \\rangle = \\langle 1 \\rangle = \\mathbb{Z}$. We know $GCD(2,3) = 1$ so by Theorem 0.2 (GCD is a linear combination) (page), there are $x, y \\in \\mathbb{Z}$ such that $2x + 3y = 1$. So for any integer $m$, $2(xm) + 3(ym) = m$. In other words, $\\mathbb{Z} = \\langle 1 \\rangle \\subset \\langle 2 \\rangle + \\langle 3 \\rangle$.\nb $\\langle a \\rangle = \\langle 2 \\rangle$. Trivially $\\langle 6 \\rangle + \\langle 8 \\rangle \\subset \\langle 2 \\rangle$ as $2$ is a common divisor of $6$ and $8$. Observe $8(1) + 6(-1) = 2$. So for any multiple $2m$, We have $8(m) + 6(-m) = 2m$, concluding $\\langle 2 \\rangle \\subset \\langle 8 \\rangle + \\langle 6 \\rangle$.\n15 By definition $A \\subset R$ and $r = r1 \\in A$ for any $r \\in R$.\n32 Let $B$ be an arbitrary ideal of $\\mathbb{Z} \\oplus \\mathbb{Z}$ such that $A \\subset B \\subset \\mathbb{Z} \\oplus \\mathbb{Z}$. Assume $B$ properly contains $A$ then we show $B = \\mathbb{Z} \\oplus \\mathbb{Z}$.\nBy hypothesis we have $(a,b) \\in B$ but not in $A$. So $a = 3q + r$ whereby either $r = 1$ or $r = 2$. Consider each case:\n$r = 1$. Since $A \\subset B$, $( 3(-q), -(b-1)) \\in B$. As $B$ is a group, $(3(-q), -(b-1)) + (3q+1, b) = (1,1) \\in B$. $r = 2$. Similarly $(3(q+1), b+1) \\in B$ and $(3(q+1), b+1) - (3q+2, b) = (1, 1) \\in B$. By Ex. 15 $B = \\mathbb{Z} \\oplus \\mathbb{Z}$.\nHad $A$ been $\\{ (4x, y) \\mid x,y \\in \\mathbb{Z} \\}$ then the property of it being a maximal ideal fails as the ideal $\\{ (2x, y) \\}$ is strictly larger.\nGenerally, $\\{ (rx,y) \\}$ is a maximal ideal if and only if $r$ is a prime. If $r$ is composite then any divisor generates a larger ideal. If $r$ is prime then for any $m$ where $0 \u0026lt; m \u0026lt; r$, $gcd(r, m) = 1$. It follows by Theorem 0.2 (GCD is a linear combination) (page 4) there is a linear combination $xr + ym = 1$.\n37 If $(x,y), (a,b) \\in \\mathbb{Z} \\oplus \\mathbb{Z}$ and $(x,y)(a,b) = (xa,yb) \\in I$ then by definition $yb = 0$. So either $y = 0$ or $b = 0$. In other words, either $(x,y) \\in I$ or $(a,b) \\in I$.\nThe set $\\{ (x,2y) \\mid x,y \\in Z \\}$ is an ideal and properly contains $I$. So $I$ is not maximal.\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"1de1df1c12202bbab2c10bf8c04788d5","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset14/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset14/","section":"siniora-algebra-post","summary":"Problems 1 We use Theorem 14.1 (ideal test) (page 249).\nFor $r_0 a, r_1 a \\in \\langle a \\rangle$, We have $r_0 a - r_1 a = (r_0 - r_1) a \\in \\langle a \\rangle$ by distributivity and $r_0 - r_1 \\in R$.","tags":null,"title":"Chapter 14","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Exercises 9.1.1 Hints.\nUse quotient and mod operations. Observe why the quotient yields the maximum possible count of some coin. Solution.\n# input: non negative amount n, and a decreasing array of coins D # output: array C where C[i] is number of coins of ith denomination D[i] def greedyCoins(integer n, D[1..m]) # for each coin for i in 1..m # take max possible number of it C[i] = floor( n/D[i] ) # remaining amount for next iteration n = n \\mod D[i] # if there is still a remaining amount if n != 0 return \u0026#34;no solution\u0026#34; # otherwise given n is partitioned by coins return C 9.1.15 Homework.\n9.2.3 Hints.\nObserve Kruskal works with global edges, unlike Prim which searches within local neighbour edges. What is error you think we will encounter upon running Kruskal on a a tree with more than one component? Why does looping on $|V| - 1$ works in Kruskal? Modify the while condition to accommodate any forest. Solution.\nModify the while condition in Kruskal to be ecounter \u0026lt; |E|, So it terminates if there are no more edges.\nBonus. Modify Prim then use it as a subroutine to solve the general forest case.\n9.2.5 Homework.\n9.3.1 Hints.\n(c) Use Transform-and-conquer strategy. (c) Fixing vertices, What kind of modification is required on edges? (d) Use Transform-and-conquer strategy. (d) We will use Dijkstra as a subroutine, So the graph will be transformed to the usual form given in the book. Solution.\n(a)\nA data structure which considers directed edges.\n(b)\nSame algorithm. You may terminate once you find the destination.\n(d)\nEach vertex $v_i$ is mapped to $v_i^{st}$ and $v_i^{en}$, with directed edge $( v_i^{st}, v_i^{en} )$ whose weight is the number labeled on $v_i$. Any vertex in $G$ neighbour to $v_i$, can travel to $v_i^{st}$ but not $v_i^{en}$ in $G’$. Only vertices $v_i^{en}$ but not $v_i^{st}$ can travel to other vertices. Those edges in $G’$ are assigned zero weights.\n# input: graph G with weighted vertices # output: graph G with weighted edges and no weighted vertices def vertexWeightToEdgeWeight(G) construct empty graph G\u0026#39; for each vertex v in G(V) add vertex v_st to G\u0026#39; add vertex v_en to G\u0026#39; set (v_st, v_en).weight to v.weight add edge (v_st, v_en) to G\u0026#39; for each edge e = {a,b} in G(E) set (a_en, b_st).weight = 0 add edge (a_en, b_st) to G\u0026#39; set (b_en, a_st).weight = 0 add edge (b_en, a_st) to G\u0026#39; return G\u0026#39; (c)\nSet the destination as source then reverse paths. If graph is directed reverse paths before running the algorithm also.\n# input: graph G # output: same graph but whose edges are reversed def reverseEdges(G) construct empty graph G\u0026#39; clone vertices G\u0026#39;(V) = G(V) for every vertex v in G(V) for every edge e = (v,t) in G(E) add edge (t,v) to G\u0026#39; return G\u0026#39; # input: undirected graph G, destination d # output: shortest-paths of given d def undirectedGraphSingleDistination(G, d) compute Dijkstra(G, d) in graph G return reverseEdges(G) # input: directed graph G, destination d # output: shortest-paths of given d def directedGraphSingleDestination(G, d) G = reverseEdges(G) compute Dijkstra(G, d) in graph G return reverseEdges(G) Homework.\nA data-structure based implementation is left to students. In fact this is an excellent illustration of abstraction in algorithm design.\n9.3.7 Homework.\n9.4.5 Homework.\n9.4.7 Hints.\nA basic recursive algorithm traversal works. Solution.\ndef allHuffmanCodes(root) if root is NULL return [ ] # if root is a leaf if root.rightChild is NULL and root.leftChild is NULL return [ root.character ] # if exactly one child is NULL, Concatenating an empty list does no harm childCodes = allHuffmanCodes(root.leftChild) + allHuffmanCodes(root.rightChild) # prefix each code in child with root\u0026#39;s character return [ root.character + code for code in childCodes ] We leave it to students to modify the algorithm so that it generates a 2d-array of symbols-codes as a homework.\n","date":1702857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702857600,"objectID":"ba27f722948996b40fa00f602a2576a5","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab09/","publishdate":"2023-12-18T00:00:00Z","relpermalink":"/msa-levitin-post/lab09/","section":"msa-levitin-post","summary":"Exercises 9.1.1 Hints.\nUse quotient and mod operations. Observe why the quotient yields the maximum possible count of some coin. Solution.\n# input: non negative amount n, and a decreasing array of coins D # output: array C where C[i] is number of coins of ith denomination D[i] def greedyCoins(integer n, D[1.","tags":null,"title":"Lab 09","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"Exercises Ex. 1 Part I def randElement(A[1..n]) X = random( [n] ) return A[X] Since the probability space is uniform, For event $M = { \\frac{\\displaystyle{n}}{\\displaystyle{4}}+1, \\dots, \\frac{\\displaystyle{3}}{\\displaystyle{4}}n }$, $Pr[M] = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot |M| = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot \\frac{\\displaystyle{n}}{\\displaystyle{2}} = \\frac{\\displaystyle{1}}{\\displaystyle{2}}$.\nPart II Additionally we certify if the randomly generated element is in middle half.\ndef randElement2(A[1..n]) # Select a random element of A k = randElement(A) # Certify whether it is in middle half # count values less and greater countLess = countGreater = 0 for i in 1..n: if A[i] \u0026lt; k countLess = countLess + 1 else if A[i] \u0026gt; k countGreater = countGreater + 1 # check if k is between first and forth quarters if (countLess \u0026gt;= n/4) and (countGreater \u0026gt;= n/4) return k return FAIL Let $R$ be the algorithm’s output. $R = FAIL$ if and only if $\\neg M$. So $Pr[R=FAIL] = Pr[\\neg M] = 1 - Pr[M] = 1 - \\frac{\\displaystyle{1}}{\\displaystyle{2}} = \\frac{\\displaystyle{1}}{\\displaystyle{2}}$.\nPart III We repeat until the probability is upperbounded by $0.01$.\ndef randElement3(A[1..n]) # repeat 7 times for i in 1..7 # generate a random element out = randElement2(A[1..n]) # if the number is certified to be correct return it if out != FAIL return out # if 7 trials failed return FAIL Setting $0.5^{x} = 0.01$ we get $x = \\log_{1/2} 0.01 = \\frac{\\displaystyle{\\log_2 100^{-1} }}{\\displaystyle{\\log_2 2^{-1} }} = \\frac{\\displaystyle{(-1) \\log_2 100}}{\\displaystyle{(-1) \\log_2 2}} = \\log_2 100 \\leq \\log_2 128 = \\log_2 2^7 = 7$\nLet $R$ be the algorithm’s output, and let $R_i$ be the output of subroutine randElement2 in iteration $i$. Then $R = FAIL$ if and only if $R_1 = FAIL \\wedge \\dots \\wedge R_7 = FAIL$. We know $Pr[R_i = FAIL] = \\frac{\\displaystyle{1}}{\\displaystyle{2}}$ and $R_i$ are pairwise independent. We conclude $Pr[R = FAIL] = Pr[ R_1 = FAIL \\wedge R_2 = FAIL \\wedge \\dots \\wedge R_7 = FAIL] = \\left ( \\frac{\\displaystyle{1}}{\\displaystyle{2}} \\right )^7 \\leq 0.01$.\nEx. 2 Part I Trivial.\nPart II Hint. By Dr. I. El-Shaarawy, Not to skip Part I, and to observe the pattern in the following example. It signals the answer is $2^k$ if $x = 0$ and $2^{k-1}$ otherwise.\nBinary Number — Count of Even Parity\n000 8 001 4 010 4 011 4 100 4 101 4 110 4 111 4 Lemma 1. The zero $0 = \\underbrace{00 \\dots 0}_{k \\text{ times}}$ counts $2^k$ numbers of even parity.\nTrivially, $BitwiseAnd(0,x) = 0$ for any binary number $x \\in [2^k]$, and $Parity(0) = 0$.\nNow we can focus on $x \\neq 0$.\nDefinition 2. Given $x$ denote indices of 1-bits by 1-bits-indices.\nLemma 3. 1-bits-indices decide the parity.\nObserve for any $r \\in [2^k]$. $$ BitwiseAnd(x_i,r_i) = \\begin{cases} 0 \u0026amp; \\text{if } x_i = 0 \\\\ r_i \u0026amp; \\text{if } x_i = 1 \\end{cases} $$ So we can restrict our focus only on 1-bits-indices to compute the parity. In other words $$ Parity(BitwiseAnd(x,r)) = \\begin{cases} 0 \u0026amp; \\text{if $r$ has even 1 bits in } \\textit{1-bits-indices} \\\\ 1 \u0026amp; \\text{if $r$ has odd 1 bits in } \\textit{1-bits-indices} \\end{cases} $$\nLemma 4. The number of k-length strings containing even number of 1 bits in 1-bit-indices is $2^{k-1}$.\nDefine a bijection $$ f: \\{ \\text{strings of even 1-bits in } \\textit{1-bits-indices} \\} \\rightarrow \\{ \\text{strings of odd 1-bits in } \\textit{1-bits-indices} \\} $$ Mapping a binary string to the same string but with last bit in 1-bit-indices flipped. If that bit is $s_m$, Then $f(s_1s_2 \\dots s_k) = s_1 s_2 \\dots \\overline{s_{m}} \\dots s_{k-1} s_k$. It follows domain and range have the same cardinality, and since they partition the set of k-length strings, the result follows.\nTheorem 5. Fixing any binary $x \\neq 0$, Among all $r \\in [2^k]$, Exactly half of them yield even parity, i.e $Parity( BitwiseAnd(x,r) ) = 0$.\nCorollay 6. Given $x \\in [2^k]$, The number of zeros in the vector mentioned in question is $$ \\begin{cases} 2^k \u0026amp; \\text{if } x = 0 \\\\ 2^{k-1} \u0026amp; \\text{if } x \\neq 0 \\end{cases} $$\n","date":1702252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702252800,"objectID":"37d5f5170516930eda5b861ac7dc5bb5","permalink":"https://mostafatouny.github.io/harvey-rand-post/pset01/","publishdate":"2023-12-11T00:00:00Z","relpermalink":"/harvey-rand-post/pset01/","section":"harvey-rand-post","summary":"Exercises Ex. 1 Part I def randElement(A[1..n]) X = random( [n] ) return A[X] Since the probability space is uniform, For event $M = { \\frac{\\displaystyle{n}}{\\displaystyle{4}}+1, \\dots, \\frac{\\displaystyle{3}}{\\displaystyle{4}}n }$, $Pr[M] = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot |M| = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\cdot \\frac{\\displaystyle{n}}{\\displaystyle{2}} = \\frac{\\displaystyle{1}}{\\displaystyle{2}}$.","tags":null,"title":"Chapter 01","type":"harvey-rand-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Part I Take $m = n-1$, and let $R$ be the algorithm’s output. $R = 0$ if and only if $RNG()$ returned $0$ or $n-1$. So $Pr[R = 0] = 2/n$ and $Pr[R = i] = 1/n$ for $i \\neq 0$.\nPart II Define $k = \\lfloor n/m \\rfloor$, So $k$ is the greatest integer such that $mk \\leq n$. Define $r = n \\mod mk$, so $n = mk + r$ where $0 \\leq r \u0026lt; m$.\ndef goodSampler(m) k = floor( n/m ) do r = RNG() while r \u0026gt;= mk return r mod m Uniformity. Assume the algorithm terminates. So we are given $r \u0026lt; mk$ and we want to prove $Pr[r \\mod m = i \\mid r \u0026lt; mk] = \\nfrac{1}{m}$ for $i \\in [m]$. Observe \\begin{aligned} Pr[r \\mod m = i \\mid r \u0026lt; mk] \u0026amp;= \\nfrac{Pr[r \\mod m = i \\cap r \u0026lt; mk]}{Pr[r \u0026lt; mk]} \\\\ \u0026amp;= \\nfrac{k/n}{mk/n} = \\nfrac{k}{n} \\cdot \\nfrac{n}{mk} = \\nfrac{1}{m} \\end{aligned} Recall by uniformity the probability is basically the number of outcomes satisfying the event over all possible outcomes. Clearly the $k$ outcomes of $r$ yielding $i$ by the algorithm are $(0)m + i, (1)m + i, (2)m + i, \\dots, (k-1)m + (i)$.\nTime Complexity. For an iteration of do-while, probability of termination is $mk/n$. So in expectation it takes $n/mk$ trials until it terminates. It follows $$ 1 \\leq \\nfrac{n}{mk} = 1 + \\nfrac{r}{mk} \u0026lt; 1 + \\nfrac{m}{mk} = 1 + \\nfrac{1}{k} \\leq 2. $$ Concluding its time is $\\mathcal{O}(1)$.\nEx. 2 Distribution. see ex-2.2 notebook.\nThe distribution of the given psuedo-code seems uniform.\nThe distribution but with modifying the probability to be hardcoded p = 0.7 rather than p = ContinuousUniform() in line 2, seems normal.\nRecall we know in expectation we will get 7 1-bits out of 10 by linearity of random variables.\nRemark. $X = \\sum X_i^n$ is equivalent to number of $1$s tossed.\nLemma. Probability of tossing $k$ $1s$.\nFor some fixed probability of getting 1 $p$, and number of coin tosses $n$, The probability of drawing $k$ $1s$ is $Pr[X = k] = (p)^k (1-p)^{n-k} \\dbinom{n}{k}$, Since the distribution of coin tossing is binomial.\nEx. 3 Part I Algorithm.\n# input: Probabilities P[i] # output: category sampled def categoricalSampler( P[1..k] ) # initially the universe is all probabilities totalProb = sum( P[1..k] ) # for each ith probability for i in 1..k # compute P[i] probability in ratio to the universe i_prob_uni = (1/totalProb) * P[i] # return i by that probability if biasedBit( i_prob_uni ) return i # remove P[i] from the universe totalProb -= P[i] Correctness. Computing a probability out of a subset of probabilities.\nWe want to compute a probability but in ratio to some subset of probabilities.\nFor example if $Pr[X = i] = 1/4$ for $i \\in { 1,2,3,4 }$, But we are given $X \\not\\in {1, 2}$. Then $Pr[X = 3 \\mid X \\not\\in {1,2}] = \\nfrac{Pr[X = 3 \\cap X \\not\\in {1,2}]}{Pr[X \\not\\in {1,2}]} = \\nfrac{1/4}{1/2} = 2 \\cdot \\nfrac{1}{4}$.\nGenerally we want to find $x$ where, For sum $S$ of some subset of probabilities, $\\nfrac{Pr[X = i]}{S} = \\nfrac{x}{1}$, so $x = \\nfrac{1}{S} \\cdot Pr[X=i]$.\nCorrectness. categoricalSampler returns a category.\nIf the algorithm reached iteration $k$, i_prob_uni would be $1$ so biasedBit surely fires.\nTime Complexity. Clearly $\\mathcal{O}(k)$.\nPart II Algorithm\n# input: probabilities P[i] # output: cumulative sum of probabilities S[i] def cumulativeSum( P[1..k] ) # S[i] is sum up to P[i] S = [] sum = 0 # compute \u0026amp; append S[i] for i in 1..k # cumulative sum up to P[i] sum += P[i] # append as S[i] S.append( sum ) return S # input: probabilities P[i], and cumulative probabilities S[i] # output: sampled category i def recursiveSampler( P[l..r], S[l..r] ) # base case. universe is one category so its probability is 1 if l = r return l # center index mid = floor( (r-l)/2 ) # total probability of P[l..r] totalProb = S[r] - S[l] + P[l] # probability of cumulative half of P in ratio to the universe prob_uni = (1/totalProb) * S[mid] # toss a coin by cumulative probability of half of P if biasedBit( prob_uni ) # if True then the sample is restricted to them return recursiveSampler( P[l..mid], S[l..mid] ) else # if False then the sample is not any of them return recursiveSampler( P[mid+1..r], S[mid+1..r] ) # input: probabilities P[i] # output: sampled category i def categoricalSampler2( P[1..k] ) # preprocessing, computing cumulative sum of probabilities S = cumulativeSum( P[1..k] ) # sample a category return recursiveSampler( P, S ) Correctness. recursiveSampler won’t ever reach array P of size zero.\nThat can only happen if either mid = r or mid = l, but then S[mid] = 1 or S[mid] = 0 respectively. Contradiction.\nCorrectness. The algorithm samples category $i$ with probability $P[i]$.\nThe remarks from Part I holds here. We show a more formal proof.\nLet $X = z$ denote the event of sampling category $z$. Let $j_1, j_2, \\dots, j_{k-1}$ be the remaining categories. Then $Pr[X = z] = Pr[X \\neq j_1 \\cap X \\neq j_2 \\cap \\dots \\cap X \\neq j_{k-1}]$. Partition $j$s on subsets of outcomes $O_1, O_2, \\dots, O_{\\log k}$. \\begin{aligned} Pr[X = …","date":1702252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702252800,"objectID":"f08c4302fa3207be2f0760ca5717436c","permalink":"https://mostafatouny.github.io/harvey-rand-post/pset02/","publishdate":"2023-12-11T00:00:00Z","relpermalink":"/harvey-rand-post/pset02/","section":"harvey-rand-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Part I Take $m = n-1$, and let $R$ be the algorithm’s output. $R = 0$ if and only if $RNG()$ returned $0$ or $n-1$. So $Pr[R = 0] = 2/n$ and $Pr[R = i] = 1/n$ for $i \\neq 0$.","tags":null,"title":"Chapter 02","type":"harvey-rand-post"},{"authors":null,"categories":null,"content":"Problems 1 Those are $\\{ a \\langle 3 \\rangle \\mid a\\in \\mathcal{Z} \\} = \\big \\{ \\{ a \\pm 0, a \\pm 3, a \\pm 6, \\dots \\} \\mid a \\in \\mathcal{Z} \\big \\}$.\n7 Observe $\\langle a^4 \\rangle = { 1, a^{4(1)}, a^{4(2)}, \\dots, a^{4(14)} }$. Then $\\lvert \\langle a^4 \\rangle \\rvert = 15$. It follows by theorem 7.1 (page 142), The number of distinct left cosets is $30/15 = 2$.\n9 Lazy to compute and typeset all left cosets.\n$H$ is a subgroup. Then by theorem 7.1 (page 142), the number of left cosets of $H$ in $S_4$ is $4!/4 = 3! = 6$.\n10 Assume for contradiction $aH \\cap bH = \\phi$. Since we are given $aH = bK$, It follows $bK \\cap bH = \\phi$, Concluding $H \\cap K = \\phi$. Contradiction as the identity element $e \\in G$ is common in both subgroups. Therefore $aH \\cap bH \\neq \\phi$.\nFrom Lemma (page 139), We get $aH = bH$. Then $bK = bH$ as we are given $aH = bK$. It follows $K = H$.\n17 Let $H$ be a proper subgroup of $G$. If $\\lvert H \\rvert = 1$, Then $H = { e } = \\langle e \\rangle$. it is cyclic. Now assume $\\lvert H \\rvert \u0026gt; 1$. Then by theorem 7.1 (page 143), and without the loss of generality, $\\lvert H \\rvert = p$ for a prime $p$. By corollary 3, $H$ is cyclic.\n19 $5^{16} \\mod 7 = 6$ and $7^{13} \\mod 11 = 2$, Using the fact $ab \\mod m = (a \\mod m) (b \\mod m) \\mod m$.\n22 Let $H$ and $K$ be finite subgroups of a group $G$, Where $\\lvert H \\rvert$ and $\\lvert K \\rvert$ are coprime. Since $H \\cap K$ is a subgroup of both $H$ and $K$, By theorem 7.1 (page 142), $\\lvert H \\cap K \\rvert = 1$. Then $H \\cap K = {e}$, where $e$ is the identity of $G$.\n38 39 We know all common divisors among $24$ and $20$ are $1,2,4$. By theorem 7.1 (page 142), It follows $\\lvert H \\cap K \\rvert = 1, 2,$ or $4$.\nCase. $\\lvert H \\cap K \\rvert = 1$. Then it is the trivial group of only the identity element.\nCase. $\\lvert H \\cap K \\rvert = 2$. Then it is ${e, a}$. Trivially abelian.\nFact. For any two elements $a,b$ of a group. If $ab = b$ then $a = e$, the identity element. Observe we can cancel $b$ in $ab = eb = b$.\nCase. $\\lvert H \\cap K \\rvert = 4$. Assume for contradiction, that $ab \\neq ba$ for arbitrary distinct elements $a$ and $b$, Neither of which is the identity. Then $ab \\not\\in {a, b}$ by the Fact. Moreover $ab \\neq e$ lest $b = a^{-1}$ and then $ab = ba$. Symmetrically these conclusions apply on $ba$. Since we excluded $3$ elements out of $4$, There is only a single element $ab$ and $ba$ can both be assigned to, i.e $ab = ba$. Contradiction.\n","date":1702252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702252800,"objectID":"64a6f1f5d0e63418e9f5ad0f1d51208c","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset07/","publishdate":"2023-12-11T00:00:00Z","relpermalink":"/siniora-algebra-post/pset07/","section":"siniora-algebra-post","summary":"Problems 1 Those are $\\{ a \\langle 3 \\rangle \\mid a\\in \\mathcal{Z} \\} = \\big \\{ \\{ a \\pm 0, a \\pm 3, a \\pm 6, \\dots \\} \\mid a \\in \\mathcal{Z} \\big \\}$.","tags":null,"title":"Chapter 07","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 4 Clearly, For arbitrary $a,c \\in G$ and $b,d \\in H$ \\begin{aligned} \u0026amp;ac = ca \\wedge bd = db \\\\ \\leftrightarrow \u0026amp;(ac, bd) = (ca, db) \\\\ \\leftrightarrow \u0026amp;(a,b)(c,d) = (c,d)(a,b) \\end{aligned} I guess the general case is any group-theoretic property on both $G$ and $H$ is also on $G \\oplus H$, and vice verca.\n5 Assume for the sake of contradiction $Z \\oplus G$ is cyclic. Then by definition there is a generator $(a,b)$. Then necessarily $\\langle a \\rangle = Z$ and $\\langle b \\rangle = G$ as by definition we have $(a,b)^k = (a^k,b^k)$. Observe $\\langle a \\rangle$ is of infinite order. Fix $c \\in Z$, Then we know $a^k = c$ for some $k$. Compute $(a,b)^k = (a^k,b^k) = (c,d)$. Let $h$ be the element other than $d$ in $G$. Now we can’t generate $(c,h)$. By theorem 4.1 (page 76) if $a^i = a^k$ then $i = k$. In other words, $k$ is the only integer that yields $a^k = c$.\n6 Clearly $(1,1) \\in Z_8 \\oplus Z_2$ is of order $8$. We claim no element of $Z_4 \\oplus Z_4$ is of order $8$, Which suffices to solve the problem.\nFrom Theorem 4.3 (page 81) we know any element of $Z_4$ is of order, which divides $4$. In other words, For any element $a$, there is $k \\leq 4$ such that $k |a| = 4$. Similarly for another element $b$ we have $k’ |b| = 4$.\nSo for any $(a,b) \\in Z_4 \\oplus Z_4$, Observe $(a,b)^4 = (a^4,b^4) = (a^{k |a|},b^{k’ |b|}) = ((a^{|a|})^k, (b^{|b|})^{k’}) = (0^k, 0^{k’}) = (0, 0)$. So order of $(a,b)$ is at most $4$.\n15 Let $\\phi: C \\rightarrow R \\oplus R$ where $\\phi(a+bi) = (a,b)$.\nInjective. $\\phi(a+bi) = \\phi(c+di)$ implies $(a,b) = (c,d)$, and in turn $a = c$ and $b = d$. Surjective. For any $(a,b)$ we have $\\phi(a+bi) = (a,b)$. Preserves Operation. $\\phi(a+bi) \\phi(c+di) = (a,b) (c,d) = (a+c, b+d) = \\phi( (a+c)+(b+d)i ) = \\phi ( (a+bi) + (c+di) )$. 17 Since $G \\oplus H$ is cyclic, it has a generator $(a,b)$. It follows $\\langle a \\rangle = G$\nand $\\langle b \\rangle = H$. If that is not the case, Then we can select an element from $G$ or $H$ whereby $(a,b)^k = (a^k, b^k)$ won’t cover it, on it corresponding index.\n21 Denote the equivalence $\\langle (g,h) \\rangle = \\langle g \\rangle \\oplus \\langle h \\rangle$ by (1).\nRecall theorem 8.1 (page 158).\nBy definition we know $(g,h)^k = (g^k,h^k)$ where $g^k \\in \\langle g \\rangle$ and $h^k \\in \\langle h \\rangle$.\nThe condition is $|g|$ and $|h|$ are coprime. Observe it is equivalent to $lcm(|g|,|h|) = |g| |h|$.\n(Necessity) We show given (1), The condition holds. Since sets are equal, and cardinality of L.H.S is $|g| \\cdot |h|$, Then $|(g,h)| = |g| \\cdot |h|$. By thm 8.1, The condition is satisfied.\n(Sufficent) We show given the condition, (1) holds. By thm 8.1, $|(g,h)| = |g| \\cdot |h|$. So its cardinality is the same as R.H.S, and it is a subset of it. It follows (1) holds.\n23 Any element in $Z_3$ is of order 3, except the identity $0$. Consider an arbitrary non-identity element\n$(x_1, x_2, \\dots, x_k) \\neq e = \\underbrace{(0, .., 0)}_{k \\text{ times}}$\nin $\\underbrace{Z_3 \\oplus .. \\oplus Z_3}_{k \\text{ times}}$. We claim $| (x_1, \\dots, x_k) | = 3$.\nFollowing the fact all non-identity elements are of order 3, and we have some $x_i \\neq 0$, \\begin{aligned} (x_1, x_2, \\dots, x_k)^1 \u0026amp;= (x_1^1, x_2^1, \\dots, x_k^1) \\neq e \\\\ (x_1, x_2, \\dots, x_k)^2 \u0026amp;= (x_1^2, x_2^2, \\dots, x_k^2) \\neq e \\\\ (x_1, x_2, \\dots, x_k)^3 \u0026amp;= (0, 0, \\dots,0) = e \\\\ \\end{aligned} Therefore we have $3^k - 1$ elements of order 3 in $\\underbrace{Z_3 \\oplus \\dots \\oplus Z_3}_{k \\text{ times}}$.\n35 Recall the square root of any complex number $z$ exists. Observe $C^*$ is closed under the square root operation.\nAssume for the sake of contradiction, there is an isomorphism $\\phi : C^* \\rightarrow R^* \\oplus R^*$. Then by surjectivity there is some complex $z$ where $\\phi(z) = (-1,-1)$. It follows \\begin{aligned} \\phi(\\sqrt{z} \\cdot \\sqrt{z}) \u0026amp;= (-1,-1) \\\\ \\phi(\\sqrt{z}) \\cdot \\phi(\\sqrt{z}) \u0026amp;= \\\\ ( \\phi(\\sqrt{z}) )^2 \u0026amp;= \\\\ (a,b)^2 \u0026amp;= \\\\ (a^2, b^2) \u0026amp;= \\end{aligned} In other words $a^2 = -1$ and $b^2 = -1$, but either of these leads to a contradiction, as no square of a real number is negative.\n46 The infinite group is $\\mathcal{Z} \\oplus D_4 \\oplus A_4$. Clearly ${ (e_Z, x, e_{A_4}) \\mid x \\in D_4 }$ and ${ (e_Z, e_{D_4}, x) \\mid x \\in A_4 }$ are both subgroups.\n48 Claim. It is all permutations on $\\mathcal{Z}_2 \\oplus \\mathcal{Z}_2$ which maps $(0,0)$ to itself.\nNote. Our characterization is consistent with the fact the identity is always mapped to itself, and that isomorphism is a bijection.\nFact. In any group, fixing element $a_0$, then for any elements $b_0 \\neq b_1$, we have $a_0 b_0 \\neq a_0 b_1$.\nLemma. For any $(a,b) \\in \\mathcal{Z}_2 \\oplus \\mathcal{Z}_2$, $(a, b)^2 = (a^2, b^2) = (0,0) = e$, As $0^2 = 0$ and $1^2 = 0$.\nLemma. Any two elements of $X = { (0,1), (1,0), (1,1) }$ multiplies to the third.\nFor distinct $a,b,c \\in X$, $ab \\neq (0,0)$ since $aa = (0,0)$. Also $ab \\neq a$ since $a (0,0) = a$. Similarly $ab \\neq b$. Therefore the only remaining choice is $ab = c$.\nTheorem. Our …","date":1702252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702252800,"objectID":"5c14e90f6703ab6663b552aafbc0ec8c","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset08/","publishdate":"2023-12-11T00:00:00Z","relpermalink":"/siniora-algebra-post/pset08/","section":"siniora-algebra-post","summary":"Problems 4 Clearly, For arbitrary $a,c \\in G$ and $b,d \\in H$ \\begin{aligned} \u0026ac = ca \\wedge bd = db \\\\ \\leftrightarrow \u0026(ac, bd) = (ca, db) \\\\ \\leftrightarrow \u0026(a,b)(c,d) = (c,d)(a,b) \\end{aligned} I guess the general case is any group-theoretic property on both $G$ and $H$ is also on $G \\oplus H$, and vice verca.","tags":null,"title":"Chapter 08","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Materials Book: Volume I. A First Course in Randomized Algorithms by Nick Harvey. Problem Set Chapter Content Ch 01 PDF, HTML Ch 02 PDF, HTML ","date":1702252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702252800,"objectID":"8b951e739da2946b105a394d0dc4e1a4","permalink":"https://mostafatouny.github.io/post/harvey-rand-pset/","publishdate":"2023-12-11T00:00:00Z","relpermalink":"/post/harvey-rand-pset/","section":"post","summary":"Self-studying randomized algorithms by Nick Harvey, British Columbia","tags":null,"title":"Harvey's Randomized Algorithms","type":"post"},{"authors":null,"categories":null,"content":"Exercises 8.1.3 Homework.\n8.1.5 Homework.\n8.1.6 Hints\nExplain why is the formulation $F(n) = F(n-1) + p_1$ is wrong. Derive a counter example. The optimal solution may be $F(n) = p_n$. Modify it so that it is in terms of $F(k)$ for some $k \u0026lt; n$. Generalize. Solution\nRecursive formulation. \\begin{aligned} F(0) \u0026amp;= 0 \\\\ F(n) \u0026amp;= \\underset{1 \\leq j \\leq n}{\\max} {p_j + F(n-j) } \\end{aligned}\nAlgorithm.\n# input: Length n, and values of pieces of length i, P[i] # output: Maximum value of all possible cuts on a rod of length n def dynamicRodCut(n, P[0..n]) # a rod of length zero contributes nothing to revenue P[0] = 0 # Initialize an array of size n F = [] * (n+1) # Set the base case F[0] = 0 # Compute bottom-up F[i] for i in 1..n maxVal = 0 # Compute the maximum among all js for j in 0..i # call memoized subinstances # update if found a greater value maxVal = max( maxVal, P[j] + F(i-j) ) # memoize F[i] = maxVal # return max value of cuts, on given length n return F[n] Complexity. Time is $1 + \\dots + n = n(n+1)/2$. Additional space is $n+1$.\n8.2.2 Homework.\n8.2.3 Homework.\n8.2.5 Hints\nRecall for the algorithm given in the book, at each step, either we take or leave the ith item. For our case what if we at each step, either leave all items, or take 1st item, or take 2nd item, .., or nth item. Modify the formulation. Solution\nRecursive Formulation. \\begin{aligned} F(W) \u0026amp;= 0 \\qquad \u0026amp;\\text{if } W \u0026lt; w_j, ; 1 \\leq j \\leq n \\\\ F(W) \u0026amp;= \\underset{j: W \\geq w_j}{\\max} F(W - w_j) + v_j \u0026amp;\\text{otherwise} \\end{aligned}\nAlgorithm\n# memory function # input: i indicating selecting a multiset of item 1, item 2, .., item i j capacity # output: optimal value of a feasible multiset from item 1, item 2, .., item i def MFKnapsack(i, j, weight, value, F) # only if not memoized, compute and cache it if F[i,j] \u0026lt; 0 # find the maximum value among all cases # item i added 0, 1, 2, .. times constrained by capacity count = 0 while (count * weight[i]) \u0026lt; j maxVal = max( maxVal, (count * value[i]) + MFKnapsack( i-1, j - (count * weight[i]) ) ) # memoize F[i,j] = maxVal return F[i,j] # input: weight of ith item, value of ith item, total capacity W # output: max value of a multiset of all given n items # constrained by capacity W def dynamicKnapsack(weight[1..n], value[1..n], W) # memoization table # all cells -1, indicating no value is computed F[0..n, 0..W] = -1 # except row 0 and column 0, values are 0, by definition of base case for i in 0..n, F[i,0] = 0 for i in 0..W, F[0,i] = 0 # compute memoization table F, and read F[n, W] sol = MFKnapsack(n, W, weight, value, F) # problem solution is F[n, W] return sol 8.3.4 Homework.\n8.3.8 Hints.\nRecall you have table $R$, where $R[i,j]$ contains the root of the tree of nodes $i, \\dots, j$. Recall how the optimal solution of knapsack was constructed. Solution.\n# global variables: table R of roots indices keys A # input: root node of a tree, and indices i and j of keys covered # output: None. Tree is modified so the root points to its children # initialize with i = 1 and j = n # def optimalBST(root, i, j) # base case if root = NULL return # index of the root of subtree of keys A_i, .., A_j k = R[i,j] # left child root.left = A[ R[i, k-1] ] # right child root.right = A[ R[k+1, j] ] # Recursively, Call the child optimalBST(root.left, i, k-1) optimalBST(root.right, k+1, j) P.S. Anything by Donald Knuth is worthwhile studying, however for our pragmatic purposes we omit the analysis bounding $\\mathcal{O}(n^2)$.\n","date":1702252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1702252800,"objectID":"ae44a3d91d4e50adeded52b7b8b51c49","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab08/","publishdate":"2023-12-11T00:00:00Z","relpermalink":"/msa-levitin-post/lab08/","section":"msa-levitin-post","summary":"Exercises 8.1.3 Homework.\n8.1.5 Homework.\n8.1.6 Hints\nExplain why is the formulation $F(n) = F(n-1) + p_1$ is wrong. Derive a counter example. The optimal solution may be $F(n) = p_n$.","tags":null,"title":"Lab 08","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 7.1.2 Homework.\n7.1.5 We tell students sort by a single loop rather than a single-line.\ndef sortBySingleLoop(A[0..n-1]) # initialize a zeros list of size n S = [0] * n # loop on A values, Convert to corresponding index, Set that index for i in 0..n-1 S[ A[i]-1 ] = A[i] # S is A but sorted return S 7.1.10 Homework.\n7.2.2 Homework.\n7.2.3 Homework.\n7.2.11 a Hints\nThe question asks for memory. So any timely inefficient solution is acceptable. Use naive brute-force. Solution\n# input: strings S[0..n-1] and T[0..n-1] # output: True if and only if T is right cyclic shift def bruteForceRightCyclicShift(S[0..n-1], T[0..n-1]) # try all ith positions for i in 0..n-1 # counter of matched characters k = 0 # check from the ith position to last nth character, cycling if needed while k \u0026lt; n and S[(i+k) mod n] = T[k] k = k + 1 # all n characters are matching, i.e strings are matching if k == n return True # if no position matches return False If the mod operation is troublesome to students, we show\n# input: position x # output: # x if x did not pass string length n # if x passed n, return only the additional length beyond n def myPosition(x, n) if x \u0026lt; n return x return x - n # input: strings S[0..n-1] and T[0..n-1] # output: True if and only if T is a right cyclic shift of S def bruteForceRightCyclicShift(S[0..n-1], T[0..n-1]) # try all ith positions for i in 0..n-1 # counter of matched characters k = 0 # check from the ith position to last nth character, cycling if needed while k \u0026lt; n and S[ myPosition(i+k,n) ] = T[k] k = k + 1 # all n characters are matching, i.e strings are matching if k == n return True # if no position matches return False Observe greatest value of x is $n-1 + n-1 = 2n - 2 \u0026lt; 2n$. So our function myPosition is equivalent to mod operation in this case.\nComplexity. Extra space is $\\mathcal{O}(1)$. Time is $\\mathcal{O}(n^2)$.\nb Hints\nUse Boyer-Moore algorithm as a subroutine. What is the input enhancement so that a linear scan, of all possible positions, of first character, is feasible? Repeat the input so the check is equivalent to cycling. Solution\n# input: string S # output: S but with n-1 prefix appended def appendPrefix(S[0..n-1]) # copy S X = S # for each character of n-1 prefix for i in 0..n-2 # append to the end X.append( X[i] ) # return appended string return X # input: string S[0..n-1] and T[0..n-1] # output: True if and only if T is a cyclic right shift of S def BoyerMooreRightCyclicShift(S[0..n-1], T[0..n-1]) # enhance the input by appending n-1 prefix S = appendPrefix(S) # right cyclic shift is equivalent to matching T in enhanced input S return BoyerMoore(S, T) For enhanced $X$ of given input $S$, Observe $S[i \\mod n] = X[i]$. In other words, our condition on the enhanced input is equivalent to the brute-force algorithm. Since we know the brute-force is correct by definition, so is BoyerMooreRightCyclicShift.\nComplexity.\nTime. $\\Theta(n)$ for appending prefix. $\\mathcal{O}(n)$ for Boyer-Moore algorithm (given from the levitin). Space. Extra space is $\\Theta(n)$ for appended prefix. $\\Theta(|\\sum|)$ for the good-suffix table. $\\Theta(n)$ for the bad-symbol table. 7.3.1 Homework.\n7.3.2 Homework.\n7.3.4 Given the even distribution of hash function, We have a uniform distribution. Fixing cell $c_j$ the probability of hashing to it is $Pr[R_i = c_j] = \\nfrac{1}{m}$ for the ith element out of the $n$ elements. Since the hash events are pairwise independent, $Pr[C = c_j] = Pr[R_1 = c_j \\wedge \\dots \\wedge R_n = c_j] = Pr[R_1 = c_j] \\cdot .. \\cdot Pr[R_n = c_j] = \\left (\\nfrac{1}{m} \\right )^n$. Since the events of hashing all elements to a particular cell are disjoint, $Pr[C = c_0 \\vee \\dots \\vee C_{m-1}] = Pr[C = c_0] + \\dots + Pr[C = c_{m-1}] = m \\left (\\nfrac{1}{m} \\right )^n = \\nfrac{1}{m^{n-1}}$.\n","date":1701648000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701648000,"objectID":"f65f57b84ac0ed5c5b8cbbe72905ccb3","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab07/","publishdate":"2023-12-04T00:00:00Z","relpermalink":"/msa-levitin-post/lab07/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 7.1.2 Homework.\n7.1.5 We tell students sort by a single loop rather than a single-line.\ndef sortBySingleLoop(A[0..n-1]) # initialize a zeros list of size n S = [0] * n # loop on A values, Convert to corresponding index, Set that index for i in 0.","tags":null,"title":"Lab 07","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"Problems 1 $\\phi(n) = 2n$. If $2a = 2b$ then $a = b$. For each $2k$ we have $\\phi(k) = 2k$. Observe $\\phi(ab) = 2(a+b) = 2a + 2b = \\phi(a)\\phi(b)$, Following by usual properties of integers.\n2 We Follow the same proof approach of Example 15 (page 130). Let $\\phi \\in Aut(Z)$ be arbitrary. Then by the usual properties of integers and isomorphisms, $\\phi(k) = \\phi(1 + 1 + \\dots + 1) = \\phi(1) + \\dots + \\phi(1) = k \\cdot \\phi(1)$. But by definition $\\phi(1) = c$ for some integer $c$. Therefore $\\phi(k) = kc$. In other words, $Aut(Z) = { \\phi \\mid \\exists c, ; \\forall k ; \\phi(k) = kc }$\n4 Caylay table of $U(8)$:\n1 3 5 7 1 1 3 5 7 3 3 1 7 5 5 5 7 1 3 7 7 5 3 1 Caylay table of $U(10)$:\n1 3 7 9 1 1 3 7 9 3 3 9 1 7 7 7 1 9 3 9 9 7 3 1 Recall from theorem 6.2 (page 126), Any $\\phi$ maps the identity to the identity of the other group.\nIn $U(8)$ we have $3 \\cdot 3 = 1$. Then $\\phi(3 \\cdot 3) = \\phi(3) \\cdot \\phi(3) = \\phi(1) = 1$. The only non-identity element in $U(10)$ satisfying that is $9$. Hence $\\phi(3) = 9$.\nSimilarly $5 \\cdot 5 = 1$. Then we must have some $a \\in U(10)$ such that $a \\cdot a = 1$ where $a \\notin { 1, 9 }$. Contradiction.\n8 Injective. Given $\\log_{10} a = \\log_{10} b$, we get $10^{\\log_{10} a} = 10^{\\log_{10} b}$, and $a = b$.\nSurjective. Given $x \\in \\mathcal{R}$, take $a = 10^x \\in \\mathcal{R}^+$. Then $\\log_{10} a = \\log_{10} 10^x = x$.\nGroup Operation. Observe $\\phi(ab) = \\log_{10} ab = \\log_{10} a + \\log_{10} b = \\phi(a) + \\phi(b)$.\n11 Observe $\\phi(a^3 b^{-2}) = \\phi(a^3) + \\phi(b^{-2}) = [\\phi(a)]^3 + [\\phi(b)]^{-2} = (\\overline{a})^3 + (\\overline{b})^{-2}$. We used theorem 6.2 (2).\n12 $(\\rightarrow)$. For any $a,b \\in G$, We have: \\begin{aligned} \\alpha(a^{-1}b^{-1}) \u0026amp;= \\alpha(a^{-1}) \\alpha(b^{-1}) \\\\ (a^{-1} b^{-1})^{-1} \u0026amp;= \\\\ ba \u0026amp;= ab \\end{aligned}\n$(\\leftarrow)$. Symmetrically, If we have $b^{-1} a^{-1} = a^{-1} b^{-1}$, Then $\\alpha(ab) = \\alpha(a) \\alpha(b)$. Bijection is clear by properties of inverses.\n14 By theorem 6.5 (page 131), $Aut(Z_3) \\approx U(3)$ and $Aut(Z_4) \\approx U(4)$, so $Aut(Z_3) \\approx Aut(Z_4)$ by the transitivity of isomorphism. But $Z_3 \\not\\approx Z_4$ as the two groups have different orders, so no bijection exists.\n21 Clearly groups $H$ and $K$ are isomorphic to $S_4$. By transitivity $H \\approx K$.\n22 For every $c = 2, 3, 4 \\dots$, Consider the subset $H_c = { ck \\mid k \\in \\mathcal{Z} }$. It is a subgroup, As it has the identity $c(0)$, inverses $c(-k)$, and closed $ck_1 + ck_2 = c(k_1 + k_2)$.\nIt remains to show those subgroups are distinct. For any $c_1$ and $c_2$ where $c_1 \u0026lt; c_2$ we have $c_1(1) \\in H_{c_1}$ but $c_1(1) \\not\\in H_{c_2}$. Therefore $H_{c_1} \\neq H_{c_2}$.\n24 We use theorem 3.2 (page 63). If $\\phi(a) = a$ then $\\phi(a^{-1}) = (\\phi(a))^{-1} = a^{-1}$. Also, If $\\phi(a) = a$ and $\\phi(b) = b$ then $\\phi(ab) = \\phi(a) \\phi(b) = ab$.\n34 Let $K$ be a subgroup of $G$. We use theorem 3.2 (page 63).\nInverse. For any $\\phi(k) \\in \\phi(K)$, $(\\phi(k))^{-1} = \\phi(k^{-1})$. But $k^{-1} \\in K$, So $\\phi(k^{-1}) \\in \\phi(K)$.\nClosed. For $\\phi(k_1), \\phi(k_2) \\in \\phi(K)$, We have $\\phi(k_1) \\phi(k_2) = \\phi(k_1 k_2)$. But $k_1 k_2 \\in K$, So $\\phi(k_1 k_2) \\in \\phi(K)$.\n","date":1701388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701388800,"objectID":"35fbc67cf5477922e5511551a4c0821a","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset06/","publishdate":"2023-12-01T00:00:00Z","relpermalink":"/siniora-algebra-post/pset06/","section":"siniora-algebra-post","summary":"Problems 1 $\\phi(n) = 2n$. If $2a = 2b$ then $a = b$. For each $2k$ we have $\\phi(k) = 2k$. Observe $\\phi(ab) = 2(a+b) = 2a + 2b = \\phi(a)\\phi(b)$, Following by usual properties of integers.","tags":null,"title":"Chapter 06","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Forward TBD\nMaterials Data Mining: Practical Machine Learning Tools and Techniques by Witten, Frank, Hall, and Pal, 4th ed. Labs Lab Notebook Lab 00 IPYNB, PDF Lab 01 IPYNB, PDF Lab 02 IPYNB, PDF Lab 03 IPYNB, PDF Lab 04 IPYNB, PDF Lab 05 IPYNB, PDF Lab 06 IPYNB, PDF Lab 07 IPYNB, PDF Lab 08 IPYNB, PDF Lab 09 IPYNB, PDF ","date":1700438400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700438400,"objectID":"5157288db88de64dad0b78008b36118c","permalink":"https://mostafatouny.github.io/post/msa-waikato-lab/","publishdate":"2023-11-20T00:00:00Z","relpermalink":"/post/msa-waikato-lab/","section":"post","summary":"A course TAed with Dr. Islam El-Shaarawy, Modern Sciences and Arts (MSA).","tags":null,"title":"Waikato's Data Mining","type":"post"},{"authors":null,"categories":null,"content":"Problems 1 a $$ \\alpha^{-1} = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \\\\ 2 \u0026amp; 1 \u0026amp; 3 \u0026amp; 5 \u0026amp; 4 \u0026amp; 6 \\end{bmatrix} $$\nb $$ \\beta \\alpha = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \\\\ 1 \u0026amp; 6 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \\end{bmatrix} $$\nc $$ \\alpha \\beta = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \\\\ 6 \u0026amp; 2 \u0026amp; 1 \u0026amp; 5 \u0026amp; 3 \u0026amp; 4 \\end{bmatrix} $$\n3(b) b. $(1 2 4)(3 5)(6)$\n6(a) a. disjoint cycles form: $(1 2)(3 5 6)$. Order is $6$.\n8(c,d) c. $(1 7)(1 6)(1 5)(1 3)$.\nd. $(2 4)(2 3)(1 5)$.\n10 We want to find some permutation $$ \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp;\n\\end{bmatrix} $$\nwhere:\nOrder is $15$, i.e $lcm$ of disjoint cycles lengths is $15$, and Even, i.e Has an even number of 2-cycles. Observe $15 = 3 \\cdot 5$ which suggests two disjoint cycles of lengths $3$ and $5$. A standard candidate is $(1 2 3)(4 5 6 7 8)$. Its 2-cycles form: $(4 8)(4 7)(4 6)(4 5)(1 3)(1 2)$, A total of even 6 cycles.\nThe permutation in matrix form is: $$ \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \u0026amp; 7 \u0026amp; 8 \\\\ 2 \u0026amp; 3 \u0026amp; 1 \u0026amp; 5 \u0026amp; 6 \u0026amp; 7 \u0026amp; 8 \u0026amp; 4 \\end{bmatrix} $$\n17 Using theorem 3.3 (page 64), It suffices to show the set of even permutations are closed under permutation composition. By definition, Given even permutations $\\alpha = (a b)(c d) \\dots (e f)$ and $\\beta = (g h)(i j) \\dots (k l)$, The composition $\\alpha \\beta = (a b) \\dots (k l)$ consists of even number of 2-cycles, As even + even = even.\n23 Let $H$ be a subgroup of $S_n$. Assume not every member is even. We show $H$ must have an equal number of even and odd members.\nWe follow the same proof approach of theorem 5.7 (page 104). We know there is an odd member $\\alpha$. For every odd $\\beta$, $\\alpha \\beta$ is even, So there as many evens as there are odds. For every even $\\beta$, $\\alpha \\beta$ is odd, So there are as many odds as there are evens. Therefore, the number of even and odd members are equal.\n25 The identity permutation is even. Not closed as the composition of two odd members is even.\n43 For $n \\geq 3$, It is easy to see $(1 2) \\in S_n$ and $(2 3) \\in S_n$. However\n$$ (2 3)(1 2) = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \\\\ 3 \u0026amp; 1 \u0026amp; 2 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \\end{bmatrix} \\neq \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \\\\ 2 \u0026amp; 3 \u0026amp; 1 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \\end{bmatrix} = (1 2)(2 3) $$\n","date":1700265600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700265600,"objectID":"c9ee1eae00ea4a3a58c452afa7266a3c","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset05/","publishdate":"2023-11-18T00:00:00Z","relpermalink":"/siniora-algebra-post/pset05/","section":"siniora-algebra-post","summary":"Problems 1 a $$ \\alpha^{-1} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \\\\ 2 \u0026 1 \u0026 3 \u0026 5 \u0026 4 \u0026 6 \\end{bmatrix} $$","tags":null,"title":"Chapter 05","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Forward TBD\nMaterials Book: Introduction to The Design and Analysis of Algorithms by Levitin, 3rd edition. Problem Set Lab Content Lab 01 - Ch 01 PDF, HTML Lab 02 - Ch 02 PDF, HTML Lab 03 - Ch 03 PDF, HTML Lab 04 - Ch 04 PDF, HTML Lab 05 - Ch 05 PDF, HTML Lab 06 - Ch 06 PDF, HTML Lab 07 - Ch 07 PDF, HTML Lab 08 - Ch 08 PDF, HTML Lab 09 - Ch 09 PDF, HTML ","date":1700265600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700265600,"objectID":"bd0a6a75d1dbda89c70cb0133b755144","permalink":"https://mostafatouny.github.io/post/msa-levitin-lab/","publishdate":"2023-11-18T00:00:00Z","relpermalink":"/post/msa-levitin-lab/","section":"post","summary":"A course TAed with Dr. Islam El-Shaarawy, Modern Sciences and Arts University (MSA)","tags":null,"title":"Levitin's Algorithms","type":"post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 1 (b). No. 3/2 is not an integer.\n(d). Yes. $cA$ is a totally valid matrix for any scalar $c$ or matrix $A$.\n2 (a). Yes.\n(b). No. $\\frac{\\displaystyle{1/2}}{\\displaystyle{3}} = \\frac{\\displaystyle{1}}{\\displaystyle{2}} \\frac{\\displaystyle{1}}{\\displaystyle{3}} \\neq \\frac{\\displaystyle{3}}{\\displaystyle{2}} = \\frac{\\displaystyle{1}}{\\displaystyle{2/3}}$.\n(e). No. $(2^2)^3 = 2^6 \\neq 2^8 = 2^{(2^3)}$\n3 (c). No. $3(x^2) \\neq 3^2 x^2 = (3x)^2$.\n(d). No. Known from linear algebra.\n5 (a). $20 - 13 = 7$.\n(b). The problem is reduced to finding $x$ and $y$ such that $13x = 14y + 1$. In other familiar notation from chapter 1, $13x - 14y = 1$. Clearly $13(-1) + (-14)(-1) = 1$ so $13(-1 + 14) + (-14)(-1 + 13) = 1$. Thus the inverse of $13$ is $13$.\n7 Not closed. $1 + 3 = 4$.\nNo inverse. $3 + x \\neq 1$ for any odd integer $x$.\n14 $(ab)^3 = ababab$.\n$(ab^{-2}c)^{-2} = (ab^{-2}c)^{-1} (ab^{-2}c)^{-1} = c^{-1}b^{-3}a^{-1}c^{-1}b^{-3}a^{-1}$\n16 Fact. $x^n$ is an odd integer for any odd $x$.\nFact. The summation of two even integers is even.\nWe take a different perspective of the problem by the set ${ (5 \\cdot 1), (5 \\cdot 3), (5 \\cdot 5), (5 \\cdot 7) }$ modulo $5 \\cdot 8$. Upon multiplying any two elements we get the form $5 \\cdot 5 \\cdot x \\cdot y$ where $x,y \\in { 1, 3, 5, 7 }$. Think of the output of multiplication as the factor of $5$ deciding the element.\nObserve the element is decided by $5 \\cdot x \\cdot y \\mod 8$. For example if we knew $5 \\cdot 5 \\cdot 5 \\cdot 1 = (5)(8 + 8 + 8 + 1)$ then we can easily deduce the output of $\\mod 5 \\cdot 8$ operation is $(5)(1)$.\nThe numbers $1$, $3$, $5$, and $7$ are all odds. So whatever $x$ or $y$ chosen, $5 \\cdot x \\cdot y$ will be odd. It follows $\\textit{odd} \\mod 8 = \\textit{odd} \\in {1, 3, 5, 7}$. To see why note $8k + \\textit{odd} = \\textit{odd}$.\nLemma. The given set is closed under the given operation.\nLemma. The identity is $5 \\cdot 5 = 25$.\nObserve $5 \\cdot 5 \\cdot x \\mod 8 = 24x + x \\mod 8 = x \\mod 8$ since $24x \\mod 8 = 0$.\nLemma. THe inverse of $5x$ is $5x$ by computation on the given elements.\nLemma. Associativity is known from integers and modulus properties.\n18 $(R_0)^2 = (R_{180})^2 = H^2 = V^2 = D^2 = (D’)^2 = R_0$.\n$(R_{90})^2 = (R_{270})^2 = R_{180}$.\nSo $K = { R_0, R_{180} }$, and $L = { R_0, R_{180}, H, V, D, D’ }$.\n33 Observe the group follows the same pattern as $\\mathcal{Z}_4$.\ne a b c d e e a b c d a a b c d e b b c d e a c c d e a b d d e a b c inverses. Since $ad = e$, $d = a^{-1}$. Since $bc = e$, $c = b^{-1}$.\nab = c. $ab = (cc)b = c(cb) = ce = c$.\ndb = a. $db = d(aa) = (da)a = ea = a$.\ncd = b. $cd = c(bb) = (cb)b = eb = b$.\ndc = b. $dc = (bb)c = b(bc) = be = b$.\nac = d. $d = bb = (aa)(dc) = a(ad)c = ac$.\nbd = a. $bd = (dc)(bb) = d(cb)b = db = a$.\ndd = c. $dd = (ac)(bb) = a(cb)b = ab = c$\n34 $(\\leftarrow)$. Given $ab = ba$ \\begin{aligned} (ab)^2 \u0026amp;= (ab)(ab) \\\\ \u0026amp;= a(ba)b, \\text{Associativity} \\\\ \u0026amp;= a(ab)b \\\\ \u0026amp;= (aa)(bb), \\text{Associativity} \\\\ \u0026amp;= a^2b^2 \\end{aligned}\n$(\\rightarrow)$. Given $(ab)^2 = a^2b^2$ \\begin{aligned} (ab)^2 \u0026amp;= (ab)(ab) \\\\ \u0026amp;= a(ba)b \\\\ \u0026amp;= aabb \\\\ ba \u0026amp;= ab, \\text{Cancellation} \\end{aligned}\n$(\\leftarrow)$. Given $ab = ba$ \\begin{aligned} (ab)^2 \u0026amp;= (ab)^{-1} (ab)^{-1} \\\\ \u0026amp;= b^{-1} a^{-1} b^{-1} a^{-1} \\\\ \u0026amp;= b^{-1} (ba)^{-1} a^{-1} \\\\ \u0026amp;= b^{-1} (ab)^{-1} a^{-1} \\\\ \u0026amp;= b^{-1} b^{-1} a^{-1} a^{-1} \\\\ \u0026amp;= (b)^{-2} (a)^{-2} \\end{aligned}\n$(\\rightarrow)$. Given $(ab)^{-2} = b^{-2} a^{-2}$ \\begin{aligned} (ab)^{-1} (ab)^{-1} \u0026amp;= b^{-1} a^{-1} b^{-1} a^{-1} \\\\ \u0026amp;= b^{-1} b^{-1} a^{-1} a^{-1} \\\\ a^{-1} b^{-1} \u0026amp;= b^{-1} a^{-1}, \\text{Cancellation} \\\\ (ba)^{-1} \u0026amp;= (ab)^{-1} \\end{aligned}\nNow observe by the definition of inverse, if $x = y^{-1}$ then $y = x^{-1}$. Therefore $ab = [ (ab)^{-1} ]^{-1}$ and $ba = [ (ba)^{-1} ]^{-1}$, and $ab = ba$.\n47 Clearly $aabb = a^2b^2 = ee = e$, and $abab = (ab)^2 = e$. It follows $aabb = abab$, and by cancellation $ab = ba$.\n","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"94f2102bec08ad59888a0a0c0a09778d","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset02/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/siniora-algebra-post/pset02/","section":"siniora-algebra-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 1 (b). No. 3/2 is not an integer.\n(d). Yes. $cA$ is a totally valid matrix for any scalar $c$ or matrix $A$.\n2 (a). Yes.\n(b). No. $\\frac{\\displaystyle{1/2}}{\\displaystyle{3}} = \\frac{\\displaystyle{1}}{\\displaystyle{2}} \\frac{\\displaystyle{1}}{\\displaystyle{3}} \\neq \\frac{\\displaystyle{3}}{\\displaystyle{2}} = \\frac{\\displaystyle{1}}{\\displaystyle{2/3}}$.","tags":null,"title":"Chapter 02","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 2 $(Q, +)$. ${ \\frac{\\displaystyle{x}}{\\displaystyle{2}} \\mid x \\in \\mathcal{Z} }$.\n$(Q^*, *)$. ${ 2^x \\mid x \\in \\mathcal{Z}^+ } \\cup { \\frac{\\displaystyle{1}}{\\displaystyle{2^x}} \\mid x \\in \\mathcal{Z}^+ } \\cup { 1 }$.\n4 Consider $|x| = n$. Then $x^n = 1$ and no positive $r \u0026lt; n$ where $x^r = 1$. It follows. \\begin{aligned} (x^n)^{-1} \u0026amp;= (1)^{-1} \\\\ (x \\cdot x \\cdot \\dots \\cdot x)^{-1} \u0026amp;= 1 \\\\ x^{-1} \\cdot \\dots \\cdot x^{-1} \u0026amp;= \\\\ (x^{-1})^n \u0026amp;= \\end{aligned} Analogously if $(x^{-1})^r = 1$ then $x^r = 1$. That cannot happen for $r \u0026lt; n$.\n6(b) Identity is $e = 0$.\n$|3| = 4$. $|8| = 3$. $|11| = 12$.\n7 Fact. For any element $x$ in any group, $x^{n+m} = x^n x^m$.\nFact. For any element $x$ in any group, $(x^{k})^m = x^{km}$. \\begin{aligned} (a^4 c^{-2} b^4)^{-1} \u0026amp;= (b^4)^{-1} (c^{-2})^{-1} (a^4)^{-1} \\\\ \u0026amp;= (b^4)^{-1} (c^2 ) (a^4)^{-1} \\\\ \u0026amp;= (b^7 b^{-3})^{-1} (c^2) (a^6 a^{-2})^{-1} \\\\ \u0026amp;= (b^{-3})^{-1} (c^2) (a^{-2})^{-1} \\\\ \u0026amp;= b^3 c^2 a^2 \\end{aligned}\n10 We naively construct all possible subgroups, pruning possible branches by their properties.\nAny subgroup must have the identity element. ${R_0}$. (+1)\n${R_0, X}$ is a subgroup for any reflection $X = H,V,D,D’$. (+4)\nConsidering a subgroup with ${R_0, X_0, X_1}$ for distinct reflections $X_0, X_1$ it must be the case we get rotation $R_s$ for $s \\neq 0$. So we cannot have a subgroup restricted on reflections other than the aforementioned case.\n${ R_0, R_{180} }$. (+1)\nFor any subgroup with $R_{90}$ or $R_{270}$, since it is closed it must contain also ${ R_0, R_{90}, R_{180}, R_{270} }$. (+1)\nFor any subgroup containing ${ R_0, R_{180}, H }$ it must contain also ${ R_0, R_{180}, H, V }$. For any subgroup containing ${ R_0, R_{180}, V }$ it must contain also ${ R_0, R_{180}, V, H }$. (+1)\nFor any subgroup containing ${ R_0, R_{180}, D }$ it must contain also ${ R_0, R_{180}, D, D’ }$. For any subgroup containing ${ R_0, R_{180}, D’ }$ it must contain also ${ R_0, R_{180}, D, D’ }$. (+1)\nFor any subgroup containing $R_s$ for $s \\neq 180$ and any reflection $X = H, V, D, D’$, since it is closed, it must contain also ${ R_0, R_{90}, R_{180}, R_{270}, H, V, D, D’}$. (+1)\nSo far we counted 10 subgroups.\n19 We show the contrapositive. Assume $a^m = a^n$ for $m \u0026gt; n$. Then $a^m a^{-n} = a^n a^{-n}$ implying $a^{m-n} = e$, but $m - n \u0026gt; 0$ so $a$ is of a finite order.\n30 The question presumes the uniqueness of $H$. We won’t prove it.\n$H = { 2 (9 k_1 + 15 k_2 + 20 k_3) \\mid k_1,k_2,k_3 \\in \\mathcal{Z} }$.\nTaking $k_1 = k_2 = k_3 = 0$ yields the identity $e = 0$. For $x \\in H$ corresponding to $k_i$, Take $-(k_i)$ to obtain the inverse. Closed property is clear from the definition. Associativity follows from $G$. Odd numbers are excluded conforming to the fact $H$ is a proper subgroup.\n34 Since $e \\in H$ and $e \\in K$ by definition, We have $e \\in H$.\nif $x,y,z \\in H \\cap K$, then $x,y,z \\in H$ and associativity follows.\nif $x \\in H \\cap K$, then $-x \\in H$ and $-x \\in K$, and any element has an inverse.\nif $x,y \\in H \\cap K$, then $x + y \\in H$ and $x + y \\in K$ by properties of a group.\nA trivial argument by induction shows the intersection of any number of subgroups.\n","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"eaa9ef0f021f7307c9c7c5f38a00510c","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset03/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/siniora-algebra-post/pset03/","section":"siniora-algebra-post","summary":"Problems 2 $(Q, +)$. ${ \\frac{\\displaystyle{x}}{\\displaystyle{2}} \\mid x \\in \\mathcal{Z} }$.\n$(Q^*, *)$. ${ 2^x \\mid x \\in \\mathcal{Z}^+ } \\cup { \\frac{\\displaystyle{1}}{\\displaystyle{2^x}} \\mid x \\in \\mathcal{Z}^+ } \\cup { 1 }$.","tags":null,"title":"Chapter 03","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Problems 1 By corollary 4 (page 80).\nGenerators of $\\mathcal{Z}_6$ are $1,5$ since $gcd(1,6) = gcd(5,6) = 1$.\nGenerators of $\\mathcal{Z}_8$ are $1,3,5,7$ since $gcd(1,8) = gcd(3,8) = gcd(5,8) = gcd(7,8) = 1$.\nGenerators of $\\mathcal{Z}_{20}$ are $1,3,7,9,11,13,17,19$ since $gcd(1,20) = gcd(3,20) = gcd(7,20) = gcd(9,20) = gcd(11,20) = gcd(13,20) = gcd(17,20) = gcd(19,20) = 1$.\n5 $\\langle 3 \\rangle = \\{ 3^0, 3^1, 3^2, 3^3, 3^4, 3^5, \\dots\\} \\cup \\{ 3^{-1}, 3^{-2}, 3^{-3}, 3^{-4}, 3^{-5}, \\dots \\} = \\{0, 3, 9, 7 , 1, 3, \\dots\\} \\cup \\{ -3, 9, -7, 1, -3, \\dots \\} = \\{0, 3, 9, 7 , 1, 3\\} \\cup \\{ 17, 9, 13, 1, 17 \\} = \\{0, 1, 3, 7, 9, 13, 17\\}$.\n$\\langle 7 \\rangle = \\{ 7^0, 7^1, 7^2, 7^3, 7^4, 7^5, \\dots\\} \\cup \\{ 7^{-1}, 7^{-2}, 7^{-3}, 7^{-4}, 7^{-5}, \\dots \\} = \\{ 0, 7, 9, 3, 1, 7, \\dots \\} \\cup \\{ -7, 9, -3, 1, -7, \\dots \\} = \\{ 0, 7, 9, 3, 1 \\} \\cup \\{ 13, 1, 17, 1 \\} = \\{ 0, 1, 3, 7, 9, 13, 17 \\}$\n10 By corollary (page 82). One generator is $\\langle 24/8 \\rangle = \\langle 3 \\rangle = \\{ 3^0, 3^1, 3^2, 3^3, 3^4, 3^5, 3^6, 3^7, 3^8, 3^9 \\} \\cup \\{ 3^{-1}, 3^{-2}, 3^{-3}, 3^{-4}, 3^{-5}, 3^{-6}, 3^{-7}, 3^{-8}, 3^{-9} \\} = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 0 \\} \\cup \\{ 21, 6, 15, 12, 9, 18, 3, 0, 21 \\} = \\{ 0, 3, 6, 9, 12, 15, 18, 21 \\}$\nNote any generator of that subgroup must be contained in it as $a = a^1 \\in \\langle a \\rangle$.\nBy corollary 3 (page 80). Generators are $3^5 = 15$ and $3^7 = 21$, as $gcd(24,5) = gcd(24, 7) = 1$.\nBy corollary 3 (page 80). Generators of arbitrary $G$ are $1,5,7,11,13,17,19,23$ since $gcd(24,i) = 1$. Observe since $G$ is generated by $a$, Any candidate must be of the form $a^i$. So we covered all of them.\n11 Follows trivially by corollary 3 (page 80), as $gcd(n, -1) = 1$.\n27 We know given a positive integer $n$, there is a complex $z$ such that $z^n = 1$. Then $S_n = \\{ z^0, z^1, z^2, \\dots \\} = \\{ z^0, z^1, \\dots, z^{n-1} \\}$. Clearly it is a group.\nFor $z^{-i}$ observe $-i = n(m) + r$ where $0 \\leq r \u0026lt; n$. Then $-i-r$ is divisable by $n$, and by theorem 4.1 (page 76), $z^{-i} = z^r$. Then $\\{ z^{-1}, z^{- 2}, \\dots \\}$ is contained in $S_n$.\nThus we conclude $S_n = \\langle z \\rangle$ is a subgroup of order $n$.\n30 We call a subgroup new if it is not ${e}$ or $G$. Observe constructing it contradicts a given hypothesis.\nSelect $a \\neq e$. If $\\langle a \\rangle$ is of infinite order, then $\\langle a^2 \\rangle$ is a new subgroup. So $\\langle a \\rangle$ is of finite order $n$.\nIf $\\langle a \\rangle \\neq G$ then $\\langle a \\rangle$ is a new subgroup. So $\\langle a \\rangle = G$.\nIf $n$ is not prime, i.e composite, then by theorem 4.3 (page 81), we can take divisor $k$ such that $\\langle a^{n/k} \\rangle$ is a new subgroup of order $k$. Note by divisibility $1 \u0026lt; k \u0026lt; n$.\nIt follows $G$ is a finite cyclic group of prime order $n$.\n36 4 8 12 16 4 16 12 8 4 8 12 4 16 8 12 8 16 4 12 16 4 8 12 16 All entries are contained in ${ 4, 8, 12, 16 }$, So closed. $16$ is the identity. Every row has an $16$ entry showing inverses existince. The group is cyclic.\nIts generators are all its elements, $4, 8, 12$ and $16$. To see why you can trace the table. For example $8^1 = 8$, $8^2 = 4$, $8^3 = 8^2 \\cdot 8 = 4 \\cdot 8 = 12$, $8^4 = 8^3 \\cdot 8 = 12 \\cdot 8 = 16$.\n48 $H$ is a subgroup by Theorem 3.2 (page 63). Given $a = 10 k_0 = 8 k_1$ and $b = 10 k_2 = 8 k_3$, Trivially $a+b = 10(k_0 + k_2) = 8(k_1 + k_3) \\in H$. Also $-a = 10 (-k_0) = 8 (-k_1) \\in H$.\n$H$ is not a subgroup in case of \u0026#34;OR\u0026#34;. Consider the counter-example $10 + 8 = 18$ as $18$ is neither divisible by $10$ nor $8$, Violating closeness property.\n59 Partially Solved.\nLet $G$ be a group with only $a$ and $b$ elements of order 2. We try to come-up with a contradiction.\nBy definition $a^2 = b^2 = e$, so $a^{-1} = a$ and $b^{-1} = b$. Clearly $ab \\neq a, b$, or $e$. For example if $ab = e$ then $b = a^{-1} = a$ which is not true as $a$ and $b$ are given as distinct elements.\nCase $ab = ba$. Then $(ab)^2 = (ab)(ba) = aea = a^2 = e$. Contradiction.\nCase $ab \\neq ba$. No solution found for that case.\n61 Let $x \\in \\langle a \\rangle \\cap \\langle b \\rangle$. Then by corollary 1 (page 79), $|x|$ divides both $10$ and $21$. Since they are coprime, $|x| = 1$ and $x^1 = x = e$.\n","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"e5223ec9bc3071521cde17464a74fc38","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset04/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/siniora-algebra-post/pset04/","section":"siniora-algebra-post","summary":"Problems 1 By corollary 4 (page 80).\nGenerators of $\\mathcal{Z}_6$ are $1,5$ since $gcd(1,6) = gcd(5,6) = 1$.\nGenerators of $\\mathcal{Z}_8$ are $1,3,5,7$ since $gcd(1,8) = gcd(3,8) = gcd(5,8) = gcd(7,8) = 1$.","tags":null,"title":"Chapter 04","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"Forward TBD\nMaterials Lecture Notes Book: Abstract Algebra by Joseph Gallian, 9th ed. Problem Set Chapter Solution Grading Ch00 PDF, HTML PDF Ch01 PDF, HTML PDF Ch02 PDF, HTML PDF Ch03 PDF, HTML PDF Ch04 PDF, HTML PDF Ch05 PDF, HTML PDF Ch06 PDF, HTML PDF Ch07 PDF, HTML Ch08 PDF, HTML Ch09 PDF, HTML Ch10 PDF, HTML Ch11 PDF, HTML Ch12 PDF, HTML Ch13 PDF, HTML Ch14 PDF, HTML ","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"c976b7eb9ea7a357efd149cd9c1ef9b4","permalink":"https://mostafatouny.github.io/post/siniora-algebra-pset/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/post/siniora-algebra-pset/","section":"post","summary":"A course audited by Dr. Daoud Siniora, The American University in Cairo (AUC)","tags":null,"title":"Gallian's Abstract Algebra","type":"post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 3.1.4 Hints\nObserve we can derive $x^i$ from $x^{i-1}$, so we don’t need to recompute Solution\nSame as manual:\n3.1.14 Homework\n3.2.8 Hints\nFollowing the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z \u0026gt; i$, What can you infer? Utilize that observation in algorithm design. Consider a flag which stores whether character $A$ is read. Generalize for a variable that counts how many $A$ was read. Solution\n(a)\ndef count_substrings_starting_with_a_ending_with_b(S[0..n-1]): count = 0 for i in 0..n-2 if S[i] == A for j in i+1..n-1 if S[j] == B count = count + 1 return count The number of basic operations is upperbounded by $\\sum_{i=0}^{n-2} \\sum_{j=i+1}^{n-1} 1 = \\mathcal{O}(n^2)$.\n(b)\ndef count_substrings_starting_with_a_ending_with_b(S[0..n-1]): count_a = 0 # Count of \u0026#39;A\u0026#39; characters encountered so far count_ab = 0 # Count of substrings starting with \u0026#39;A\u0026#39; and ending with \u0026#39;B\u0026#39; for i in 0..n-2: if S[i] == A count_a = count_a + 1 else if S[i] == B count_ab = count_ab + count_a return count_ab $\\sum_{i=0}^{n-2} 1 = \\Theta(n)$. Observe count of basic operations is exactly 1 per iteration.\n3.2.9 Homework\n3.3.3 Homework\n3.3.9 Hints\nThink of a unique property about extreme points, in terms of coordinates. What can you conclude about the point of maximum $x$ or $y$ coordinates? Solution\n# input: array of points, each point is a tuple of x and y coordinates # output: a list of exactly two extreme points def find_extreme_points(P[0..n]) # given n \u0026gt;= 2 # Initialize extreme points with the first point in the set min_x_point, min_y_point = P[0] max_x_point, max_y_point = P[0] # Iterate through the remaining points for i in P[1..n] x, y = i # Update max_x_point and max_y_point if needed if x \u0026gt; max_x_point: max_x_point = x max_y_point = y else if x == max_x_point and y \u0026gt; max_y_point: max_y_point = y # Update min_x_point and min_y_point if needed if x \u0026lt; min_x_point: min_x_point = x min_y_point = y else if x == min_x_point and y \u0026lt; min_y_point: min_y_point = y return [(min_x_point, min_y_point), (max_x_point, max_y_point)] 3.4.6 We assume the problem would always have a solution. We leave it as an exercise for students to detect the case of the non-existince of any solution.\nHints\nWhat can you conclude about the total sum of the whole set, given we have a partition of two subsets, each of total sum $p$? If we selected a subset whose sum is $k$, How do we compute the total sum of the remaining elements? Consider the special case of finding a single subset whose total sum is $p$. Design your algorithm to only rely upon searching through the domain of subsets. Solution\nThere is an elegant generator based on binary numbers. Since this is not the core focus of the question, We show an easier to understand code by recursion.\ndef generate_subsets(A[0..n-1]): if n == 0: return [ [] ] # Generate subsets without the last element subsets_without_last = generate_subsets( A[0..n-2] ) # Add the last element to each subset in subsets_without_last subsets_with_last = [ subset + [A[n-1]] for subset in subsets_without_last ] # Concatenate subsets with and without the last element return subsets_without_last + subsets_with_last 3.4.9 Homework.\n3.5.7 Homework\n3.5.8 Hints\nThe hinted picture of 2-colorable might be more useful. Try to construct a 2-colorable labeling on given graphs. Observe by symmetry you can start anywhere and with any colour. What if a vertex must be coloured with two different colours from two different vertices? Can we conclude colouring impossibility? Solution\n(a)\nmodify $dfs$ function in page 124 to maintain a two colours switching for each level, rather than $count$.\ndef switchColour(input_colour) if input_colour is white return black if input_colour is black return white def dfs(v, current_colour) if v.colour == NULL v.colour = current_colour else return v.colour == current_colour for each vertex w in V adjacent to v if not dfs( w, switchColour(current_colour) ) return False return True (b)\nmodify $bfs$ to maintain the depth alongside the vertex in the queue, and then colour according to whether the depth is even or odd.\ndef colourByDepth(depth_input) if depth_input is even return white if depth_input is odd return black def bfs(v) set v.depth = 0 v.colour = colourByDepth(v.depth) initialize a queue with v while the queue is not empty do for each vertex w in V adjacent to the front vertex f if w.colour == NULL w.depth = f.depth + 1 w.colour = colourByDepth(w.depth) add w to the queue else if w.colour != colourByDepth(f.depth+1) return False remove the front vertex from the queue return True ","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"82e450344fdf89ff8006b62f1092a35b","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab03/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/msa-levitin-post/lab03/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 3.1.4 Hints\nObserve we can derive $x^i$ from $x^{i-1}$, so we don’t need to recompute Solution\nSame as manual:\n3.1.14 Homework\n3.2.8 Hints\nFollowing the definition, If you knew $S[i] = A$, and $S[j] = S[z] = B$ for $j,z \u003e i$, What can you infer?","tags":null,"title":"Lab 03","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nInstructor Notes Lemma. $\\lfloor \\log n \\rfloor + 1 = \\lceil \\log (n+1) \\rceil$.\nWe know $n = 2^k + r$ for some $k \\geq 0$ and $0 \\leq r \u0026lt; 2^k$, ByEuclid’s Theorem and Archimedean Property. Then \\begin{aligned} k + 1 = \\log 2^{k+1} \\geq \\log (2^k + r + 1) \u0026gt; \\log (2^k + r) \\geq \\log 2^k = k \\end{aligned}\nThus, $\\lceil \\log(n + 1) \\rceil = \\lceil \\log (2^k + r + 1) \\rceil = k + 1$ and $\\lfloor \\log (n+1) \\rfloor = \\lfloor \\log(2^k + 1) \\rfloor = k$.\nLemma. Given $n$, If we repeatedly apply the operation $\\lfloor n/2 \\rfloor$ Then we reach $1$ after exactly $\\lfloor \\log n \\rfloor + 1$.\nConsider $n$ but in binary representation $(d_1 d_2 \\dots d_k)_2$, where $d_1 = 1$. Then by definition $(d_1 d_2 \\dots d_k)_2 / 2$\nyields a quotient $(d_1 \\dots d_{k-1})$ and remainder $d_k$. Since we are taking floor, We can safely ignore $d_k$. It is easy to we reach $d_1 = 1$ after exactly $k-1$ operations. But we know $k = \\lfloor \\log n \\rfloor$.\nExercises 4.1.4 Hints\nConsider the fact, for a fixed element $k$, All subsets either contain $k$, or does not contain $k$. Given all subsets not containing $k$, What do we generate when we append $k$ to each subset? Solution\nTop-down\ndef generateSubsets(A[0..n-1]) # base case, empty subset if A.length == 0 return [ [ ] ] lastElement = A[n-1] # smaller instance solution subsetsWithNoLast = generateSubsets(A[0..n-2]) # generate new solutions from smaller instance subsetsWithLast = [] for subset in subsetsWithNoLast subsetsWithLast.append( subset + [lastElement] ) # concatenate solutions return subsetsWithNoLast + subsetsWithLast Bottom-up (Iterative Improvement)\ndef generateSubsets(A[0..n-1]): n = A.length allSubsets = [ [ ] ] for i in 0..n-1: newSubsets = [] for subset in allSubsets: newSubsets.append( subset + [ A[i] ] ) allSubsets = allSubsets + newSubsets return allSubsets 4.1.10 Homework.\n4.2.3 (a) In matrix implementation $\\Theta(|V|^2)$, and in adjacency list implementation $\\Theta(|V| + |E|)$. Careful analysis won’t be shown as it is outside the scope of the lab, especially that students lack data structures foundations.\n(b)\nHints\nConsider a stack data structure Think in terms of recursion, Given a solved smaller instance, How do we augment it to reach a greater instance? Solution\n# a node is inserted in stack, only after calling its subgraph # Input: node, visited nodes list, stack # Output: NULL def dfs(node, visited, stack): visited.add( node ) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, stack) stack.insert(node) # Input: directed graph in adjacency list implementation # Output: Topological order of the graph def topologicalSortDfs(graph G): visited = set() # no multiple occurences in sets stack = [] # can be omitted if we assumed graph\u0026#39;s connectivity # and given a unique root (tree) for node in G(V): if node not in visited: dfs(node) return stack Another simpler implementation not based on DFS as a bonus answer. Preferred to students over DFS based implementation.\n# Input: directed graph in adjacency list implementation # Output: Topological order of the graph def topologicalsortRecursive(graph G): visited = set() # multiple occurences in sets stack = [] for node in G(V): if node not in visited: visited.add(node) topologicalSortRecursive(graph[node], visited, stack) stack.insert(0, node) return stack 4.2.8 Homework.\n4.3.7 Hints\nFor each bit string of size $n-1$, If we added $0$, What do we generate? Combine adding $0$ and $1$. Solution\n# Input: Positive integer n # Output All bit strings of length n def generateAllBitStrings(n): # base case if n == 1: return [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;] else # smaller instance solution smallerInstanceStrings = generateAllBitsStrings(n-1) # generate n instance from smaller instance nInstanceWithZero = [] for bitString in smallerInstanceStrings nInstanceWithZero.append(bitString + \u0026#34;0\u0026#34;) nInstanceWithOne = [] for bitString in smallerInstanceStrings nInstanceWithOne.append(bitString + \u0026#34;1\u0026#34;) return nInstanceWithZero + nInstanceWithOne 4.3.10 Homework.\n4.4.2 Hints\nConsider n separation, in case it is odd, and in case it is even. If odd, subtract from it only 1, to get an even number Since we are taking floor, We only need to care about the new even number. I.e we won’t count. Solution\ndef floorLog2Recursive(n): # Base case # log2(1) = 0 if n == 1: return 0 # n is even if n % 2 == 0: return 1 + floorLog2Recursive(n/2) # n is odd else return 0 + floorLog2Recursive( (n-1)/2 ) # Since we consider floor, the remainder does not count 4.4.9 Homework.\n4.5.12 Homework.\n4.5.13 Hints\nGiven the target $t \u0026gt;$ cell $c$, for some cell in the matrix. Which elements of the matrix can we exclude from the search? Consider the case if the cell $c$ is at the corner. Try to reduce the problem size by $1$. Solution\nRecursive implementation\n# Input: n x n Matrix, and target value t # Output: tuple (row, column) of the element found, or -1 if not found def searchMatrixRecursive(matrix …","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"b7656e3028e9785fa5ee4b28837b6189","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab04/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/msa-levitin-post/lab04/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nInstructor Notes Lemma. $\\lfloor \\log n \\rfloor + 1 = \\lceil \\log (n+1) \\rceil$.\nWe know $n = 2^k + r$ for some $k \\geq 0$ and $0 \\leq r \u003c 2^k$, ByEuclid’s Theorem and Archimedean Property.","tags":null,"title":"Lab 04","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 5.1.3 Hints\nyou can use floors and ceils as subroutines. Solution\n(a)\ndef divConqPower(a,n) if n = 1 return a return divConqPower(a, floor(n/2)) * divConqPower(a, ceil(n/2)) (b)\nTime of basic operations $T(n)$ are $T(n) = T( \\lfloor n/2 \\rfloor ) + T( \\lceil n/2 \\rceil) + 1$. Assuming $n = 2^k$, We get $T(n) = 2T(n/2) + 1$. By master theorem, $T(n) = \\Theta(n)$.\nFor general cases of $n$, Observe $n = 2^{\\log n} \\leq 2^{\\lceil \\log n \\rceil}$, So by master theorem $T(n) \\leq \\mathcal{O}(2^{\\lceil \\log n \\rceil}) \\leq \\mathcal{O}(2^{\\log n + 1}) = \\mathcal{O}(n)$. Similarly $T(n) \\geq \\Omega(2^{\\lfloor \\log n \\rfloor}) = \\Omega(n)$. That concludes $T(n) = \\Theta(n)$ for any $n$.\nComplexity proof by substitution. Recurrence is \\begin{aligned} T(1) \u0026amp;= 0 \\\\ T(n) \u0026amp;= 2T(n/2) + 1 \\end{aligned} It follows \\begin{aligned} T(n) \u0026amp;= 2T(n/2) + 1 \\\\ \u0026amp;= 2^2 T(n/2^2) + 2^1 + 2^0 \\\\ \u0026amp;= 2^3 T(n/2^3) + 2^2 + 2^1 + 2^0 \\\\ \u0026amp;= 2^k T(n/2^k) + 2^{k-1} + \\dots + 2^0 \\\\ \u0026amp;= 2^{\\log n} T(n/2^{\\log n}) + 2^{(\\log n) - 1} + \\dots + 2^0 \\\\ \u0026amp;= 2^{\\log n} T(1) + 2^{(\\log n) - 1} + \\dots + 2^0 \\\\ \u0026amp;= 2^{(\\log n) - 1} + \\dots + 2^0 \\\\ \u0026amp;= 2^{\\log n } - 1 = n - 1 = \\Theta(n) \\end{aligned}\nP.S. Generally speaking we can ignore floors and ceilings in asymptotic notation (see page 885 in MIT’s Math for CS).\n(c). Homework\n5.1.10 Homework\n5.2.8 Homework Consider pivot to be zero.\n5.2.9 Homework\n5.3.1 Hints\nRecall in a binary tree, a node has at most two leaves. Apply the strategy on them Given the height of subtrees, What can you conclude about height of the main tree? What is subtrees have different heights? Solution\nSame as solution manual:\nAnalysis. We know each node is going to count 1 operation. If we assumed total number of nodes to be $n$, then $T(n) = \\Theta(n)$. If we assumed like the book the total number of internal nodes to be $n$ and leaves to be $x$, then $x + n = 2n$, so $T(n) = \\Theta(n)$.\nP.S. The book considers checking whether tree is empty to be the basic operation. My intuition tells me it is the max operation.\n5.3.2 Hints\nConsider the problem size to be level of a node, not number of nodes. Consider the base case as the tree being a single node (leaf). Assume you can query the tree’s root, and its children. Recall a binary tree has at most two children for each node. Given counts of both, what can we conclude? Solution\nCommentary on the given algorithm in the question. It is flawed. Given the solution of an empty tree, we reach a flawed claim about the tree of size 1 node. Remarkably we shouldn’t consider problem size to be the number of nodes, but rather the height.\nCorrect algorithms:\n# input: tree T with access to its root # output: count of leaves def leafCounter (Tree T) # base case: the tree is empty if T is empty return 0 # base case: the tree is a leaf node if T.root.children == [] return 1 # recursive step return leafCounter(T_left) + leafCounter(T_right) Analysis. We count one summation operation for each non-leaf node. Following the notation given in the book, $n$ as number of non-leaf nodes and $x$ as leaves, We get $T(n) = n$.\nAlternatively we can consider $n$ to be total number of nodes. But we know $n = 2i+1$ where $i$ is number of non-leaf nodes. So $T(n) \\approx n/2 = \\Theta(n)$.\n5.4.3 Homework Proving exponent rules is not germane to the course.\n5.4.8 Homework Uses geometric series.\n5.5.1 Hints\nAmong pairs of right and left subsets, What are the least-distance ones? Use the given sorted property to deduce the least-distance pair. Solution\nLike the solution manual.\n5.5.9 Homework\n","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"9ac6adfa0e6f4c0e6729f58764fb97c4","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab05/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/msa-levitin-post/lab05/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 5.1.3 Hints\nyou can use floors and ceils as subroutines. Solution\n(a)\ndef divConqPower(a,n) if n = 1 return a return divConqPower(a, floor(n/2)) * divConqPower(a, ceil(n/2)) (b)\nTime of basic operations $T(n)$ are $T(n) = T( \\lfloor n/2 \\rfloor ) + T( \\lceil n/2 \\rceil) + 1$.","tags":null,"title":"Lab 05","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 6.1.1 (a).\nHints\nSort the array as a preprocessing step. Given a sorted array, and an adjacent pair $A[i],A[i+1]$, Could the distance between $A[i]$ and $A[j]$ where $j \u0026gt; i+1$, be strictly less? Use that to design your algorithm. Solution\n# input: Array of integers # output: minimum distance between any pairs def ClosestDistance(A[0..n-1]) # Transformation: Sort the array A.sort() # Initialize minimum distance to | A[0] - A[1] | minDistance = abs( A[0] - A[1] ) # Iterate and compute the distance between adjacent elements for i in 1..n-1: currentDistance = | arr[i] - arr[i + 1] ) # Update the minimum distance if the current distance is smaller if currentDistance \u0026lt; minDistance: minDistance = currentDistance # Return the minimum distance return minDistance (b). Homework.\n6.1.2 Homework.\n6.2.4 We ask students whether $\\Theta(n^3) - \\Theta(n^3) + \\Theta(n^3) = \\Theta(n^3)$.\nHints\nTry to given a counter example where coefficients cancel each other. Solution\nWe show it is not true in general true by the counter example $T_1(n) = n^3$, $T_2(n) = 2 n^3$, and $T_3(n) = n^3$.\nAnalysis of the algorithm is left as a homework.\n6.2.5 Homework.\n6.3.5 (a)\nHints\nThe idea is similar to binary search tree Solution\n# input: non-empty graph, by its root # output: smallest element def find_smallestKey(root): node = root while node.left is not None current = current.left return current.key # input: non-empty graph, by its root # output: largest element def find_largestKey(root): node = root while node.right is not None: node = node.right return current.key # input: non-empty graph, by its root # output: difference between largest and smallest elements def range(root) return find_largestKey(root) - find_smallestKey(root) Complexity is $2 \\log n = \\Theta( \\log n )$\n(b)\nHints\nFor the largest, Note we can step down on left children. Similarly for the smallest, we can step down on right children. Solution\nFalse. Counter example from the solution manual.\n6.3.9 Hints\nVery similar to binary search tree Solution\nLike the previous previous exercise we traverse left-most and right-most nodes. The difference is we consider left key and right key of these nodes, respectively.\ndef range(root) leftMost = find_leftMostNode(root) rightMost = find_rightMostNode(root) return rightMost.rightKey - leftMost.leftKey 6.4.2 Homework.\n6.4.5 Students will be given the following subroutines.\n# input: heap as an array, node by its index # output: None. Given heap is modified in-place def siftUp(heap, index): # cannot sift-up root node while index \u0026gt; 0: # parent of the node parentIndex = (index - 1) // 2 # parental dominance is satisfied if heap[index] \u0026lt;= heap[parentIndex] break # if not satisfied, swap with parent swap(heap[index], heap[parentIndex]) # set the cursor to the parent, and repeat index = parentIndex # input: heap as an array, node by its index # output: None. Given heap is modified in-place def siftDown(heap, index): # Children indices leftChild_index = (2 * index) + 1 rightChild_index = (2 * index) + 2 # Find the largest out of index, leftChild_index, and rightChild_index # Initially set largest = index # Check if the left child exists. if larger, update largest if leftChild_index \u0026lt; len(heap) and heap[leftChild_index] \u0026gt; heap[largest] largest = leftChild_index # Check if the right child exists. if larger, update largest if rightChild_index \u0026lt; len(heap) and heap[rightChild_index] \u0026gt; heap[largest]: largest = rightChild_index # If the largest element is one of the children. if largest != index: # swap the child with parent swap( heap[index], heap[largest] ) # recursively heapify the smaller tree siftDown(heap, largest) # parental dominance is satisfied here, whether recursion is called or not, so we are done return (a). Homework.\nHints\nThe approach is very similar to Maximum Key Deletion in Levitin. Hint. Same logic of b but notably restrict search of the min element on leaves, $H[ \\lfloor n/2 \\rfloor + 1 ], \\dots H[n]$. Also since the minimum is in leaves, we will only call \\verb#siftUp#.\ndef delMin(heap H) # find the minimum node\u0026#39;s index in leaves minElIndex = min(H[n/2 .. n]) # swap the minimum with last node swapWithLast(minElIndex) # remove the last node removeLast() # sift-up the node in the index, previously containing the minimum siftUp(minElIndex ) (b).\nHints\nUse the element removal subroutine, given in the book. Call it removeLast. Use the swap with last indexed node trick, given in the book. Call it swapWithLast. Solution\ndef findElementIndex(heap, target) for each element i of heap if i == target return i.index def removeIndexNode(heap, index) # swap the indexed node with the last node swapWithLast(heap, index) # remove the last node removeLast(heap) # One of them must terminate in constant time siftDown(heap, index) # swapping downwards siftUp(heap, index) # swapping upwards def removeElementNode(heap, target) # get the index of target by a linear scan index = …","date":1700092800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1700092800,"objectID":"d1710f8cb523fbb4687346a5fa832bf9","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab06/","publishdate":"2023-11-16T00:00:00Z","relpermalink":"/msa-levitin-post/lab06/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 6.1.1 (a).\nHints\nSort the array as a preprocessing step. Given a sorted array, and an adjacent pair $A[i],A[i+1]$, Could the distance between $A[i]$ and $A[j]$ where $j \u003e i+1$, be strictly less?","tags":null,"title":"Lab 06","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 2(d) Observe the prime factorization $21 = 3 \\cdot 7$ and $50 = 2 \\cdot 5 \\cdot 5$. As they share no prime numbers, $gcd(21,50) = 1$.\n4 We have $1 = 7(-3) + 11(2) = -21 + 22$, and $1 = 7(8) + 11(-5) = 56 - 56 - 56 - 56 - 56 - 56 - 55$. Generally $1 = 7(-3 + 11k) + 11(2 - 7k)$.\n7 $(\\rightarrow)$ We are given $a = nk_0 + r$ and $b = nk_1 + r$. Thus $a - b = nk_0 - nk_1 = n(k_0 - k_1)$.\n$(\\leftarrow)$ We have $a = nk_1 + r_1$, and $b = nk_2 + r_2$. Construct $a - b = n(k_1 - k_2) + (r_1 - r_2)$ and observe we get $0 \\leq r_1 - r_2 \\leq n-1$. If $r_1 - r_2 \\neq 0$, Then $n$ won’t divide $a-b$ contradicting the given hypothesis.\n10 We have $1 = 7(-3) + 11(2) = -21 + 22$, and $1 = 7(8) + 11(-5) = 56 - 56 - 56 - 56 - 56 - 56 - 55$. Generally $1 = 7(-3 + 11k) + 11(2 - 7k)$.\n11 Observe the form $ax \\mod n = 1$ is equivalent to $(a)x + (-n)k = 1$.\n$(\\leftarrow)$ Given $gcd(a,n) = 1$, It is easy to show $gcd(a, (-1)n) = 1$ as any negative divisor won’t ever be the $gcd$. By theorem 0.2 there exists $x_0$ and $k_0$ such that $(a)x_0 + (-n)k_0 = gcd(a,n) = 1$.\n$(\\rightarrow)$ We have $x_0$ and $k_0$ which satisfy $(a)(x_0) + (n)(-k_0) = 1$. But $1$ is the smallest positive integer satisfying it. It follows $1 = gcd(a,n) = d$.\n13 By definition $gcd(m,n) = 1$ and hence we get $m(s_0) + n(t_0) = 1$. Multiplying both sides by $r$, We get $m(s_0 \\cdot r) + n(t_0 \\cdot r) = r$.\n20 Assume for contradiction that $p_1 p_2 \\dots p_n + 1$ is divisable by $p_i$. Then\n\\begin{aligned} \\frac{\\displaystyle{p_1 p_2 \\dots p_n + 1}}{\\displaystyle{p_i}} \u0026amp;= \\frac{\\displaystyle{p_i k_0}}{\\displaystyle{p_i}} \\\\ \\frac{\\displaystyle{p_1 \\dots p_n}}{\\displaystyle{p_i}} + \\frac{\\displaystyle{1}}{\\displaystyle{p_i}} \u0026amp;= k_0 \\\\ \\frac{\\displaystyle{p_1 \\dots p_n}}{\\displaystyle{p_i}} - k_0 \u0026amp;= \\frac{\\displaystyle{1}}{\\displaystyle{p_i}} \\end{aligned}\n$L.H.S$ is clearly an integer implying $\\frac{\\displaystyle{1}}{\\displaystyle{p_i}}$ is an integer also. Contradiction.\n28 $2^n \\cdot 3^{2n} = 18^n$. Since $18 \\mod 17 = 1$, We get $18^2 \\mod 17 = 1 \\cdot 1 \\mod 17 = 1$. Generally $18^n \\mod 17 = 1$, and finally $18^n - 1 \\mod 17 = 1 - 1 \\mod 17 = 0$.\n33 We prove a relaxed version of the problem and hence assume $a$ is positive.\nWe show the contrapositive. Consider $S$ which does not contain every integer $z \\geq a$. Then there’s some integer $z_0 \\geq a$ where $z_0 \\notin S$. In other words the set $R ={ z ; | ; z \\geq a \\wedge z \\notin S }$ is not empty. By the well-ordering principle $R$ has a smallest member, Call it $z_s$. Note $z_s \\neq a$ So we can safely take $z_s - 1 \\in S$. Therefore it is NOT the case that if integer $z \\in S$ then $z+1 \\in S$ by the counter-example we constructed.\nFor a general version of any integer $a$, We would partition set $R$ to a finite subset of non-positives and another subset of positives. Then we consider the smallest of positives by well-ordering, and smallest of non-positives, and take the minimum of both. Recall any finite set has a smallest member.\n35 Note $(n+3)^3 = n^3 + 9(n^2 + 3n + 3)$ by trivial algebraic operations.\nBase. $n = 1$. $n^3 + (n+1)^3 + (n+2)^3 = 1 + 8 + 27 = 36 = 9(4)$.\nHypo. $n^3 + (n+1)^3 + (n+2)^3 = 9k_0$\nStep. $(n+1)^3 + (n+2)^3 + (n+3)^3 = n^3 + (n+1)^3 + (n+2)^3 + 9(n^2 + 3n + 3) = 9k_0 + 9(n^2 + 3n + 3) = 9(k_0 + n^2 + 3n +3)$\n57 2. Let $a_0, a_1 \\in A$ where $(\\beta \\alpha)(a_0) = (\\beta \\alpha)(a_1)$. In other notation, $\\beta(\\alpha(a_0)) = \\beta(\\alpha(a_1))$. Since $\\beta$ is one-to-one we get $\\alpha(a_0) = \\alpha(a_1)$. Since $\\alpha$ is one-to-one we get $a_0 = a_1$.\n3. Let $c \\in C$. Since $\\beta$ is onto we get $\\beta(b_0) = c$. Since $\\alpha$ is onto we get $\\alpha(a_0) = b_0$. Thus $\\beta \\alpha (a_0) = c$.\n4. For the sake of brevity we highlight that fact the inverse $a^{-1}$ is a well-defined function, i.e maps each element of the domain to exactly one element of the range, as $a$ is both one-to-one and onto.\n58 Reflexive. $a - a = 0$.\nSymmetry. Given $a - b = z$ is an integer, Trivially $b - a = -z$ is an integer also.\nTransitivity. Given $a - b = z_0$ and $b - c = z_1$, Trivially $(a - b) + (b - c) = a - c = z_0 + z_0$ is an integer also.\nA Class has numbers of the same decimal fraction.\n59 No.\n63 $3^{100} \\mod 10$ and $2^100 \\mod 10$ respectively.\n","date":1698969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698969600,"objectID":"01a386deb6f54192804fdc2fdba6800e","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset00/","publishdate":"2023-11-03T00:00:00Z","relpermalink":"/siniora-algebra-post/pset00/","section":"siniora-algebra-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 2(d) Observe the prime factorization $21 = 3 \\cdot 7$ and $50 = 2 \\cdot 5 \\cdot 5$. As they share no prime numbers, $gcd(21,50) = 1$.\n4 We have $1 = 7(-3) + 11(2) = -21 + 22$, and $1 = 7(8) + 11(-5) = 56 - 56 - 56 - 56 - 56 - 56 - 55$.","tags":null,"title":"Chapter 00","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 2 R_0 R_120 R_240 D D\u0026#39; D\u0026#39;\u0026#39; R_0 R_0 R_120 R_240 D D\u0026#39; D\u0026#39;\u0026#39; R_120 R_120 R_240 R_0 D\u0026#39;\u0026#39; D D\u0026#39; R_240 R_240 R_0 R_120 D\u0026#39; D\u0026#39;\u0026#39; D D D D\u0026#39; D\u0026#39;\u0026#39; R_0 R_120 R_240 D\u0026#39; D\u0026#39; D\u0026#39;\u0026#39; D R_240 R_0 R_120 D\u0026#39;\u0026#39; D\u0026#39;\u0026#39; R_0 D\u0026#39; R_120 R_240 R_0 Two pictures. Not abelian.\n3 a. $V$.\nb. $R_{270}$.\nc. $R_0$.\nd. $R_0$, $R_{180}$, $H$, $V$, $D$, $D’$.\ne. None.\n5 We follow our intuition and generalize the cases of $D_4$ and $D_3$ with no formal argumentation.\nFor both cases, Elements include rotations $\\nfrac{i}{n} 360$ for $i = 1, 2, \\dots, n-1$. Counts $n$.\nEven case only. Flips about the $ith$ diagonal (counts $n/2$), and Flips about the $ith$ axis (counts $n/2$)\nOdd case only. Flips about the $ith$ diagonal (counts $n$).\n$D_n$ is going to have a total of $2n$ elements; This fact was mentioned in the textbook though.\n11 Notation. We donate Rotation by T and Reflection by F.\nLemma. Through Caylay table in page 33, $TT = T$, $FF = T$, $TF = F$, and $FT = F$. In other words $X^2 = T$, and $XY = F$ if $X \\neq Y$.\nTheorem. Observe we can re-structure the given composed function as $a^2b^2b^2 ac c^2 c^2 a^2 ac = TTTacTTTac = (TTTac)^2 = T$.\nTherefore, Regardless of the choices of $a, b, c$, The given function is always a rotation.\n13 $D = H R_{90} = R_{90} V$.\n21 $X \\neq H, V, D, D’, R_0, R_{180}$, As otherwise $X^2 = R_0$ and then $Y = R_{90}$. For either of the remaining two cases $X = R_{90}$ or $X = R_{270}$, Necessarily $Y = R_{270}$.\n","date":1698969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698969600,"objectID":"f134a2e1cfcb8e1e294127893915b73c","permalink":"https://mostafatouny.github.io/siniora-algebra-post/pset01/","publishdate":"2023-11-03T00:00:00Z","relpermalink":"/siniora-algebra-post/pset01/","section":"siniora-algebra-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nProblems 2 R_0 R_120 R_240 D D' D'' R_0 R_0 R_120 R_240 D D' D'' R_120 R_120 R_240 R_0 D'' D D' R_240 R_240 R_0 R_120 D' D'' D D D D' D'' R_0 R_120 R_240 D' D' D'' D R_240 R_0 R_120 D'' D'' R_0 D' R_120 R_240 R_0 Two pictures.","tags":null,"title":"Chapter 01","type":"siniora-algebra-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 1.1.4 Hints\nYou are given a square number $n$. Given some integer $k$, How can we verify it is the root? Follow the exhaustive search strategy, to find the root of $n$. You are given a real number $r$. Given some integer $k$, How can we verify it is the floor of $r$? Follow the exhaustive search strategy, to find the floor of $n$. Combine all previous hints to find a unique definition of $\\lfloor \\sqrt{n} \\rfloor$. Follow the exhaustive search strategy, to solve the main problem. Solution\nfor i in n-1 .. 0 if (i)^2 \u0026lt;= n return i 1.1.8 Hints\nTry this case on concrete examples like $m = 2$ and $n = 3$. Why $m \\mod n = m$ when $m \u0026lt; n$? Recall the definition of mod. What are the possible ranges of $x \\mod n$ for any integer $x$? Solution\nIt shall swap them as $r = m \\mod n = m$ when $m \u0026lt; n$.\nOnly once. Given $m \u0026gt; n$, Necessarily $n \u0026gt; m \\mod n$.\n1.2.5 Hints\nConvert a concrete decimal number to binary. Observe how the right most digit from the binary representation is obtained. Given a binary representation, What is the number we divide on it, so that the quotient eliminate the right most digit? Follow the Decrease and Conquer strategy, with the above two hints, to solve the problem. Solution\nDecToBin(n): # input: integer n # output: binary representation as a list # binary representation l = [ ] while n != 0: # kth digit from right to left b.appendLeft( n % 2 ) # remove the rightmost digit # division output is an integer n = n/2 1.2.9 Hint\nAre there duplicated computations? Are there pairs tested twice? Observe $| a - b | = | b - a |$. If we checked all elements with $A[i]$, Do we need to test $A[j]$ with $A[i]$? Solution\nMinDistance( A ): # input: array of size n # output: minimum distance between two distinct elements dmin = infinity for i in 0 .. n-1: for j in i+1 .. n-1: dis = | A[i] - A[j] | if dis \u0026lt; dmin: dmin = dis 1.3.1 Hints\nif $A[i] == A[j]$ which index shall be counted? What can we conclude about $S$? Solution\na. Tedious to typeset.\nb. No. Observe counting only happens when strictly $i \u0026lt; j$. If $A[i] == A[j]$ then the code counts $A[i]$ not $A[j]$. Therefore $A[i]$\nshall succeed $A[j]$. In fact equal cells are reversed in the sorted array.\nc. No. It does not modify array $A$ but output is a different array $S$.\n1.4.2 Hint\nFor ascendingly ordered array $A$, Is it possible for the target value $t$ to exist in $A[i..n-1]$ given the fact $t \u0026gt; A[i]$? Use the above hint to prune the search space. Which index of the array you think shall prune the greatest search space. Solution\nFor target value $t$:\na. Access some element $x$ in the array. If $t \\neq x$, We can ignore searching in the right/left side of $x$.\nb. While linear scanning, Terminate the algorithm earlier once some $A[i] \u0026gt; t$.\n1.4.10 Hints\nIs it possible for two strings to be anagrams in case they different lengths? Is it possible for two strings to be anagrams if one of them has a character not present in the other? You can convert a character to its corresponding ascii number. Use that for a cheaper data strucutre. the ascii number corresponds to an index. Solution\nTwo strings are anagrams if and only if they have the same count of characters.\nAreStringsAnagrams(A, B): # input two strings # output True if anagrams and False otherwise # if lengths are not the same, then not anagrams if length(A) != length(B): return False # initialize characters counts to zeros for both strings A_chCount = B_chCount = [ 0 ] * 26 # Count characters in both strings for ch in A: A_chCount[ int(ch) ] = A_chCount[ int(ch) ] + 1 for ch in B: B_chCount[ int(ch) ] = B_chCount[ int(ch) ] + 1 # Anagrams if and only if characters count is exactly the same return A_chCount == B_chCount ","date":1698969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698969600,"objectID":"2a82604340d371244197aae5491da67f","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab01/","publishdate":"2023-11-03T00:00:00Z","relpermalink":"/msa-levitin-post/lab01/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 1.1.4 Hints\nYou are given a square number $n$. Given some integer $k$, How can we verify it is the root? Follow the exhaustive search strategy, to find the root of $n$.","tags":null,"title":"Lab 01","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 2.1.1 (a)\ndef sumOfArrayNumbers(A[0 .. n-1]) sum = 0 for i in 0..n-1 sum = sum + A[i] return sum n; Summation; no.\n(b)\ndef factorial(n) res = 1 for i in n..1 res = res * i return res 1; Multiplication; yes.\n(c)\nAlgorithm is in page 61.\ndef maxElementInArray(A[0..n-1]) max = A[0] for i in 1..n-1 if A[i] \u0026gt; max max = A[i] return max n; Comparison; no.\n(d)\ndef gcd(m,n) while n != 0 r = m mod n m = n n = r return m 2; mod operation; yes.\n(e) Homework.\n(f) Homework.\n2.1.3 Yes.\nClassical Search\nWorst-case is $\\mathcal{O}(n)$. Average-case is $1 \\cdot \\frac{\\displaystyle{1}}{\\displaystyle{n}} + \\dots + n \\cdot \\frac{\\displaystyle{1}}{\\displaystyle{n}} = \\frac{\\displaystyle{1}}{\\displaystyle{n}} (1 + \\dots + n) = \\frac{\\displaystyle{1}}{\\displaystyle{n}} \\frac{\\displaystyle{n(n+1)}}{\\displaystyle{2}} = \\frac{\\displaystyle{n+1}}{\\displaystyle{2}} = \\mathcal{O}(n)$. Best-case is $\\mathcal{O}(1)$. Varied Search\nWorst-case, Average-case, and Best-case, are all $\\Omega(n)$. For any determinstic algorithm not reading all the $n$ cells, We can construct a counter-example input.\nP.S. Big-Oh is used to upper-bound complexity, showing an algorithm is efficient. So it can’t be used here while we are showing the inefficiency.\n2.2.5 $5 \\lg(n+100)^{10}, \\ln^2 n, n^{1/3}, 0.001n^4 + 3n^2 + 1, 3^n, 2^{2n}, (n-2)!$\n2.2.12 Homework\n2.3.4 (a) $s(n){i=1}^n = \\sum{i=1}^n i*i$, The sum of squares up to $n$.\n(b) Multiplication.\n(c) $\\sum_{i=1}^n 1 = n(1) = n$.\n(d) $\\mathcal{O}(n)$.\n(e) Homework.\n2.3.6 (a) Homework.\n(b) Comparison.\n(c) $\\sum_{i=0}^{n-2} \\sum_{j=i+1}^{n-1} 1 = \\sum_{i=0}^{n-2} (n-1) - (i+1) + 1 = \\sum_{i=0}^{n-2} n-i-1 = (n+1) + n + \\dots + (n - (n-2) - 1) = \\frac{\\displaystyle{n(n+1)}}{\\displaystyle{2}}$\n(d) $\\mathcal{O}(n^2)$\n(e) Homework.\n2.4.3 (a)\n\\begin{aligned} S(n) \u0026amp;= S(n-1) + 2 \\ \u0026amp;= S(n-2) + 4 \\ \u0026amp;\\dots \\ \u0026amp;= S(n-(n-1)) + 2(n-1) \\ \u0026amp;= 0 + 2n - 2 \\end{aligned}\nHence $\\mathcal{O}(n)$.\n(b) Homework.\n2.4.9 (a) Homework.\n(b)\n\\begin{aligned} S(n) \u0026amp;= S(n-1) + 1 \\ \u0026amp;= S(n-2) + 2 \\ \u0026amp;\\dots \\ \u0026amp;= S(n-(n-1)) + n-1 \\ \u0026amp;= 1 + n - 1 \\end{aligned}\nHence $\\mathcal{O}(n)$\n2.5.10 Homework\n2.5.12 Homework\n2.6.1 No count of the comparison basic operation $A[j] \u0026gt; v$ in case it is $False$.\nFix by adding if j \u0026gt;= 0 then count = count+1 after the end of while.\n2.6.10 Homework\n","date":1698969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698969600,"objectID":"00f7b361860b97168ed96849a0013dfb","permalink":"https://mostafatouny.github.io/msa-levitin-post/lab02/","publishdate":"2023-11-03T00:00:00Z","relpermalink":"/msa-levitin-post/lab02/","section":"msa-levitin-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises 2.1.1 (a)\ndef sumOfArrayNumbers(A[0 .. n-1]) sum = 0 for i in 0..n-1 sum = sum + A[i] return sum n; Summation; no.\n(b)\ndef factorial(n) res = 1 for i in n.","tags":null,"title":"Lab 02","type":"msa-levitin-post"},{"authors":null,"categories":null,"content":"Materials Book: Calculus: Early Transcendentals by Rogawski \u0026amp; Adams, 3rd ed. Exercises Section Source Solution Ch. 12, Sec. 01 Page 635 PDF, HTML Ch. 12, Sec. 02 Page 644 PDF, HTML Ch. 12, Sec. 03 Page 652 PDF, HTML ","date":1696550400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1696550400,"objectID":"abdbf124203caa798cb084aac510e34a","permalink":"https://mostafatouny.github.io/post/rog-adam-ex/","publishdate":"2023-10-06T00:00:00Z","relpermalink":"/post/rog-adam-ex/","section":"post","summary":"Self-studying Calculus by Rogawski \u0026 Adams.","tags":null,"title":"Calculus","type":"post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 3.90 \\begin{align*} c^2 \u0026amp;= (a \\sin \\theta)^2 + (b - a \\cos \\theta)^2 \\\\ \u0026amp;= a^2 \\sin^2 \\theta + b^2 + a^2 \\cos^2 \\theta - 2 ab \\cos \\theta \\\\ \u0026amp;= a^2 (\\sin^2 \\theta + \\cos^2 \\theta ) + b^2 - 2ab \\cos \\theta \\\\ \u0026amp;= a^2 + b^2 - 2ab \\cos \\theta \\end{align*}\nEx. 3.91 (a). The goal is $||xv + w||^2 = ||v||^2 x^2 (2v \\cdot w)x + ||w||^2$. Then \\begin{align*} L.H.S \u0026amp;= (xv + w) \\cdot (xv + w) \\\\ \u0026amp;= xv \\cdot xv + 2xv \\cdot w + w \\cdot w \\\\ \u0026amp;= x^2 (v \\cdot v) + (2v \\cdot w)x + ||w||^2 \\\\ \u0026amp;= ||v||^2 x^2 + (2v \\cdot w)x + ||w||^2 \\\\ \u0026amp;= R.H.S \\end{align*}\n(b). We know $f(x) = ax^2 + bx + c \\geq 0$. Geometrically a parabola which does not intersect the x-axis at two points. So there are no two distinct real solutions, and hence the discriminent $b^2 - 4ac \\leq 0$.\nEx. 3.92 Observe $(v+w) \\cdot (v+w) = (v+w) \\cdot v + (v+w) \\cdot w$, So hint is proven. \\begin{align*} L.H.S = ||v+w||^2 \u0026amp;\\leq ||v+w|| ; ||v|| + ||v+w|| ; ||w|| \\\\ \u0026amp;= ||v+w|| (||v|| + ||w||) \\end{align*} Thus, $||v+w|| \\leq ||v|| + ||w||$.\nEx. 3.93 Recall the cosine additition formula is $\\cos(a-b) = \\cos a \\cos b + \\sin a \\sin b$. \\begin{align*} v \u0026amp;\\cdot w \\\\ \u0026amp;= ||v|| (\\cos \\theta_1, \\sin \\theta_1) \\cdot ||w|| (\\cos \\theta_2, \\sin \\theta_2) \\\\ \u0026amp;= ||v|| \\cdot ||w|| \\left[ (\\cos \\theta_1, \\sin \\theta_1) \\cdot (\\cos \\theta_2, \\sin \\theta_2) \\right] \\\\ \u0026amp;= ||v|| \\cdot ||w|| \\left[ \\cos \\theta_2 \\cos \\theta_1 + \\sin \\theta_2 \\sin \\theta_1 \\right] \\\\ \u0026amp;= ||v|| \\cdot ||w|| \\cos(\\theta_2 - \\theta_1) \\\\ \u0026amp;= ||v|| \\cdot ||w|| \\cos(\\theta) \\text{ given } \\theta = \\theta_2 - \\theta_1 \\end{align*}\nEx. 3.94 It suffices to show $\\cos \\theta = \\nfrac{V \\cdot V_\\theta}{||V|| \\cdot ||V_\\theta||}$. But $||V|| = ||V_\\theta||$, Then \\begin{align*} R.H.S \u0026amp;= \\nfrac{(x^2 \\cos \\theta + xy \\sin \\theta)+(-xy \\sin \\theta + y^2 \\cos \\theta)}{||V||^2} \\\\ \u0026amp;= \\nfrac{\\cos \\theta (x^2 + y^2)}{||V||^2} \\\\ \u0026amp;= \\nfrac{\\cos \\theta ||V||^2}{||V||^2} \\\\ \u0026amp;= L.H.S \\end{align*}\nEx. 3.95 Let $V_x$, $V_y$, $V_z$ be projected vectors of $V$ on $x$, $y$, and $z$ axis. Then: \\begin{align*} \\cos \\alpha \u0026amp;= ||V_x|| / ||V|| \\\\ \\cos \\beta \u0026amp;= ||V_y|| / ||V|| \\\\ \\cos \\gamma \u0026amp;= ||V_z|| / ||V|| \\end{align*} It follows \\begin{align*} \\cos^2 \\alpha \u0026amp;+ \\cos^2 \\beta + \\cos^2 \\gamma \\\\ \u0026amp;= (||V_x|| / ||V||)^2 + (||V_y|| / ||V||)^2 + (||V_z|| / ||V||)^2 \\\\ \u0026amp;= \\nfrac{ ||V_x||^2 + ||V_y||^2 + ||V_z||^2 }{ ||V||^2 } \\\\ \u0026amp; = \\nfrac{ ||V_{x,y}||^2 + ||V_z||^2 }{ ||V||^2 } \\textit{ (Pythagorean Theorem)} \\\\ \u0026amp; = \\nfrac{ ||V||^2 }{ ||V||^2 } \\textit{ (Pythagorean Theorem)} \\\\ \u0026amp; = 1 \\end{align*}\n","date":1696550400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1696550400,"objectID":"ba8ada1abcf693b15ff428e881b90b1f","permalink":"https://mostafatouny.github.io/rog-adam-post/ch12-sec03/","publishdate":"2023-10-06T00:00:00Z","relpermalink":"/rog-adam-post/ch12-sec03/","section":"rog-adam-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 3.90 \\begin{align*} c^2 \u0026= (a \\sin \\theta)^2 + (b - a \\cos \\theta)^2 \\\\ \u0026= a^2 \\sin^2 \\theta + b^2 + a^2 \\cos^2 \\theta - 2 ab \\cos \\theta \\\\ \u0026= a^2 (\\sin^2 \\theta + \\cos^2 \\theta ) + b^2 - 2ab \\cos \\theta \\\\ \u0026= a^2 + b^2 - 2ab \\cos \\theta \\end{align*}","tags":null,"title":"Ch.12, Sec.3","type":"rog-adam-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 2.60 \\begin{align*} L \u0026amp;= P_0 + tv \\\\ \u0026amp;= (x_0,y_0,z_0) + t (a,b,c) \\end{align*} \\begin{align*} x = x_0 + ta \\rightarrow t = \\nfrac{x-x_0}{a} \\\\ y = y_0 + tb \\rightarrow t = \\nfrac{y-y_0}{b} \\\\ z = z_0 + tc \\rightarrow t = \\nfrac{z-z_0}{c} \\end{align*}\nEx. 2.66 Be definition of a slope, We have two points on the line: $(x_0, y_0)$ and $(x_0 + 1, y_0 + m)$.\nBy page 640, We take the directional vector: $v = (x_0 + 1, y_0 + m) - (x_0, y_0) = (1,m)$.\nThus, \\begin{align*} x = x_0 + (1)t \\rightarrow t = x - x_0 \\\\ y = y_0 + (m)t \\rightarrow t = \\nfrac{y - y_0}{m} \\end{align*} Hence, The symmetric form is satisfied.\nEx. 2.67 \\begin{align*} \\vec{OA} \u0026amp;= v \\\\ \\vec{OA’} \u0026amp;= \\nfrac{1}{2} (w-u) + u \\\\ \u0026amp;= \\nfrac{1}{2} (w+u) \\\\ \\vec{OA’} - \\vec{OA} \u0026amp;= \\nfrac{1}{2} w + \\nfrac{1}{2} u - v \\end{align*} Taking $2/3$ of it: $\\nfrac{2}{3} (\\vec{OA’} - \\vec{OA}) = \\nfrac{1}{3} w + \\nfrac{1}{3} u - \\nfrac{2}{3} v$.\n$P$ is the terminal of vector: $v + \\nfrac{1}{3} w + \\nfrac{1}{3} u - \\nfrac{2}{3} v = \\nfrac{1}{3} w + \\nfrac{1}{3} u + \\nfrac{1}{3} v$.\nSymmetrically, Taking $\\nfrac{2}{3}$ of segments $BB’$ and $CC’$ yields the vector $\\nfrac{1}{3} w + \\nfrac{1}{3} u + \\nfrac{1}{3} v$, and thus point $P$ lies on the other two medians as well.\n","date":1695600000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1695600000,"objectID":"9ae02c48b1b2c1385b0918cefe93b4e0","permalink":"https://mostafatouny.github.io/rog-adam-post/ch12-sec02/","publishdate":"2023-09-25T00:00:00Z","relpermalink":"/rog-adam-post/ch12-sec02/","section":"rog-adam-post","summary":"$\\newcommand{\\nfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 2.60 \\begin{align*} L \u0026= P_0 + tv \\\\ \u0026= (x_0,y_0,z_0) + t (a,b,c) \\end{align*} \\begin{align*} x = x_0 + ta \\rightarrow t = \\nfrac{x-x_0}{a} \\\\ y = y_0 + tb \\rightarrow t = \\nfrac{y-y_0}{b} \\\\ z = z_0 + tc \\rightarrow t = \\nfrac{z-z_0}{c} \\end{align*}","tags":null,"title":"Ch.12, Sec.2","type":"rog-adam-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1.66 $$ \\begin{aligned} ||L_3|| \u0026amp;= ||L_2|| \\sin \\theta_2 \\\\ ||L_4|| \u0026amp;= ||L_6|| \\sin \\theta_1 \\\\ ||L_5|| \u0026amp;= ||L_3|| + ||L_4|| \\\\ ||L_7|| \u0026amp;= \\sqrt{(L_2)^2 - (L_3)^2} \\\\ ||L_7|| \u0026amp;= ||L_6|| \\cos \\theta_1 \\rightarrow ||L_6|| = ||L_7|| / \\cos \\theta_1 \\\\ ||L_8|| \u0026amp;= ||L_1|| - ||L_6|| \\\\ ||L_9|| \u0026amp;= ||L_8|| \\cos \\theta_1 \\end{aligned} $$ Components are $\\langle ||L_5||, ||L_9|| \\rangle$.\nEx. 1.69 Observe $\\overline{AC} = ||v+w||$ and $\\overline{BD} = ||v-w||$.\nBy vector algebra, $$ \\begin{aligned} w + \\frac{1}{2} (v-w) \u0026amp;= \\frac{1}{2} (v+w) \\\\ \\text{point of BD midpoint} \u0026amp;= \\text{point of AC midpoint} \\end{aligned} $$ Hence bisects each other.\nEx. 1.70 Observe that we can construct the midpoint between the ends of two vectors by $\\frac{1}{2} (v-u)$.\nThe midpoint of $H$ is $\\frac{1}{2} [(v + \\frac{1}{2} w) - \\frac{1}{2} u] + \\frac{1}{2} u = \\frac{1}{2} v + \\frac{1}{4} w + \\frac{1}{4} u$.\nThe midpoint of $V$ is $\\frac{1}{2} [(u + \\frac{1}{2} z) - \\frac{1}{2} v] + \\frac{1}{2} v = \\frac{1}{2} u + \\frac{1}{4} z + \\frac{1}{4} v$\nSuffices to show $2u + v + z = 2v + w + u$ which reduces to $u+z = v+w$. By our diagram both yields exactly the same vector.\nNote. I solved the problem without seeing the hint.\nEx. 1.71 vectors $v$ and $w$ are perpendicular if and only if $$ \\begin{aligned} ||w-v||^2 \u0026amp;= ||v||^2 + ||w||^2 \\\\ ||\\langle c-a, d-b \\rangle||^2 \u0026amp;= a^2 +b^2 + c^2 + d^2 \\\\ (c-a)^2 + (d-b)^2 \u0026amp;= \\\\ c^2 + a^2 - 2ac + d^2 + b^2 - 2bd \u0026amp;= \\\\ -2ac - 2bd \u0026amp;= 0 \\\\ ac - bd \u0026amp;= \\end{aligned} $$\n","date":1693180800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1693180800,"objectID":"8c1fa74e996c22e38cc13ba633aaedb4","permalink":"https://mostafatouny.github.io/rog-adam-post/ch12-sec01/","publishdate":"2023-08-28T00:00:00Z","relpermalink":"/rog-adam-post/ch12-sec01/","section":"rog-adam-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1.66 $$ \\begin{aligned} ||L_3|| \u0026= ||L_2|| \\sin \\theta_2 \\\\ ||L_4|| \u0026= ||L_6|| \\sin \\theta_1 \\\\ ||L_5|| \u0026= ||L_3|| + ||L_4|| \\\\ ||L_7|| \u0026= \\sqrt{(L_2)^2 - (L_3)^2} \\\\ ||L_7|| \u0026= ||L_6|| \\cos \\theta_1 \\rightarrow ||L_6|| = ||L_7|| / \\cos \\theta_1 \\\\ ||L_8|| \u0026= ||L_1|| - ||L_6|| \\\\ ||L_9|| \u0026= ||L_8|| \\cos \\theta_1 \\end{aligned} $$ Components are $\\langle ||L_5||, ||L_9|| \\rangle$.","tags":null,"title":"Ch.12, Sec.1","type":"rog-adam-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 11 $(\\rightarrow)$ Observe $v = v_U + v_{U^\\bot}$ and $w = w_U + w_{U^\\bot}$. Clearly, \\begin{aligned} \\langle Pv, w \\rangle \u0026amp;= \\langle v_U, w \\rangle \\\\ \u0026amp;= \\langle v_U, w_{U^\\bot} \\rangle + \\langle v_U, w_U \\rangle \\\\ \u0026amp;= 0 + \\langle v_U, w_U \\rangle \\\\ \\langle v, Pw \\rangle \u0026amp;= \\langle v_{U^\\bot}, w_U \\rangle + \\langle v_U, w_U \\rangle \\\\ \u0026amp;= 0 + \\langle v_U, w_U \\rangle \\end{aligned}\n$(\\leftarrow)$ For $U = range \\ T$ and $v = v_U + v_{U^\\bot}$, we show $Tv = v_U$.\nLemma. $Tv_U = v_U$.\nSince $v_U \\in range \\ T$, by definition we know $Tv_0 = v_U$. So $T(Tv_0) = Tv_0$ as $T^2 = T$, which concludes $Tv_U = v_U$.\nLemma. $Tv_{U^\\bot} = 0$.\nBy definition we know $v_{U^\\bot} \\in (range \\ T)^\\bot$. But given $T$ is self-adjoint, $(range \\ T)^\\bot = null \\ T$. So $v_{U^\\bot} \\in null \\ T$.\nIn conclusion, $Tv = Tv_U + Tv_{U^\\bot} = v_U + 0 = v_U$.\nEx. 17 Fact. For $normal \\ T$, $range \\ T$ = $range \\ T^*$ and $null \\ T = null \\ T^*$. For any $T$, $range \\ T = (null \\ T^*)^\\bot$. See ex.16.\nLemma. For $normal \\ T$, $range \\ T \\cap null \\ T = {0}$.\nObserve $L.H.S = (null \\ T^*)^\\bot \\cap (null \\ T^*)$ by the aforementioned facts.\nTheorem. $null \\ T^k = null \\ T$.\nClearly $null \\ T \\subset null \\ T^k$ as $T0 = 0$ for any operator $T$. It remains to show $null \\ T^k \\subset null \\ T$.\n$v \\rightarrow^T v_1 \\rightarrow^T v_2 \\rightarrow^T \\dots \\rightarrow^T v_k = 0$.\n$v_{k-1} \\in range \\ T \\cap null \\ T$, so $v_{k-1} = 0$.\n…\n$v_1 \\in range \\ T \\cap null \\ T$, so $v_1 = 0$.\nThus $Tv = v_1 = 0$, and $v \\in null \\ T$.\nTheorem. $range \\ T^k = range \\ T$.\nLet $T’$ be the same as $T$ but restricted on subspace $range \\ T$. Observe it is a linear operator.\nWe prove $null \\ T’ = {0}$. Observe for $v \\in null \\ T’$, $v \\in range \\ T \\cap null \\ T$, and hence $v = 0$. Clearly $T\u0026#39;0 = 0$ as $T0 = 0$ for any operator $T$.\nIt follows $dim \\ null \\ T’ = 0$. By The Fundamental Theorem of Linear Maps (See Axler page 63), $dim \\ range \\ T = dim \\ range \\ T’$. But by definition $range \\ T’ \\subset range \\ T$, and therefore $range \\ T’ = range \\ T$.\nWe conclude $T[range \\ T] = range \\ T$, The image of $range \\ T$ under $T$ is exactly $range \\ T$. Clearly it suffices to prove our intended theorem.\nEx. 19 By normality we know $null \\ T = (range \\ T)^\\bot$. So $(z_1, z_2, z_3) \\bot v$, for any $v \\in ran \\ T$. It follows \\begin{align*} (z_1, z_2, z_3) \\cdot v \u0026amp;= 0 \\\\ (z_1, z_2, z_3) \\cdot T(1, 1, 1) \u0026amp;= 0 \\\\ \u0026amp;= (z_1, z_2, z_3) \\cdot (2, 2, 2) = 2 z_1 + 2 z_2 + 2 z_3 = 2 (z_1 + z_2 + z_3) \\end{align*} Thus $z_1 + z_2 + z_3 = 0$.\n","date":1691884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1691884800,"objectID":"286369b690a364a2bf71324590356ab4","permalink":"https://mostafatouny.github.io/axler-linear-post/ch07-seca/","publishdate":"2023-08-13T00:00:00Z","relpermalink":"/axler-linear-post/ch07-seca/","section":"axler-linear-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 11 $(\\rightarrow)$ Observe $v = v_U + v_{U^\\bot}$ and $w = w_U + w_{U^\\bot}$. Clearly, \\begin{aligned} \\langle Pv, w \\rangle \u0026= \\langle v_U, w \\rangle \\\\ \u0026= \\langle v_U, w_{U^\\bot} \\rangle + \\langle v_U, w_U \\rangle \\\\ \u0026= 0 + \\langle v_U, w_U \\rangle \\\\ \\langle v, Pw \\rangle \u0026= \\langle v_{U^\\bot}, w_U \\rangle + \\langle v_U, w_U \\rangle \\\\ \u0026= 0 + \\langle v_U, w_U \\rangle \\end{aligned}","tags":null,"title":"Ch. 07, Sec. A","type":"axler-linear-post"},{"authors":null,"categories":null,"content":"Materials MIT OCW Problem Sets Problem Source Solution P. Set 01 Here PDF, HTML P. Set 02 Here PDF, HTML P. Set 03 Here PDF, HTML P. Set 04 Here PDF, HTML P. Set 05 Here PDF, HTML P. Set 06 Here PDF, HTML P. Set 07 Here PDF, HTML P. Set 08 Here PDF, HTML P. Set 09 Here PDF, HTML P. Set 10 Here PDF, HTML ","date":1691280000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1691280000,"objectID":"03658d7aae22347b347123ecf220f522","permalink":"https://mostafatouny.github.io/post/erik-alg-pset/","publishdate":"2023-08-06T00:00:00Z","relpermalink":"/post/erik-alg-pset/","section":"post","summary":"Self-studying Proof-based Algorithms by Erik Demaine.","tags":null,"title":"Erik's Algorithms","type":"post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nProblems Prob. 1 a The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.\nb A randomized algorithm identical to slide 18, satisfies all the problem’s requirements.\nThe sole difference is the subroutine which exchanges all UIDs. In round $1$, A process sends its randomly generated UID to the right port. In round $r \u0026gt; 1$, The received message from the left port in the previous round is sent to the right port. All processes record received UIDs and stop after recording $n$ of them.\nThat subroutine consumes $\\mathcal{O}(n)$ rounds and $\\mathcal{O}(n^2)$ messages.\nc I conjecture the answer there is no such algorithm; I couldn’t come-up with a rigorous proof. Here is an insight justifying my stance.\nThe only way processes can know each other’s UIDs is by circulating their UIDs. They cannot ever know whether the whole ring is covered. For example, If a process recorded $(a,b,c,a)$ then it can be tricked by the actual complete ring $(a,b,c,a,d)$ whose size is $5$. It is trivial to generalize the trick to accommodate any number of loops of $a$, like $(a,b,c,a,b,c,a)$ tricked by ring $(a,b,c,a,b,c,a,d)$.\nProb. 2 a I am not sure what is the sufficent degree of clarity the instructor is looking for. Neither do I claim my argument to be formally rigorous or even convincing. However, We hope it fulfills all the practical purposes of two introductory lectures.\nThe key idea is for processes, not to send search unless the root $v_0$ broadcasts ready. Also, ready is broadcasted by $v_0$ only if all of its neighbours signaled level $i$ updated their parents.\nb Time. For each level, the root $v_0$ broadcasts ready and receives a response, Accounting for $diam \\cdot 2(diam)$ edges traversed. That concludes the desired $\\mathcal{O}(diam^2 \\cdot d)$ upper-bound.\nMessages. For each level, At most all vertices, both receive and send a message, Accounting for $diam \\cdot 2n$.\n","date":1691280000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1691280000,"objectID":"bc474f87f22fc294f7822cdf76719d57","permalink":"https://mostafatouny.github.io/erik-alg-post/pset10/","publishdate":"2023-08-06T00:00:00Z","relpermalink":"/erik-alg-post/pset10/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nProblems Prob. 1 a The proof is identical to slide 15. Note the symmetric structure of the ring where, as all processes are identical they send the same message to their right port and receive the same message from their left port.","tags":null,"title":"Problem Set 10","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Ex. 2 Ex. 3 Ex. 4 Problems Prob. 1 a Consider $$\\begin{aligned} A \u0026amp;= { 1, 2 } \\\\ S \u0026amp;= { 1, 50 } \\\\ V \u0026amp;= { 2, 50 } \\\\ B \u0026amp;= 50\\end{aligned}$$ Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$. Therefore the approximation ratio is $2/50 = 1/25$.\nIt is easy to see the number $50$ can be set arbitrarily larger, and therefore we can reach the desired unbounded approximation ratio.\nb We follow the same convention of assuming the given indices order follow non-increasing order of their densities.\nFor the first index $i$ such that $\\sum_{j=1}^{i} v_j \u0026gt; B$, denote items up to $i-1$ by Max-Dens-Items and $i$th item by First-Overweight. For item $a_i$ denote $D(a_i)$ to be the density of $a_i$, i.e the value per one unit of weight.\nTake D(First-Overweight) and multiply it by the slack weight in $B$ after consuming weights of Max-Dens-Items. Sum the resulting value along values of Max-Dens-Items and let $V_{maxDensities}$ denote that sum.\nIt is very clear $C* \\leq V_{maxDensities}$ as we fully utilized the space of $B$ with maximum possible densities.\nLet’s return to Alg2 and note how similar it is to the way we defined $V_{maxDensities}$. Remark that $C = max{ V_{maxDensities}, \\textit{value of First-Overweight} }$. We have two cases:\nCase 1. Weights of Max-Dens-Items $\\geq \\frac{\\displaystyle{B}}{\\displaystyle{2}}$.\nThen $C \\geq \\frac{\\displaystyle{ V_{maxDensities} }}{\\displaystyle{2}}$, As Max-Dens-Items accounts for more than 50% of $V_{maxDensities}$. Case 2. Weights of Max-Dens-Items $\u0026lt; \\frac{\\displaystyle{B}}{\\displaystyle{2}}$.\nThen the weight of First-Overweight is greater than $\\frac{\\displaystyle{B}}{\\displaystyle{2}}$. It follows $V_{maxDensities}$ is contributed only by Max-Dens-Items and First-Overweight. Observe one of them must contribute at least 50% of $V_{maxDensities}$. By definition, that one shall be selected by Alg2, and therefore $C \\geq \\frac{\\displaystyle{ V_{maxDensities} }}{\\displaystyle{2}}$. c That is a standard dynamic programming problem whose solution can be found in any textbook. For brevity we only show the recurrece relation.\nBase: $S_{1,v} = w(a_1)$ if $w(a_1) = v$.\nInduction Step: $S_{i,v} = min{ S_{i-1,v}, w(a_i) + S_{i-1, v-v_i} }$\nd Polynomial Time Complexity. Observe the time complexity of $Alg3$ is $\\mathcal{O}(n^2 V)$, As the memoization table is:\nvalue\\items 1 .. n 1 .. nV Since $Alg4$ basically runs $Alg3$ with additional linear operations, Its time complexity is $\\mathcal{O}(n^2 V’)$, where $V’$ is similarly defined but on scaled values $v_i’$.\nClearly $V’ = \\lfloor \\frac{\\displaystyle{V}}{\\displaystyle{V}} \\cdot \\frac{\\displaystyle{n}}{\\displaystyle{\\epsilon}} \\rfloor = \\lfloor \\frac{\\displaystyle{n}}{\\displaystyle{\\epsilon}} \\rfloor$. So complexity of $Alg4$ can be re-written as $\\mathcal{O}(n^3 \\cdot \\frac{1}{\\epsilon})$.\nApproximation Scheme. The idea is to use the bound of b but on scaled values $v_i’$, then reverse the scaling to reach the intended ratio.\nLet $U$ be the upper-bound of optimal solutions which we defined earlier in b on given values $v_i$. Let $U’$ be similarly defined but on scaled values $v_i’$. Define function $f$ so that it scales value as mentioned by the author. Let $C$ and $C’$ denote the value of the subset solution obtained by $Alg4$ but on given and scaled values respectively.\nFrom b, We know there exists a solution on scaled values $v_i’$ whose approximation ratio is $2$, out of $U’$. Then trivially the optimal solution also can deviate by a ratio of at most $2$ out of $U’$.\nObserve if we scaled back a value then the calculated value is no greater than the original given value, since we are taking ceils. In other words, $f^{-1}(v_i’) \\leq v_i$.\nJoining all these remarks: \\begin{aligned} C’ \u0026amp;\\geq \\frac{1}{2} U’ \\\\ C \\geq f^{-1}(C’) \u0026amp;\\geq \\frac{1}{2} f^{-1}(U’) = U \\end{aligned} From b, That suffices to concluding $Alg4$ is an approximation scheme.\nProb. 2 a Assume for the sake of contradiction there is a cycle $c_0$ in the reversed graph $\\hat{G}$. Then it must contain an edge from $A$. Otherwise $c_0$ would also be in graph $G$ and by definition it must contain an edge from $A$. Call that edge $a$. Returning to $G$, $a$ would be reversed as in the figure below. It is possible to have edges other than $a$ in cycle $c_0$ which would also be reversed in graph $G$ In this case $p_0$ would be constructed by taking the corresponding sub-cycles into it.\nSince $A$ is minimal there must be a cycle $c_1$ in graph $G$ which would not be covered if not for $a$. Observe we have cycle $c_2$ constructed by paths $p_0$ and $p_1$. What covers $c_2$ in $G$? Clearly no edge in path $p_0$ would do that since we already considered all edges of $A$ we might encounter and took a sub-cycle avoiding them. Then $c_2$ is covered by edge $b$ in path $p_1$ which is part of the cycle $c_1$. That contradicts $c_1$ being a cycle only covered by edge $a$ …","date":1690934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1690934400,"objectID":"e47e778c5a03b0ba23fad9adc1852026","permalink":"https://mostafatouny.github.io/erik-alg-post/pset09/","publishdate":"2023-08-02T00:00:00Z","relpermalink":"/erik-alg-post/pset09/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Ex. 2 Ex. 3 Ex. 4 Problems Prob. 1 a Consider $$\\begin{aligned} A \u0026= { 1, 2 } \\\\ S \u0026= { 1, 50 } \\\\ V \u0026= { 2, 50 } \\\\ B \u0026= 50\\end{aligned}$$ Observe the optimal solution is $C = 50$ while Alg1 is of value $C* = 2$.","tags":null,"title":"Problem Set 09","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nEx. 2 \\begin{aligned} \\text{Maximize } \u0026amp;d_y \\\\ \\text{Subject to } \u0026amp;d_s = 0 \\\\ \u0026amp;d_t \\leq d_s + w(s,t) \\\\ \u0026amp;d_y \\leq d_s + w(s,y) \\\\ \u0026amp;d_y \\leq d_t + w(t,y) \\\\ \u0026amp;d_x \\leq d_t + w(t,x) \\\\ \u0026amp;d_t \\leq d_y + w(y,t) \\\\ \u0026amp;d_x \\leq d_y + w(y,x) \\\\ \u0026amp;d_z \\leq d_y + w(y,z) \\\\ \u0026amp;d_z \\leq d_x + w(x,z) \\\\ \u0026amp;d_x \\leq d_z + w(z,x) \\\\ \u0026amp;d_s \\leq d_z + w(z,s) \\end{aligned}\nEx. 3 \\begin{aligned} \\text{Maximize } \\sum_{v \\in V} f_{sv} \u0026amp;- \\sum_{v \\in V} f_{vs} \\\\ \\text{Subject to } f_{s,v_1} \u0026amp;\\leq c(s,v_1) \\\\ f_{s,v_2} \u0026amp;\\leq c(s,v_2) \\\\ f_{v_1,v_3} \u0026amp;\\leq c(v_1,v_3) \\\\ f_{v_2,v_1} \u0026amp;\\leq c(v_2,v_1) \\\\ f_{v_2,v_4} \u0026amp;\\leq c(v_2,v_4) \\\\ f_{v_3,v_2} \u0026amp;\\leq c(v_3,v_2) \\\\ f_{v_3,t} \u0026amp;\\leq c(v_3,t) \\\\ f_{v_4,v_3} \u0026amp;\\leq c(v_4,v_3) \\\\ f_{v_4,t} \u0026amp;\\leq c(v_4,t) \\\\ \\\\ \\sum_{v \\in V} f_{v_1v} \u0026amp;= \\sum_{v \\in V} f_{vv_1} \\\\ \\sum_{v \\in V} f_{v_2v} \u0026amp;= \\sum_{v \\in V} f_{vv_2} \\\\ \\sum_{v \\in V} f_{v_3v} \u0026amp;= \\sum_{v \\in V} f_{vv_3} \\\\ \\sum_{v \\in V} f_{v_4v} \u0026amp;= \\sum_{v \\in V} f_{vv_4} \\\\ \\\\ f_{sv_1} \u0026amp;\\geq 0 \\\\ f_{sv_2} \u0026amp;\\geq 0 \\\\ f_{v_1v_3} \u0026amp;\\geq 0 \\\\ f_{v_2v_1} \u0026amp;\\geq 0 \\\\ f_{v_2v_4} \u0026amp;\\geq 0 \\\\ f_{v_3v_2} \u0026amp;\\geq 0 \\\\ \\\\ f_{v_4t} \u0026amp;\\geq 0 \\end{aligned}\nEx. 4 Ex. 5 Problems Prob. 1 a For the sake of time, We cheat by a drawn graph from desmos.\nb Standard Form\nHere $n=2$ and $m=4$. \\begin{aligned} \\text{Maximize } 4(x_1) \u0026amp;+ 1(x_2) \\\\ \\text{Subject to } 1(x_1) \u0026amp;+ 1(x_2) \\leq 10 \\\\ 4(x_1) \u0026amp;+ -1(x_2) \\leq 20 \\\\ 1(x_1) \u0026amp;+ 3(x_2) \\leq 24 \\\\ x_1, x_2 \u0026amp;\\geq 0 \\end{aligned}\nSlack Form\n\\begin{aligned} \\text{Maximize } \u0026amp;4(x_1) + 1(x_2) \\\\ \\text{Subject to } \u0026amp;x_3 = -1(x_1) - 1(x_2) + 10 \\\\ \u0026amp;x_4 = -4(x_1) + 1(x_2) + 20 \\\\ \u0026amp;x_5 = -1(x_1) - 3(x_2) + 24 \\\\ \u0026amp;x_1, x_2, x_3, x_4, x_5 \\geq 0 \\end{aligned}\nc The solution form is $(x_1,x_2,x_3,x_4,x_5)$ where $x_1, x_2$ are basic and $x_3,x_4,x_5$ are non-basic.\nBasic solution, by setting basic variables to zeros is $(0,0,10,20,24)$.\nInterchange basic $x_1$ with non-basic $x_4$. Solving $x_1$ by the equation of $x_4$, We get $x_1 = 5 + \\frac{\\displaystyle{1}}{\\displaystyle{4}}x_2 + \\frac{\\displaystyle{-1}}{\\displaystyle{4}} x_4$.\nSubstituting the new equation into remaining ones, We get: \\begin{aligned} \\text{Maximize } \u0026amp;20 + 2x_2 - x_4 \\\\ \\text{Subject to } \u0026amp;x_1 = 5 + \\frac{\\displaystyle{1}}{\\displaystyle{4}}x_2 + \\frac{\\displaystyle{-1}}{\\displaystyle{4}}x_4 \\\\ \u0026amp;x_3 = 5 - \\frac{\\displaystyle{5}}{\\displaystyle{4}}x_2 + \\frac{\\displaystyle{1}}{\\displaystyle{4}}x_4 \\\\ \u0026amp;x_5 = 19 + \\frac{\\displaystyle{-13}}{\\displaystyle{4}}x_2 + \\frac{\\displaystyle{1}}{\\displaystyle{4}}x_4 \\\\ \u0026amp;x_1, x_2, x_3, x_4, x_5 \\geq 0 \\end{aligned}\nSolution = $(5, 0, 5, 4, 19)$ with objective equal to $20$.\nInterchange basic $x_2$ with non-basic $x_3$. Solving $x_2$ by the equation of $x_3$, We get $x_2 = 4 - \\frac{\\displaystyle{4}}{\\displaystyle{5}} x_3 + \\frac{\\displaystyle{1}}{\\displaystyle{5}} x_4$.\nSubstituting the new equation into remaining ones, We get: \\begin{aligned} \\text{Maximize } \u0026amp;28 - \\frac{\\displaystyle{8}}{\\displaystyle{5}}x_3 - \\frac{\\displaystyle{3}}{\\displaystyle{5}}x_4 \\\\ \\text{Subject to } \u0026amp;x_1 = 6 - \\frac{\\displaystyle{1}}{\\displaystyle{5}}x_3 - \\frac{\\displaystyle{19}}{\\displaystyle{20}}x_4 \\\\ \u0026amp;x_2 = 4 - \\frac{\\displaystyle{4}}{\\displaystyle{5}}x_3 + \\frac{\\displaystyle{1}}{\\displaystyle{5}}x_4 \\\\ \u0026amp;x_5 = 6 + \\frac{\\displaystyle{13}}{\\displaystyle{5}}x_3 - \\frac{\\displaystyle{8}}{\\displaystyle{20}}x_4 \\\\ \u0026amp;x_1, x_2, x_3, x_4, x_5 \\geq 0 \\end{aligned}\nSolution = $(6, 4, 0, 0, 6)$ with objective equal to $28$.\nQuoting from CLRS, page 868: \u0026#34;At this point, all coefﬁcients in the objective function are negative. As we shall see later in this chapter, this situation occurs only when we have rewritten the linear program so that the basic solution is an optimal solution.\u0026#34;\nd \\begin{aligned} \\text{Minimize } \u0026amp;10y_1 + 20y_2 + 24y_3 \\ \\text{Subject to } \u0026amp;1y_1 + 4y_2 + 1y_3 \\geq 4\\ \u0026amp;1y_1 - 1y_2 + 3y_3 \\geq 1\\ \u0026amp;y_1, y_2, y_3 \\geq 0 \\end{aligned} From c we know the optimal value is 28.\nProb. 2 a Given a $3SAT$ formula $\\phi$, Construct $\\phi’ = \\phi \\wedge (x_{n+1} \\vee x_{n+2})$. Observe every True assignment of $\\phi$ corresponds to three distinct True assignments of $\\phi’$. It follows $\\phi$ is solvable if and only if $\\phi’$ is, and the solution of $3SAT$ is basically the output on $\\phi$ in formula of $\\phi’$. Therefore $3SAT$ is reduced to TRIPLE-SAT.\nb Observe the following illustrative example reducing $3SAT$ to $DONUT$.\nAll profits of vertices equal exactly 1. Every clause is transformed to a complete 3-vertices sub-graph. It ensures Every 1 counted of $k$ must be of a distinct sub-graph. $k$, the profit threshold to be satisfied, is equal to the number of clauses. It ensures every clause to be satisfied corresponds to counting 1 of k. For consistency, There is an edge between every $v_i$ and $\\neg v_i$, So that we cannot select both of them. It is not problemetic to select $v_i$ multiple times. It is interpreted by many clauses being satisfied by the same …","date":1689465600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1689465600,"objectID":"5ea87943c1b38abbade7cf7e25fd2788","permalink":"https://mostafatouny.github.io/erik-alg-post/pset08/","publishdate":"2023-07-16T00:00:00Z","relpermalink":"/erik-alg-post/pset08/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done\nEx. 2 \\begin{aligned} \\text{Maximize } \u0026d_y \\\\ \\text{Subject to } \u0026d_s = 0 \\\\ \u0026d_t \\leq d_s + w(s,t) \\\\ \u0026d_y \\leq d_s + w(s,y) \\\\ \u0026d_y \\leq d_t + w(t,y) \\\\ \u0026d_x \\leq d_t + w(t,x) \\\\ \u0026d_t \\leq d_y + w(y,t) \\\\ \u0026d_x \\leq d_y + w(y,x) \\\\ \u0026d_z \\leq d_y + w(y,z) \\\\ \u0026d_z \\leq d_x + w(x,z) \\\\ \u0026d_x \\leq d_z + w(z,x) \\\\ \u0026d_s \\leq d_z + w(z,s) \\end{aligned}","tags":null,"title":"Problem Set 08","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Will do while solving the exercises.\nEx. 2 Definitions \u0026amp; Properties Extended Network Instructed below Source s Sources ${s_1, s_2, \\dots, s_{k_s}}$ Sink t Sinks ${t_1, t_2, \\dots, t_{k_t} }$ Capacity constraint Same Flow conservation V - {sources} - {sinks} flow value $|f|$ $\\sum_{s_i} ( \\sum_v f(s_i,v) - \\sum_v f(v, s_i) )$ For brevity we illustrate the construction definition by the following diagram.\nObserve $\\sum_v f(s_{sup},v) = \\sum_{s_i} \\sum_v f(s_i, v)$ and $\\sum_v f(v,s_{sup}) = \\sum_{s_i} \\sum_v f(v,s_i)$ which concludes our goal.\nEx. 3 Denote $f = \\alpha f_1 + (1-\\alpha) f_2$. We show $f$ satisfies both definitions of (1) capacity and (2) reservation.\n(1) Clearly \\begin{aligned} 0 \\leq \\alpha f_1(u,v) \u0026amp;\\leq \\alpha c(u,v) \\\\ 0 \\leq (1-\\alpha) f_2(u,v) \u0026amp;\\leq (1-\\alpha) c(u,v) \\end{aligned} Which concludes \\begin{aligned} \\alpha f_1(u,v) + (1-\\alpha) f_2(u,v) \\leq \\alpha c(u,v) + (1-\\alpha) c(u,v) = c(u,v) \\end{aligned}\n(2) Clearly, \\begin{aligned} \\alpha \\sum_v f_1(u,v) \u0026amp;= \\alpha \\sum_v f_1(v,u) \\\\ (1-\\alpha) \\sum_v f_2(u,v) \u0026amp;= (1-\\alpha) \\sum_v f_2(v,u) \\end{aligned} Which concludes \\begin{aligned} \\sum_v \\alpha f_1(u,v) + (1-\\alpha) f_2(u,v) = \\sum_v \\alpha f_1(v,u) + (1-\\alpha) f_2(v,u) \\end{aligned}\nEx. 4 Intuitively and without proof, min-cut is $S = {s, v_1, v_2, v_4}$ and $T = {v_3, t}$.\nEx. 5 Comment: I don’t feel confident about the solution.\nBy Ex. 2 we have a construction procedure from multiple to single with the same flow value. Intuitively and without proof, a flow of multiple corresponds to a flow of the same value in single. Then solving the single yields a max-flow for multiple.\nProblems Prob. 1 a 1\nNotation. We say an edge $(u,v)$ is saturated in $F$ if $f(u,v) = c(u,v)$.\nFact. Since $F$ is a max-flow, we know there is no augmenting path existing in it.\nLemma. Based on the fact, Lest a flow greater than $|f|$ gets constructed in $F$, The following cannot happen in $F’$:\nAugmenting path, not containing edge $(u,v)$.\nAugmenting path, containing $(u,v)$, but $(u,v)$ was not saturated in $F$.\nAugmenting path, containing $(u,v)$, but $f(u,v)$ is decreased.\nLemma. Then, the possible cases of $F’$ are:\nNo augmenting path exists, Then $|f’| = |f|$.\nAugmenting path exists, containing $(u,v)$, which was saturated in $F$, and flow increases it in $F’$. Since $c’(u,v) = f(u,v) + 1$, Then by definition of taking the minimum values along the path, It is concluded the increase in flow is at most 1.\nIf an augmenting path is taken in $F’$, Then by the same line of reasoning, No second augmenting path is possible. Note $f’(u,v) = c’(u,v)$ now.\n2\nSimilar.\nA difference is the increase shall be at most k rather than at most 1, Following taking the minimum values along the augmenting path.\nIt is possible to have multiple augmenting paths, but even in that case, the overall increase shall be upperbounded by $k$.\nThe same line of reasoning leads to, any existing augmenting path, must be in the edge $(u,v)$ whose capacity is increased.\n3\nSymmetric.\n4\nSimilar.\nb Intuitively and without a proof, apply Ford-Fulkerson method, Searching for paths which only contains edge $(u,v)$ whose capacity is increased. Intuitively that search restriction yields the upperbound $k \\cdot (V+E)$.\nc Intuitively and without a proof, If the new capacity $c(u,v)$ is less than the flow of $F$, Fix the flow by decreasing flow values of edges which are in paths containing $(u,v)$, Then similarly to b, apply Ford-Fulkerson but only on paths containing $(u,v)$. Intuitively that search restriction yields the upperbound $k \\cdot (V+E)$\nProb. 2 Out solution is based on intuition not a rigorous proof. Given a directed graph input, Construct a corresponding flow network where:\nA new source vertex $s$ has a new edge with each $s_i$. All edges have a capacity equal to $1$. Then we run Ford-Fulkerson to find the maximum flow. Now observe\nIf max-flow $|f| = k$, output \u0026#34;Possible\u0026#34; if max-flow $|f| \\neq k$, output \u0026#34;Impossible\u0026#34; The goal of edge-disjoint paths is realized by setting all capacities to 1. If max-flow is $k$ then each $s_i$ has a path to $t$. If max-flow is not $k$ then it must be less than $k$ and means some $s_i$ doesn’t have a successful flow to $t$.\nProb. 3 Observe the following illustrative diagram which models the problem as a max-flow problem.\nA customer $a_i$ has an edge with food $b_j$ in our constructed graph, If we are given $b_j \\in A_i$. There is an additional edge for each customer to the special vertex 10$.\nIntuitively and without a proof, Maximizing a flow, corresponds to minimizing the 1-flow value output from each customer to the 10$ vertex as it does not reach vertex t and hence does not contribute to increasing the flow.\n","date":1688947200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1688947200,"objectID":"0ec792b081f06f61fe448f76eedbb21e","permalink":"https://mostafatouny.github.io/erik-alg-post/pset07/","publishdate":"2023-07-10T00:00:00Z","relpermalink":"/erik-alg-post/pset07/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Will do while solving the exercises.\nEx. 2 Definitions \u0026 Properties Extended Network Instructed below Source s Sources ${s_1, s_2, \\dots, s_{k_s}}$ Sink t Sinks ${t_1, t_2, \\dots, t_{k_t} }$ Capacity constraint Same Flow conservation V - {sources} - {sinks} flow value $|f|$ $\\sum_{s_i} ( \\sum_v f(s_i,v) - \\sum_v f(v, s_i) )$ For brevity we illustrate the construction definition by the following diagram.","tags":null,"title":"Problem Set 07","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Materials MIT OCW Book: Principles of Mathematical Analysis by Walter Rudin, 3rd ed. Problem Sets Problem Source Solution P. Set 01 Here PDF, HTML P. Set 02 Here PDF, HTML P. Set 03 Here PDF, HTML P. Set 04 Here PDF, HTML P. Set 05 Here P. Set 06 Here PDF, HTML P. Set 07 Here PDF, HTML P. Set 08 Here PDF, HTML ","date":1687737600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1687737600,"objectID":"ea9fca7975f14e67eda13ff40b6b5dae","permalink":"https://mostafatouny.github.io/post/mit-analysis1c-pset/","publishdate":"2023-06-26T00:00:00Z","relpermalink":"/post/mit-analysis1c-pset/","section":"post","summary":"Self-studying real analysis companioned to Rudin.","tags":null,"title":"Baby Rudin's Real Analysis","type":"post"},{"authors":null,"categories":null,"content":"Problem. 1 By boundedness we get $|f(x)| \\leq M_f$ and $|g(x)| \\leq M_g$. Clearly there is $N_g$ such that for $n \\geq N_g$, $|g_n(x)| \\leq M_g + \\epsilon_g$.\nLet $\\epsilon \u0026gt; 0$ be arbitrary. Define $\\epsilon_0 = \\frac{\\displaystyle{\\epsilon}}{\\displaystyle{2(M_g + \\epsilon_g)}}$ and $\\epsilon_1 = \\frac{\\displaystyle{\\epsilon}}{\\displaystyle{2(M_f)}}$.\nBy hypothesis we have can take $N_{max}$ considering also $N_g$ to get \\begin{aligned} |f_n(x) - f(x)| \u0026lt; +\\epsilon_0 \\\\ |g_n(x) - g(x)| \u0026lt; +\\epsilon_1 \\end{aligned} By multiplication, \\begin{aligned} |f_n(x) g_n(x) - f(x) g_n(x)| \u0026lt; +\\epsilon_0 \\cdot |g_n(x)| \\\\ |f(x) g_n(x) - f(x) g(x)| \u0026lt; +\\epsilon_1 \\cdot |f(x)| \\end{aligned} Now observe: \\begin{aligned} |f_n(x) g_n(x) - f(x) g(x)| \u0026amp;= |f_n(x) g_n(x) - f(x) g_n(x) + f(x) g_n(x) - f(x) g(x)| \\\\ \u0026amp;\\leq |f_n(x) g_n(x) - f(x) g_n(x)| + |f(x) g_n(x) - f(x)g(x)| \\\\ \u0026amp;\u0026lt; \\epsilon_0 |g_n(x)| + \\epsilon_1 |f(x)| \\\\ \u0026amp;\\leq \\epsilon_0 (M_g + \\epsilon_g) + \\epsilon_1 (M_f) \\\\ \u0026amp;= \\epsilon/2 + \\epsilon/2 = \\epsilon \\end{aligned} The second line follows by triangular inequality.\nProblem. 2 Lemma. $\\hat{f}$ is of the same class.\nBy definition, The domain of $\\hat{f}$ is the same as $f$. Clearly $\\hat{f}(0) = \\frac{\\displaystyle{1}}{\\displaystyle{4}} f(2 \\cdot 0) = \\frac{\\displaystyle{1}}{\\displaystyle{4}} f(0) = \\frac{\\displaystyle{1}}{\\displaystyle{4}} (0) = 0$ and $\\hat{f}(1) = \\frac{\\displaystyle{3}}{\\displaystyle{4}} f(2 \\cdot 1 - 1) + \\frac{\\displaystyle{1}}{\\displaystyle{4}} = \\frac{\\displaystyle{3}}{\\displaystyle{4}} f(1) +\\frac{\\displaystyle{1}}{\\displaystyle{4}} = \\frac{\\displaystyle{3}}{\\displaystyle{4}} (1) + \\frac{\\displaystyle{1}}{\\displaystyle{4}} = 1$.\nThe continuity of $\\hat{f}$ follows by the continuity of $f$. Consider arbitrary $\\hat{f}(q)$ and $\\epsilon \u0026gt; 0$. Consider the case of $\\hat{f}(q) = \\frac{\\displaystyle{3}}{\\displaystyle{4}} f(2q-1) + \\frac{\\displaystyle{1}}{\\displaystyle{4}}$ and note the other case is symmetric. Take $\\grave{\\epsilon} = \\frac{\\displaystyle{4}}{\\displaystyle{3}} \\epsilon$. By continuity of $f$, There exists $\\delta$ such that for any $r$, if $| r - p | \u0026lt; \\delta$ then $| f(r) - f(p) | \u0026lt; \\grave{\\epsilon}$. Define $\\grave{\\delta} = \\frac{\\displaystyle{\\delta}}{\\displaystyle{2}}$, and observe for any $r$: \\begin{aligned} \\text{If } \u0026amp; | r - q | \u0026lt; \\grave{\\delta} = \\frac{\\displaystyle{\\delta}}{\\displaystyle{2}} \\\\ \\text{Then } \u0026amp; | (2r+1) - (2q+1) | \u0026lt; \\delta \\\\ \\text{By Continuity } \u0026amp; | f(2r+1) - f(2q+1) | \u0026lt; \\grave{\\epsilon} = \\frac{\\displaystyle{4}}{\\displaystyle{3}} \\epsilon \\\\ \\text{Then } \u0026amp; | (\\frac{\\displaystyle{3}}{\\displaystyle{4}} f(2r+1) + \\frac{\\displaystyle{1}}{\\displaystyle{4}}) - (\\frac{\\displaystyle{3}}{\\displaystyle{4}} f(2q+1) + \\frac{\\displaystyle{1}}{\\displaystyle{4}}) | \u0026lt; \\epsilon \\\\ \\text{By definition } \u0026amp; | \\hat{f}(r) - \\hat{f}(q) | \u0026lt; \\epsilon \\end{aligned}\nProblem. 3 We use the following theorem found in Rudin’s book in page 59.\nFix $x \\in [a,b]$. The theorem follows by the following lemmas\n(i) $\\sum_{k=n}^m f_k(x) \\geq 0$ for odd $n$. (ii) $\\sum_{k=n}^m f_k(x) \\leq 0$ for even $n$. (iii) Given $f_n(x) = +M$ for odd $n$ and non-negative $M$, $\\sum_{k=n}^m f_n(x) \\leq M$. (iv) Given $f_n(x) = -M$ for even $n$ and non-negative $M$, $\\sum_{k=n}^m f_n(x) \\geq -M$. Proof.\n(i). Follows by a strong form of induction. Observe for odd $n$, $|f_n(x)| \\geq |f_{n+1}(x)|$ yields $f_n(x) + f_{n+1} \\geq 0$. The induction step is to show $\\sum_{k=n}^{m+2} f_k(x) \\geq 0$ given $\\sum_{k=n}^{m} f_k(x) \\geq 0$ and $\\sum_{k=n}^{m+1} f_k(x) \\geq 0$.\n(ii). Symmetric to (i).\n(iii) Expand to $f_n(x) + \\sum_{k=n+1}^m f_k(x)$, Then it follows immediately by (ii)\n(iv). Symmetric to (iii).\nTheorem. These lemmas conclude, Given $f_n(x) = M$ regardless $n$ is even or odd, $|\\sum_{k=n}^m f_k(x)| \\leq |M|$. But we are given $f_n(x)$ converges to 0, So we can substitute $M$ by any $\\epsilon \u0026gt; 0$.\n","date":1687737600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1687737600,"objectID":"860da1e8e7a6024f53247c5958034bb2","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset08/","publishdate":"2023-06-26T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset08/","section":"mit-analysis1c-post","summary":"Problem. 1 By boundedness we get $|f(x)| \\leq M_f$ and $|g(x)| \\leq M_g$. Clearly there is $N_g$ such that for $n \\geq N_g$, $|g_n(x)| \\leq M_g + \\epsilon_g$.\nLet $\\epsilon \u003e 0$ be arbitrary.","tags":null,"title":"Problem Set 08","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 skipped in hope of professionally read while solving the exercises, and well-gain from lectures.\nEx. 2 To definte shortest-path weight function $\\delta$, which satisfies the triangle inequality, enabling the second property of $\\overline{w}$.\nEx. 3 For a cycle $c = v_0, v_1, \\dots, v_k=v_0$ we are given $w(c) = 0$. It is natural to ignore the case $k = 0$.\nRecall the facts\n$\\overline{w}(u,v) \\geq 0$ $\\overline{w}(u,v) = w(u,v) + h(u) - h(v)$ $\\overline{w}(p) = w(p) + h(v_0) - h(v_k)$ for path $p$ Lemma. $\\Sigma \\overline{w}(v_i, v_{i+1}) = 0$\n$$\\begin{aligned} \\overline{w}(c) \u0026amp;= w(c) + h(v_0) - h(v_k) \\\\ \u0026amp;= 0 + h(v_0) - h(v_0), v_0=v_k \\\\ \u0026amp;= 0 \\end{aligned}$$\nIf any $\\overline{w}(v_i,v_{i+1}) \u0026gt; 0$ then $\\overline{w}(c) \u0026gt; 0$, contradicting the proved above lemma.\nEx. 4 skipped in hope of professionally read while solving the exercises, and well-gain from lectures.\nEx. 5 In page 636 there is a hint of using fibonacci-heabs. I am not sure whether it is the key of solving the problem. Anyway, The exercise is postponed untill we gain a guidance from others. Skimming the chapter did not yield any promising clue to pursue.\nEx. 6 Same as Ex. 5\nProblems Prob. 1 a Case $r = w_{i,j}$. Nothing to be done.\nCase $r \u0026lt; w_{i,j}$. Check to see if new paths including edge $(i,j)$ offer less-weight.\n(For LaTeX issue we denote matrix $\\Pi$ by $P$)\nfor x = 0 to n for y = 0 to n if d_x,i + r + d_j,y \u0026lt; d_x,y d_x,y = d_x,i + r + d_j,y P(x,j) = i P(x,y) = P(j,y) Observe $\\Pi(x,i)$ is the same, and same for its recursive vertices. Similarly to $\\Pi(j,y)$.\nComplexity. $\\mathcal{O}(V^2)$\nCase $r \u0026gt; w_{i,j}$. For paths which do not depend on $w_{i,j}$, Nothing needs to be updated about them. If their paths are less or equal than any path which includes $w_{i,j}$ then obviously these paths are still optimal when the weight of $w_{i,j}$ increases. If for vertex $x$, $P(x,j) != i$ then $x$ shall never visit edge $\\set{i,j}$.\nOur focus starts on vertices $x$ whose $\\Pi(x,j)$ equals $i$. For each such $x$ and each arbitrary vertex $y$, We compute minimum paths from $x$ to $y$ and update if needed. Let $D’$ and $\\Pi’$ denote minimum distance and predecessor matrices after updating the weight of edge $\\set{i,j}$ to $r$, respectively. Any path $x \\rightarrow y$ either consists of a single edge $\\set{x,y}$ or contains an intermediate vertex between $x$ and $y$. We loop on all vertices $z$ to compute $D(x,z) + D(z,y)$ and then set $D’(x,y)$. However, we must check whether edge $\\set{i,j}$ falls into the path $x \\rightarrow z$ or $z \\rightarrow y$. if NO, then we know $D’(x,z) = D(x,z)$ and $D’(z,y) = D(z,y)$. If YES, then the new weight of path $x \\rightarrow y$ which equals $D(x,y) + (r-w_{i,j})$, is equal or less than the new weight $D(x,z) + D(z,y) + (r - w_{i,j})$. That follows by $D(x,y) \\leq D(x,z) + D(z,y)$ as the additional weight $r - w_{i,j}$ is added on both sides of the inequality. In this case we know $z$ won’t offer a less-weight path. So we can restrict our focus on vertices $z$ whose corresponding paths do not include edge $\\set{i,j}$.\n(For LaTeX issues we denote matrix $\\Pi$ by $P$)\nisEdgeInPath(edge {i,j}, path x -\u0026gt; y, predecessor P) if P(x,j) != i return False s = y while P(x,s) != x if P(x,s) == j return False return True Main() for x = 0 to n if P(x,j) = i for y = 0 to n minDistance = min{ edge (x,y) if exists, D(x,y) + (r - w_i,j) } minVertex = NULL isDistanceUpdated = False for z = 0 to n if isEdgeInPath( {i,j}, x -\u0026gt; y, P) OR z = x OR z = y continue to next iteration of z zDistance = D(x,z) + D(z,y) if (distance \u0026lt; minDistance) minDistance = zDistance minVertex = z isDistanceUpdated = True if isDistanceUpdated P\u0026#39;(x,y) = P(z,y) P\u0026#39;(x,z) = P(x,z) Complexity. $\\mathcal{O}(V^3)$\nb c In the same mannger matrices $M$ and $\\Pi$ are maintainces distances and predecessors, We maintain also matrix $W$ for the number of edges corresponding to $d_{i,j}$ in $M$. The algorithm then checks $W$ before updating a new solution whether its number of edges is at most $h$.\nComplexity. The overhead is constant over the original algorithm. In terms of parameters and $h$ is postponed.\nd The algorithm constructs a series of matrices $L^1, L^2, .., L^{n-1}$ where $L^m = \\left ( l_{ij}^m \\right )$, indicating shortest-paths of edges length at most $m$. The adapted algorithm terminates on $L^{h}$ and outputs it.\nComplexity. At most the complexity of the original algorithm.\ne Prob. 2 a We prove if there are two different minimum spanning trees, $T_a$ and $T_b$, Then we can construct a minimum spanning tree $T_c$ whose weight is less than either of them.\nWe define:\n$E_a = T_a(E)$ $E_b = T_b(E)$ $E_c = E_a \\cap E_b$ $E_{a-b} = E_a - E_b$ $E_{b-a} = E_b - E_a$ $E_{-c} = E_{a-b} \\cup E_{b-a}$ $e_{a}$, An edge in $E_a$ $e_{a0}$, An edge in $E_{a-b}$ Lemma. For an edge $e_{a0} = {x,y}$, $x$ and $y$ are connected by a path in $T_b$ which does not include edge $e_{a0}$. …","date":1686355200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1686355200,"objectID":"1b3bb257240308171dbd5b689cbee022","permalink":"https://mostafatouny.github.io/erik-alg-post/pset06/","publishdate":"2023-06-10T00:00:00Z","relpermalink":"/erik-alg-post/pset06/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 skipped in hope of professionally read while solving the exercises, and well-gain from lectures.\nEx. 2 To definte shortest-path weight function $\\delta$, which satisfies the triangle inequality, enabling the second property of $\\overline{w}$.","tags":null,"title":"Problem Set 06","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Materials Lecture Videos Book: Introduction to the Theory of Computation by Michael Sipser, 3rd ed. Problem Sets Problem Source Solution P. Set 01 Here PDF, HTML P. Set 02 Here PDF, HTML P. Set 03 Here PDF, HTML P. Set 04 Here PDF, HTML P. Set 05 Here PDF, HTML P. Set 06 Here PDF, HTML ","date":1684627200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1684627200,"objectID":"3c416d5f17ccab44992eae21334c374c","permalink":"https://mostafatouny.github.io/post/odonnell-undergrad-pset/","publishdate":"2023-05-21T00:00:00Z","relpermalink":"/post/odonnell-undergrad-pset/","section":"post","summary":"Self-studying undergrad computational complexity by Ryan O'Donnell.","tags":null,"title":"Odonnell's Undergrad Complexity","type":"post"},{"authors":null,"categories":null,"content":"Ex. 1 Here is a very illustrative example.\nThe procedure of encoding 3COL-UNARY to 3COL is as:\n(i) For each group of nodes labeled with some colour x, create two additional connected nodes x1 and x2, and connect each node coloured x to both of them. (ii) For each two distinct groups of colours x and y, connect some node from x with some node from y. When encoded input is run on 3COL,\nProcedure (i) ensures all nodes coloured x will have the same colour, even if that colour is not exactly x. Procedure (ii) ensures groups of labeled nodes will have different colours. Notably the colours outputted by 3COL may not match the given original labeled colours. Since colours are symmetric, i.e can be exchanged without tampering any required condition, an encoded graph $f(w)$ is accepted by 3COL if and only if graph $w$ is accepted by 3COL-UNARY.\nEx. 2 The goal is to show any language in NP can be polynomially reduced to IMPLICIT-4COL. The exponentiality of number of vertices of graph $G_C$ is the central key of testing all possible certificates and in turn determining whether a given w belongs to L language.\nBy cook-levin we know any NP language can be encoded in terms of SAT, and hence we can construct a corresponding circuit. Since the circuit’s input is of length 2n, we can think of it as partitioned into two n-length inputs. The first one is problem’s input (like a graph) and the second is a potential certificate (like a graph-route). The circuit evaluates whether a given input along some literals assignments (cirtificate) yields true (satisfiable).\nWe assume any language input is prefixed with 0, and any certificate input is prefixed with 1. If the circuit is given an invalid encoding it immediately outputs FALSE. In other words, If a circuit accepts some input pair, we are ensured the first one indicates a language input and the second indicates a possible certificate.\nNow we can think of graph $G_C$ as being partitioned into two groups; One for language inputs and the other for all possible certificates. If a vertix prefixed with 0 is connected to a vertix prefixed with 1, we can immediately conclude the language input is satisfiable, and otherwise it is unsatisfiable.\nGiven any language $L$ we can construct a corresponding $C$, and by IMPLICIT-4COL a corresponding $G_C$. For any input $w$ which we wish to check whether it belongs to $L$, We can see whether its encoded vertex in $G_C$ is connected to any other vertex.\nEx. 3 Notation.\nNAE-Constraint: $N_i = (x_1, x_2, x_3)$ $XOR(x_i, x_j) = (x_i \\vee x_j) \\wedge (\\neg x_i \\vee \\neg x_j)$ $GXOR(x_i, x_j, x_k) = XOR(x_i, x_j) \\wedge XOR(x_i, x_k) \\wedge XOR(x_j, x_k)$ Recall an $XOR$ means exactly one of two literals is true\nLemma. $GXOR$ is unsatisfiable.\nObserve each two $XORs$ intersect a literal $x_i$. So either:\n$x_i$ is False, and $x_j$ and $x_k$ are both True. Or $x_i$ is True, and $x_j$ and $x_k$ are both False But that contradicts the third $XOR$ stipulating exactly one of $x_j$ and $x_k$ is True.\nLemma. 5 clauses of $GXOR$ are satisfiable.\nFollowing the same line of reasoning of the previous lemma, It’s clear by ignoring some clause of the 6 clauses of $GXOR$, we can have $x_j$ and $x_k$ both assigned to the same boolean value.\nLemma. Equivalence of NAE constraint and 5 clauses of $GXOR$.\nIt is clear from the previous discussion that satisfying any 5 clauses of $GXOR$ is equivalent to satisfying an NAE constraint. Clearly, Not-All-Equal constraint is exactly the same as either two literals are True and one is False, or two literals are False and one is True.\nTheorem. An NAE-3SAT: $N_1, N_2, \\dots, N_r$ is equivalent to corresponding MAX-2SAT: $GXOR_1, GXOR_2, \\dots, GXOR_r$ with at least $5r$ clauses to be satisfied.\nIf MAX-2SAT is going to satisfy exactly 5 clauses of each $GXOR_i$, Then we are guaranteed of satisfying all $N_i$. In fact, This is the only feasible distribution of satisfied clauses. Otherwise all 6 clauses of some $GXOR_i$ must be satisfied, contradicting Lemma 2.\nOn the other hand, It’s clear if a given NAE-3SAT instance is satisfiable, then so is the corresponding MAX-2SAT.\nEx. 4 “not confident of the solution”\na As mentioned by the instructor we follow the verifier-based definition of NP. Our goal is to show $$\\begin{aligned} \u0026lt;M, x, 1^w, 1^t\u0026gt; \\in TS \\leftrightarrow \\exists u , s.t , S(\u0026lt;M, x, 1^w, 1^t\u0026gt;, u) , \\text{certifies} , \u0026lt;M, x, 1^w, 1^t\u0026gt; \\in TS\\end{aligned}$$\nBy $S$ we mean an algorithm which simulates $M$ on $(x, u)$, untill it accepts on $t$ steps.\nThe definition trivially concludes our intended goal. Note if $\u0026lt;M, x, 1^w, 1^t\u0026gt; , \\not\\in , TS$ then obviously there’s no any certificate $u$, such that any $M$ computes $(x, u)$ in time bounded by $t$.\n","date":1684627200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1684627200,"objectID":"0d6fb3fc8be3a5758f010f4c944ef4e6","permalink":"https://mostafatouny.github.io/odonnell-undergrad-post/pset06/","publishdate":"2023-05-21T00:00:00Z","relpermalink":"/odonnell-undergrad-post/pset06/","section":"odonnell-undergrad-post","summary":"Ex. 1 Here is a very illustrative example.\nThe procedure of encoding 3COL-UNARY to 3COL is as:\n(i) For each group of nodes labeled with some colour x, create two additional connected nodes x1 and x2, and connect each node coloured x to both of them.","tags":null,"title":"Problem Set 06,","type":"odonnell-undergrad-post"},{"authors":null,"categories":null,"content":"Problem. 1 Problem. 2 Problem. 3 By hypothesis, For any reals $x$ and $t$, We are given $| f(t) - f(x) | \\leq (t-x)^2$. Clearly: \\begin{aligned} \\frac{\\displaystyle{|f(t) - f(x)|}}{\\displaystyle{|t-x|}} \\leq\u0026amp; \\frac{\\displaystyle{(t-x)^2}}{\\displaystyle{|t-x|}} \\\\ \\left | \\frac{\\displaystyle{f(t) - f(x)}}{\\displaystyle{t-x}} \\right | \\leq\u0026amp; |t- x| \\end{aligned} But $\\lim_{t \\rightarrow x} |t-x| = 0$ which concludes $\\lim_{t \\rightarrow x} \\left | \\frac{\\displaystyle{f(t)-f(x)}}{\\displaystyle{t-x}} \\right | \\leq 0$. Since the absolute value is always equal or greater than 0, We get also $\\lim_{t \\rightarrow x} \\left | \\frac{\\displaystyle{f(t)-f(x)}}{\\displaystyle{t- x}} \\right | \\geq 0$. Therefore $f’(x) = 0$ for any real $x$.\n","date":1684022400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1684022400,"objectID":"0ee05a557dec464b28040019e0d3860d","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset07/","publishdate":"2023-05-14T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset07/","section":"mit-analysis1c-post","summary":"Problem. 1 Problem. 2 Problem. 3 By hypothesis, For any reals $x$ and $t$, We are given $| f(t) - f(x) | \\leq (t-x)^2$. Clearly: \\begin{aligned} \\frac{\\displaystyle{|f(t) - f(x)|}}{\\displaystyle{|t-x|}} \\leq\u0026 \\frac{\\displaystyle{(t-x)^2}}{\\displaystyle{|t-x|}} \\\\ \\left | \\frac{\\displaystyle{f(t) - f(x)}}{\\displaystyle{t-x}} \\right | \\leq\u0026 |t- x| \\end{aligned} But $\\lim_{t \\rightarrow x} |t-x| = 0$ which concludes $\\lim_{t \\rightarrow x} \\left | \\frac{\\displaystyle{f(t)-f(x)}}{\\displaystyle{t-x}} \\right | \\leq 0$.","tags":null,"title":"Problem Set 07","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 Definition. coll, $p[coll]$\nWe denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed $k_1 \\neq k_2$, and by $p[coll]$ the probability of that event happening.\nDefinition. ${f_{coll-i,j}}$\nWe denote all functions with a collision on $i, j \\in U$ by ${f_{coll-i,j}}$\nNote. It’s explicitly assumed\\\n(i) The given hash family $\\mathcal{H}$ contains all possible functions $f:U \\rightarrow B$.\n(ii) for any fixed $i$ and $j$, $f(i), f(j) \\in {0, \\dots, |B|-1}$ are independently and randomly assigned.\nWe are not aware whether these properties are part of a hash’s family definition.\nLemma. For a family of functions $\\mathcal{H}$ whose functions are defined on $f:U \\rightarrow B$, $p[coll] = \\frac{\\displaystyle{1}}{\\displaystyle{|B|}}$\nFor a fixed $k \\in B$, $|{f_{coll-i,j} | f(i)=f(j)=k }| = |B|^{|U|-2}$ To see why, Think of $f(k_i)$ and $f(k_j)$ as a fixed determined values; As a deferred choice, how many choices we have for $f$, for the remaining of $|U|-2$ elements?\nConsidering all $x_i \\in {0, \\dots, |B|-1}$ for $f(k_i) = x_i = f(k_j)$, $|{f_{coll-i,j}}| = |B|^{|U|-2} + \\dots + |B|^{|U|-2} = |B| \\cdot |B|^{|U|-2} = |B|^{|U|-1}$.\nFinally, $\\frac{\\displaystyle{|{f_{coll-i,j}}|}}{\\displaystyle{|\\mathcal{H}|}} = \\frac{\\displaystyle{|B|^{|U|-1}}}{\\displaystyle{|B|^{|U|}}} = \\frac{\\displaystyle{1}}{\\displaystyle{|B|}}$. The result is concluded, recalling a function is drawn randomly from $\\mathcal{H}$.\nCorollarly. If $p[coll] \\leq \\epsilon$, Then $\\epsilon \\geq \\frac{\\displaystyle{1}}{\\displaystyle{|B|}}$.\nTheorem. If $p[coll] \\leq \\epsilon$, Then $\\epsilon \\geq \\frac{\\displaystyle{1}}{\\displaystyle{|B|}} - \\frac{\\displaystyle{1}}{\\displaystyle{U}}$. Note $\\epsilon \\geq \\frac{\\displaystyle{1}}{\\displaystyle{|B|}} - \\frac{\\displaystyle{1}}{\\displaystyle{U}}$ is equivalent to $|B| |U| \\epsilon + |B| \\geq |U|$ by trivial algebraic operations. It immediately follows from lemma 4, $|B| |U| \\epsilon + |B| \\geq |B| |U| \\frac{\\displaystyle{1}}{\\displaystyle{|B|}} = |U|+|B| \\geq |U|$, since $|B| \u0026gt; 0$.\nEx. 3 Done.\nEx. 4 Fact. Trees’ Keys\nKeys of the tree are keyed on low endpoints. i.e nodes on the left subtree have low endpoints less than the root’s low endpoint and nodes on the right subtree have greater low endpoints.\nDefinition. Goodness\nBy an optimal-interval we mean an overlapping one with the lowest low endpoint. We say some interval is better when its low endpoint is strictly lower.\nLemma. No better-interval on the right subtree.\nIf any search algorithm terminated upon finding an overlapping interval $x$, Then for any other overlapping interval on the right subtree, Its low endpoint is going to be at least equal to $x$’s low endpoint. That due to Fact 1.\nObservation. Possible better-intervals on the left subtree.\nFor node $x$ whose interval overlaps with the queried interval $i$, The possible existince of a better-interval on the left subtree is justified by verifying $x.left.max$ to be at least $i.low$, and Fact 1.\nCorollary. If $x.left.max$ is less than queried $i.low$, Then the found overlapping interval in $x$ is the optimal.\nTinkering Search Algorithm. The previous discussion suggests a simple modification to solve our problem. The algorithm maintains a variable $bestInterval$, Updating it whenever a better overlapping interval is found. If the algorithm found an interval, and $x.left.max$ is less than $i.low$, It terminates. If $x.left.max$ were at least $i.low$, It steps to left subtree.\nINTERVAL-SEARCH(T, i) bestIntervalNode = nil x = T.root while x != T.nil if i overlaps with x.int and x.int is better than bestIntervalNode bestIntervalNode = x if x.left != T:nil and x.left.max \u0026gt;= i.low x = x.left else if bestIntervalNode == nil x = x.right else return bestIntervalNode return bestIntervalNode Ex. 5 Done.\nEx. 6 In Memoized-Cut-Rod, Initalize a new binary array $c[0..n-1]$ where $c[i]=1$ if there’s a cut at the ith possible cut position. In Memoized-Cut-Rod-Aux, While computing the maximum $q$ in $i$’s loop, store $i_0$ value which corresponds to the maximum $q$. Then set $c[i_0]=1$.\nEx. 7 Postponed.\nEx. 8 Definition. Less-order Sequence\nA sequence A is less-order than sequence B if A is less in terms of the lexicographical order. For example, A C B is less-order than A D A.\nRemark. Misleading Equal Character\nConsider sequences A = 1 9 2 5 1 3 4 and B = 1 9 2 6 1 3 4. On A2 = 1 9 and B2 = 1 9, We have a subsequence 1 9. But since 9 is a huge number we can’t append subsequence 2 3 4. In fact the optimal subsequence of A and B is 1 2 3 4. Our algorithm must prefer less-order subsequences as they enable better chances of a longer subsequence.\nApproach. Same but tinkered\nFollowing exactly the same formulation and solution mentioned in CLRS but with a simple tinkering:\nA new character appended to a subsequence must be monotonically increasing. Otherwise the subsequence is passed as it is without appending the …","date":1683417600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1683417600,"objectID":"be2fa82c8ce8f452aa5484195afd9db6","permalink":"https://mostafatouny.github.io/erik-alg-post/pset05/","publishdate":"2023-05-07T00:00:00Z","relpermalink":"/erik-alg-post/pset05/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 Definition. coll, $p[coll]$\nWe denote by coll the collision event of $f(k_1) = f(k_2)$ for fixed $k_1 \\neq k_2$, and by $p[coll]$ the probability of that event happening.","tags":null,"title":"Problem Set 05","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Ex. 0 Naively we guess any transformation $f$ of Boolean formulas preserves the property of satisfiability. Hence it would always be the case $$ \\begin{aligned} w \\not\\in \\textit{UNSAT} \\leftrightarrow f(w) \\in \\textit{SAT} \\end{aligned} $$\nEx. 1 Since the questions is about factor $a$ we can ignore constants. $n^r + {(n^l)}^b = n^{r+lb}$. So $a = r+lb$.\nEx. 2 following NTM simulation by DTM, partition states into H1 and H2 subsets, and apply the same procedure on each. now the combination of delta1 and delta2 reaches all possible states of NTM.\nFirst. sipser-NTM can be viewed as a sequence of states, Each of which, is a subset of a deterministic TM’s states. A state of binary-NTM can be viewed as a subset of exactly two states from a deterministic TM. Since there are no restrictions on the number of elements of sipser-NTM’s subset, binary-NTM can be seen as a special case of it.\nSecond. Recall the proof idea of a deterministic TM simulating a non-deterministic TM, whereby a determinstic state encodes/resembles a non-determinstic subset of states. Following the same idea, partition $Q = Q_1 \\cup Q_2$ and define $Q_1’ = P(Q_1)$ and $Q_2’ = P(Q_2)$. Here $P(Q_i)$ means the set of all subsets of states $Q_i$. Let $\\delta_1$ and $\\delta_2$ be responsible of $Q_1’$ and $Q_2’$, respectively. Observe any state of $P(Q)$ can be constructed by some $x \\cup y$ where $x \\in Q_1’$ and $y \\in Q_2’$. Therefore, Any configuration sequence of sipser-TM can be encoded/represented by some configuration sequence of binary-TM.\nEx. 3 The proof is shown by constructing a non-deterministic exponential-time algorithm for solving IMPLICIT-4COL.\nGiven a circuit $C$, Construct its graph $G_C$ by enumerating all possible $2^n$ inputs of $i$ and all $2^n$ inputs of $j$, Computing $C(i,j)$, for $i \\neq j$. The complexity is $2^n \\times 2^n = 2^{n+1}$; Exponential.\nCheck whether the graph $G_C$ is 4-colorable. For each vertex of the graph, non-determinstically brute-force all the possible 4 colours. Since there are $2^n$ vertices, The complexity is NEXP.\nClearly the total complexity of a subroutine of EXP followed by a subroutine of NEXP, is NEXP.\nEx. 4 We construct the reduction function through a polynomial algorithm. Let C_colorable and C_uncolorable be some fixed 4-colorable and 4-uncolorable graphs.\nL-to-3COL(w) check whether w is in L by the given polynomial algorithm if w belongs to L output C_colorable otherwise output C_uncolorable Observe our mapping necessarily satisfies $$ w \\in L \\leftrightarrow \\textit{L-to-3COL(w)} \\in 3COL $$\n","date":1682812800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682812800,"objectID":"1d5d3fc21d22d0d833df29549742b04d","permalink":"https://mostafatouny.github.io/odonnell-undergrad-post/pset05/","publishdate":"2023-04-30T00:00:00Z","relpermalink":"/odonnell-undergrad-post/pset05/","section":"odonnell-undergrad-post","summary":"Ex. 0 Naively we guess any transformation $f$ of Boolean formulas preserves the property of satisfiability. Hence it would always be the case $$ \\begin{aligned} w \\not\\in \\textit{UNSAT} \\leftrightarrow f(w) \\in \\textit{SAT} \\end{aligned} $$","tags":null,"title":"Problem Set 05","type":"odonnell-undergrad-post"},{"authors":null,"categories":null,"content":"Problem. 1 Problem. 2 Problem. 3 The first part is solved by a trivial set-theoretic operations. The second is postponed.\nObserve if $x \\in f(\\overline{E})$ then $x = f(p)$ for some $p \\in \\overline{E}$. To prove $x \\in \\overline{f(E)}$ it suffices to have $f(p) \\not\\in f(E)$. By contrapositive, It follows by the given $p \\not\\in E$.\nNote the proof is independent of continuity.\nProblem. 4 Observation. In case of a continuous function $f$ at point $p$, If we have a sequence ${x_i}$ converging to $p$ and ${f(x_i)}$ converges to $a$ then $a = f(p)$.\nTheorem. Our approach is proving the definition of a closed-set is satisfied. Namely, If $p$ is a limit point of of $Z(f)$ then $p \\in Z(f)$. Fix $p$ and suppose $\\forall \\epsilon \u0026gt; 0$ $\\exists x \\in Z(f)$ such that $d(x,p) \u0026lt; \\epsilon$. We can construct a sequence $x_i$ arbitrarily close to $p$ where $f(x_i) = 0$. By the above observation it must be the case $f(p) = 0$, and hence $p \\in Z(f)$.\n","date":1682208000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682208000,"objectID":"494403fb6bd02dfecbbcaf59617f408b","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset06/","publishdate":"2023-04-23T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset06/","section":"mit-analysis1c-post","summary":"Problem. 1 Problem. 2 Problem. 3 The first part is solved by a trivial set-theoretic operations. The second is postponed.\nObserve if $x \\in f(\\overline{E})$ then $x = f(p)$ for some $p \\in \\overline{E}$.","tags":null,"title":"Problem Set 06","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 he amortized cost of n operations is upper-bounded by \\begin{align*} \u0026amp;n + \\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i \\\\ \u0026amp;= n + \\ddfrac{2(1-2^{\\lfloor \\lg n \\rfloor})}{1-2} \\\\ \u0026amp;\\leq n + \\ddfrac{2(1-n)}{-1} \\\\ \u0026amp;= n - 2 + 2n \\\\ \u0026amp;= 3n - 2 \\\\ \u0026amp;= \\mathcal{O}(n) \\end{align*}\nSo the amortized cost of one operation is $\\ddfrac{\\mathcal{O}(n)}{n} = \\mathcal{O}(1).$\nEx. 3 We assign the following amortized costs:\nith operation isn’t a power of 2 $\\rightarrow$ 4 ith operation is an exact power of 2 $\\rightarrow$ 0 We prove for each operation $2^i$, There’s a sufficient balance for it. For $i \\geq 2$, There are exactly $2^{i-1} - 1$ non-power operations before $2^i$ and after $2^{i-1}$. It sufficies to show $4(2^{i-1}-1) \\geq 2^i$ which can trivially be proven by induction.\nObserve amortized cost $= 4n - 4 \\lfloor \\lg n \\rfloor \\geq n - \\lfloor \\lg n \\rfloor + 2n \\geq n - \\lfloor \\lg n \\rfloor + \\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i$ = actual cost. Note by the geometric series $\\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i = \\ddfrac{2(1-2^{\\lfloor \\lg n \\rfloor})}{1-2} \\leq 2n$\nThe amortized cost of n operations is $\\mathcal{O}(n)$, and hence the amortzed cost of one operation is $\\mathcal{O}(1)$.\nEx. 4 Define potential function $\\Phi(D_i)$ to be the number of 1-bits in the binary representation of i. Note $\\Phi(D_0) = 0$ and $\\Phi(D_i) \\geq 0$ which suffices to show the validity of our definition.\nObserve the amortized cost of operations: \\begin{align} c_i’ = \\begin{array}{lr} i+1-i=1, \u0026amp; \\text{i is a power of 2} \\\\ 1+1=2, \u0026amp; \\text{if i is odd} \\\\ 1 + \\Delta \\Phi(D_i) \\leq 1, \u0026amp; \\text{if i is even but not power of 2} \\end{array} \\end{align}\nWhen i is odd, it has one additional 1-bit over even i-1, due to the right most bit being only flipped from 0 to 1. When i is even, then i-1 is odd, and at least one 1-bit is flipped to zero and at most one 0-bit is flipped to 1. So $\\Delta \\Phi(D_i) \\leq 0$. When $i = 2^k$, a power of two, then $\\Phi(D_i) = 1$ because there’s exactly one 1-bit. Also, i-1 contains exactly i 1-bits, So $\\Phi(D_{i-1}) = i$.\nIn all cases, the amortized cost of a single operation is $\\mathcal{O}(1)$.\nEx. 5 Done\nEx. 6 Each element of the array needs to be compared with the pivot only once to conclude whether it is greater or less than it.\nEx. 7 Since $0 \u0026lt; \\alpha \\leq \\ddfrac{1}{2}$ branching $1 - \\alpha$ is greater or equal than branching $\\alpha$. Maximum depth is $\\lg_{\\ddfrac{1}{1-\\alpha}} n = \\ddfrac{\\lg n}{\\lg \\ddfrac{1}{1-\\alpha}} = \\ddfrac{\\lg n}{\\lg 1 - \\lg (1-\\alpha)}$ and minimum depth is $\\lg_{\\ddfrac{1}{\\alpha}} n = \\ddfrac{\\lg n}{\\lg \\ddfrac{1}{\\alpha}} = \\ddfrac{\\lg n}{\\lg 1 - \\lg\\alpha}$. The fact $\\lg 1 = 0$ concludes the intended result.\nEx. 8 Failed to solve.\nThrough the same reasoning of establishing upper-bound, we derived a lower-bound of $\\Omega(\\lg n)$.\nProblems Prob. 1 The obvious FIFO queue satisfies the problem’s requirements. Think of a list of numbers where integers are enqueued to left and dequeued from right.\nA list.min variable is maintained whenever a new integer is added, Checking whether it’s less than list.min and updating accordingly. Whenever dequeue is called, we check whether removed integer is equal to list.min. If not, no additional work is done. If yes, we know by the distinctness of integers, that the list.min is removed from the list, and hence it must be updated. A linear scan is implemented to update list.min.\nWhile the worst-case analysis of dequeue is linear, That worst case of removing the list.min happens in proportion to the number of integers enqueued, which in turn allows us to conclude an amortized cost of $\\mathcal{O}(1)$.\nThe central key idea is to loop only once on each element, from left to right, storing in each element.min, The minimum integer of the sub-array starting from left-most to current element’s position. Now whenever we need to loop again to find list.min, We do not loop on already-visited elements, but only on newly inserted elements. We assign list.min to be the minimum integer of that new sub-array. Observe we can conclude the minimum of the whole list, from list.min and right-most element.min stored in visited elements. It’s basically min(list.min, element.min).\nWe continue in this manner untill all visited elements are dequeued. Then we are left with a list of totally no visited elements, and list.min is the minimum integer of the whole list.\na element contains int holding the integer value and min storing the minimum element of a sub-array. list contains min indicating the minimum integer of the unstamped sub-array. That, besides elements aforementioned. b minAllElements Loop from left to right on the whole list, Maintaining the minimum of the sub-array from left-most to currently visiting element, and storing it in each element.min. Reset list.min to $+\\infty$ so that it considers only newly inserted elements. Enqueue Append element to the left …","date":1681603200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1681603200,"objectID":"5d39c118804dd2ca49ad5c39d019cce2","permalink":"https://mostafatouny.github.io/erik-alg-post/pset04/","publishdate":"2023-04-16T00:00:00Z","relpermalink":"/erik-alg-post/pset04/","section":"erik-alg-post","summary":"$\\newcommand{\\ddfrac}[2]{\\frac{\\displaystyle{#1}}{\\displaystyle{#2}}}$\nExercises Ex. 1 Done.\nEx. 2 he amortized cost of n operations is upper-bounded by \\begin{align*} \u0026n + \\sum_{i=1}^{\\lfloor \\lg n \\rfloor} 2^i \\\\ \u0026= n + \\ddfrac{2(1-2^{\\lfloor \\lg n \\rfloor})}{1-2} \\\\ \u0026\\leq n + \\ddfrac{2(1-n)}{-1} \\\\ \u0026= n - 2 + 2n \\\\ \u0026= 3n - 2 \\\\ \u0026= \\mathcal{O}(n) \\end{align*}","tags":null,"title":"Problem Set 04","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Ex. 1 a Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It’s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.\nb Obviously a verifier is some input $x_0$ such that $C_1(x_0) \\neq C_2(x_0)$. It’s easy to compute both circuits and check their unequal output.\nEx. 2 Intuitively, If a problem has some varifier, Then we can brute-force all possible verifiers. Observe we can choose the greatest branching factor $c_{max}$ so that time is upper-bounded by $c_{max}^{poly(n)}$. Alternatively, Our argument might be seen through the perspective of a tree of an $NP$ problem, where $poly(n)$ is the time required of the longest path of the tree.\nI am not aware of any more rigorous proof.\nEx. 3 a For clarity and brevity we list all cases:\nunit clause $x_i$ delete any clause containing $x_i$ delete $\\neg x_i$ from any clase unit clause $\\neg x_i$ delete any clause containing $\\neg x_i$ delete $x_i$ from any clause Due to symmetry we mention only the case of unit clause $x_i$.\nWe prove the new propagated $C’$ is satisfiable if and only if the given $C$ is satisfiable.\n$(\\leftarrow)$ Necessarily $x_i = True$. Hence any clause containing $x_i$ is immediately evaluated to $True$ as well. Since $\\neg x_i = False$ one of the remaining units of the clause containing $\\neg x_i$ must be evaluated to $True$.\n$(\\rightarrow)$ Following the same reasoning, Since $x_i = True$, adding any clause containig $x_i$ is still going to be true regardless of other units boolean values. Also adding $\\neg x_i = False$ to any clause evaluated to $True$ won’t change the whole clause’s boolean value.\nb We give a constructive polynomial-time algorithm. We follow the hint mentioned in the problem statement.\nFor case (ii), Loop on clauses, and for each:\nIf no negative literal is assigned any value, Conveniently pick-up the first negative literal $\\neg x_k$ and assign $x_k = False$. If a negative literal $\\neg x_k$ is assigned $x_k = False$, Continue to the next clause. Observe we only assign $x_k = False$. As a result, the case of a negative literal $\\neg x_k$ assigned $x_k = True$ won’t ever be encountered.\nFor case (i), Keep applying the process of $a$, Until all unit-clauses are eliminated. If any clause is empty, It’s concluded the given $C$ is unsatisfiable. Now we know every clause contains at least two literals, Including a negative literal. Case (i) is now reduced to case (ii).\nEx. 4 a Clearly, If literals $x_i$ which are assigned to $1$ are even, Then they can re-arranged as pairs, Each yielding $0$, and in turn all pairs yield $0$. Observe for an even number, $2k$ mod 2 = 0.\nSimilarly, if literals $x_i$ which are assigned to $1$ are odd, Then we obtain 1 XOR 0 = 1, by separating one literal from the remaining even literals.\nb We define summation as, $\\epsilon_1 + \\epsilon_2 = c_1 + c_2 + 1$ where are $\\sum_i x_{1i} = c_1$ mod $2$ and $\\sum_i x_{2i} = c_2$ mod $2$. Note if $c_1 = c_2 = 1$, Then $c_1 + c_2 + 1 = 1 + 1 + 1 = 1$ mod $2$ and hence $(\\epsilon_1 + \\epsilon_2)(x) = 1$. On the other hand, If $1 + c_2 + 1 = 1$ mod $2$, Then $c_2 = -1 = 1$ mod $2$. Hence, $\\epsilon_2(x) = 1$.\nc Consider $k_1$ to be the number of equations in which $x_{11}$ appreas.\n\\begin{align*} \\text{Update $x_{11}$ to} \\hspace{10mm} { \\begin{array}{lr} 0, \u0026amp;\\text{if $k_1$ is even} \\\\ k_1 x_{11}, \u0026amp;\\text{if $k_1$ is odd} \\end{array} } \\end{align*}\nRemark in case $k_1 = 2m$ is even, Then $\\sum_{j=1}^{2m} x_{1j} = 2(m x_{11}) = 0$ mod $2$. That, Regardless of $x_{1j}$ values, as we would always obtain an even number.\nNow consider the whole system of equations by summing all equations as we defined in b. In case $k_1$ is even, Then we know $x_{1j}$ evaluates to zero, and hence their removal from the system doesn’t affect. In case $k_1$ is odd, Then $k_1 x_{11}$ is exactly equivalent to $x_{11} + x_{12} + \\dots + x_{1n}$. Think of redistributing $x_{1j}$ to reconstruct the original equations before the transformation, which clarifies why the new system is equivalent to the original one.\nd If at any stage $0 = 1$ is concluded, Then no matter what $x$ is inputted, The system won’t be satisfied. Since the transformed system is equivalent to the original one, It’s trivial why the original system is unsatisfiable.\nObserve in modulus 2, the only possible evaluation outcomes are $0$ or $1$. So if $LHS \\neq RHS$, then necessarily we get $0 = 1$. If we don’t get $0 = 1$, then all equations’ evaluations are satisfied.\nObserve also if $k_{ii} x_{ii} = c , mod , 2$ then by our definitions we know $k_{ii}$ is odd. It follows there’s exactly one unique solution for $x_ii$.\nAs the instructor hinted, back-substitution can be applied recursively to compute $x_{nn}$, $x_{n-1 , n-1}$, .., $x_{11}$ where once $x_{ii}$ is computed, For all the above equations, Their number of variables are reduced by one. Only one literal $x_{i-1 , i-1}$ is left for the next equation.\nAs a …","date":1680998400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680998400,"objectID":"1abd555ec5f6fc9206ceaa8924803d40","permalink":"https://mostafatouny.github.io/odonnell-undergrad-post/pset04/","publishdate":"2023-04-09T00:00:00Z","relpermalink":"/odonnell-undergrad-post/pset04/","section":"odonnell-undergrad-post","summary":"Ex. 1 a Obviously the problem has a polynomial-time verifier by specifying the range of the subsequence common among all $w_i$. It’s easy to loop on that range $k$, Checking whether corresponding positions of all $w_j$ are the same.","tags":null,"title":"Problem Set 04","type":"odonnell-undergrad-post"},{"authors":null,"categories":null,"content":"Problem. 1 Lemma. If $x_{n+1} \\leq \\lambda x_n$, where $0 \\leq \\lambda \u0026lt; 1$, Then the sequence ${x_n}$ gets artbitrarily small\nClearly $x_{1+k} \\leq \\lambda^k x_1$, by substituting successive terms in the inequality. Given $\\epsilon \u0026gt; 0$ we can reach $\\lambda^k x \\leq \\epsilon$ by setting $k \\geq \\log_\\lambda y/x$.\nFix any x in the metric space, Then construct the following sequence: ${f^n(x)} = f^0(x), f^1(x), f^2(x), \\dots$. We prove it is cauchy. Consider $d(f^n(x),f^m(x))$ of some tail where $n \u0026lt; m$. By the triangular inequality, We know the distance is upper-bounded by $d(f^n(x),f^{n+1}(x)) + d(f^{n+1}(x),f^{n+2}(x)) + \\dots + d(f^{m-1}(x),f^m(x)) \\leq (m-n+1) \\lambda^{n-1} d(f^1(x),f^2(x))$. By Lemma 1 and substituting distances by a sequence ${x_n}$ our intended result is concluded.\nGiven $X$ is complete we know our sequence ${f^n(x)}$ converges. Call it $q$. We show it converges also to $f(q)$, and by the uniqueness of limits, The main theorem of $f(x) = x$ for some $x$ is concluded. Observe $d(f^{n+1}(x),f(q)) \\leq d(f^n(x),q)$, but the right hand side of the inequality is arbitrarily small. QED.\nNote. This problem was solved with assistance by wonderful friends. The main key idea of using the uniqueness of limits was given by them. See the following chat:\nProblem. 2 Suppose $(x_k)$ converges to $q$. Let $\\epsilon \u0026gt; 0$ be arbitrary. We already have $N_0$ where for any $k \\geq N_0$ $x_k - q \u0026lt; \\epsilon$. For a given permuted sequence $(x_{g(k)})$, We now show there’s $N_1$ where for any $n \\geq N_1$, $x’_{n} - q \u0026lt; \\epsilon$.\nObserve $x_1, \\dots, x_{N_0-1}$ are finite. Consider indices $g(1), \\dots, g(N_0-1)$ and take the maximum. Call it $g_{max}(N_0-1)$. Clearly for any index $i$ greater than it, we know $x_i’$ is not equal to any one of $x_1, \\dots, x_{N_0-1}$. So it is contained in the trail $x_{N_0}, x_{N_0+1}, \\dots$. Thus, $x_i’ - q \u0026lt; \\epsilon$ for any $i \u0026gt; g_{max}(N_0-1)$.\nIt is not true if we dropped the assumption that $g$ is one-to-one. A counter example is a permutation function whose range is exactly one element of $\\mathcal{N}$.\nProblem. 3 The is exactly the same as theorem 3.4 in Rudin’s page 50.\nProblem. 4 Postponed\n","date":1680393600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680393600,"objectID":"0d7c0beb07b08c58cff72ce465b4911c","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset04/","publishdate":"2023-04-02T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset04/","section":"mit-analysis1c-post","summary":"Problem. 1 Lemma. If $x_{n+1} \\leq \\lambda x_n$, where $0 \\leq \\lambda \u003c 1$, Then the sequence ${x_n}$ gets artbitrarily small\nClearly $x_{1+k} \\leq \\lambda^k x_1$, by substituting successive terms in the inequality.","tags":null,"title":"Problem Set 04","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"Exercises Ex. 3.1 Done.\nEx. 3.2 Skipped; I don’t understand the problem.\nEx. 2 Skipped; I don’t understand the problem.\nProblems Prob. 3.1 psuedo-code changes; compare new complexity with old one\na Psuedo-code. No Changes at all. Note the sequence $2^9 \\rightarrow 2^3 \\rightarrow 2^1$, up to the base case of $u = 2$ as before, starting with total data of size $2^9 = 512$.\nComplexity. Similarly $\\mathcal{O}(\\lg \\lg u)$. We follow the same reasoning on the master method but on the case of a cluster size $u^{1/3}$. We gain $\\lg_b a = \\lg_3 1 = 0$, or more accurately $\\lg_b a = \\lg_{4/3} 1 = 0$, whereby $\\lceil m/3 \\rceil \\leq 3m/4$. Thus, Reaching exactly the same complexity.\nb vEB-TREE-MIN No Changes.\nvEB-TREE-MAX No Changes.\nvEB-TREE-MEMBER(V, x) No Changes.\nvEB-TREE-SUCCESSOR(V, x) No Changes.\nvEB-TREE-PREDOCESSOR(V, x) Symmetric, Skipped.\nvEB-EMPTY-TREE-INSERT(V, x) No Changes.\nIntuitively, We apply the same trick of swapping V.min. Complexity is the same, as we only re-ordered a constant-complexity code block.\nvEB-TREE-INSERT(V, x) if V.min == NIL vEB-EMPTY-TREE-INSERT(V, x) else if x \u0026lt; V.min exchange x with V.min if x \u0026gt; V.max exchange x with V.max if V.u \u0026gt; 2 if vEB-TREE-MINIMUM(V.cluster[high(x)] == NIL vEB-TREE-INSERT(V.summary, high(x)) vEB-EMPTY-TREE-INSERT(V.cluster[high(x)], low.x) else vEB-TREE-INSERT(V.cluster[high(x)], low.x) Intuitively, We apply the same trick of updating V.min and assigning x to a new value before the delete operation. In this case, there’s no need to check for summary as V.max will be already set to either V.min or the suitable index value. Complexity is the same for exactly the same reasoning\nvEB-TREE-DELETE(V, x) . .. else if x == V.min first-cluster = vEB-TREE-MINIMUM(V.summary) x = index(first-cluster, vEB-TREE-MINIMUM(V.cluster[first-cluster])) V.min = x elseif x == V.max last-cluster = vEB-TREE-MAXIMUM(V.summary) x = index(high(x), vEB-TREE-MAXIMUM(V.cluster[high(x)])) V.max = x vEB-TREE-DELETE(V.cluster[high(x)], low(x)) if vEB-TREE-MINIMUM(V.cluster[high(x)]) == NIL vEB-TREE-DELETE(V.summary, high.x) Algorithm’s correctness are not proved. We relied only on our intuition. Not comfortable the new modification is simpler and yet offers the same complexity; Why not illustrated in this way by the author?\n","date":1679184000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679184000,"objectID":"6e72f47b92a5d7fb8efed8ae68e70a07","permalink":"https://mostafatouny.github.io/erik-alg-post/pset03/","publishdate":"2023-03-19T00:00:00Z","relpermalink":"/erik-alg-post/pset03/","section":"erik-alg-post","summary":"Exercises Ex. 3.1 Done.\nEx. 3.2 Skipped; I don’t understand the problem.\nEx. 2 Skipped; I don’t understand the problem.\nProblems Prob. 3.1 psuedo-code changes; compare new complexity with old one","tags":null,"title":"Problem Set 03","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Ex. 1 The proof is already mentioned in sipser. We can easily reprove it using the diagonalization argument.\nEx. 2 Enumerate all the two choices of a node colored in (red or blue), or colored in yellow, on all nodes. Consider the two subgraphs separately; If the yellow subgraph contains any edge reject the instance. Check if the other subgraph is 2-colorable. Only if yes, accept as the whole graph as 3-colorable.\nThe complexity is justified, Since checking 2-colorable is polynomially solved, on each instance of all two choices, on all nodes.\nClearly, If the graph is 3-colorable, then the algorithm catches the instance corresponding to nodes correctly colored in yellow and others in either red or blue. On the other hand, If the algorithm found a solution, Then the graph is 3-colorable, As the solution can easily be constructed.\nEx. 3 Observe the cases of $x_i$ and $x_j$ of the binary relation $x_i \\leq x_j$.\n(1) Both are assigned by a given condition (2) One is assigned 0 and the other is equal or less (2) One is assigned 1 and the other is equal or greater (3) Both are not assigned (4) One is assigned 0 and the other is equal or greater (4) One is assigned 1 and the other is equal or less We give an algorithm that costs exactly one linear scan. Scan all binary relations $x_i \\leq x_j$, If\nof type (1), Check whether assigned values conform to the relation, and reject satisfiability if not. of type (2), Assign 0 and 1, Correspondingly, So that values conform to the relation. If a conflict is faced, where there’s a prior assignment, that precludes from assigning what satisfies the relation, reject. To see why the algorithm is correct, We construct a valid solution, Given what the algorithm had already verified. For case\n(3), assign $x_i = 0$ and $x_j$ arbitrarily $0$ or $1$ (4), assign arbitrarily $0$ or $1$ Clearly, cases $3$ and $4$, do not conflict with cases $1$ or $2$, Since the algorithm has already checked and assigned what satisfies cases $1$ and $2$. Case $3$ doesn’t conflict with $4$, As $4$ allows any assignment. Remaining $x_i$ with no conditions at all, can be arbitrarily assigned as well.\nEx. 4 From hw02-2-b, We are given a procedure haltMachine(T, f(n)) that produces a Turing Machine $T_{f(n)}$, which is exactly the same as machine $T$, but halts within $f(n)$ steps; If $T$ terminates within $f(n)$, Then $T_{f(n)}$ produces the same output; Otherwise rejects. Note $T_{f(n)}$ is multi-tab, whereby at each step simulated of $T$, a counter on a specific tab is increased by one.\na For any polynomial time machine $T$, We know it runs in time at most $kn^k$. $T_{kn^k}$ simulates $T$ upto $kn^k$ steps which suffices to ensure it produces the same output.\nb Since $T$ is polynomial, and at each step, counter increase is polynomial, The total resulting complexity is polynomial.\nc Observe to construct $T_{f(n)}$, We would need to integrate a sub-routine that increases counter by one, where every state points to it after completing its one-step operation. For every state $q_i$, we create a new state $q_{i-counter}$ such that\n$q_i$ transitions to $q_{i-counter}$, instead of $q_r$ as in $T$, exactly after one-step. $q_{i-counter}$ transitions to $q_r$, what $q_i$ transitions to in $T$, after completing all steps required for increasing counter by one. Clearly the transformation is linear in time.\nd Alice can basically check for the sub-routine that increases counter by one, and check for the state that terminates the machine, upon the counter reaching $f(n)$.\nThe algorithm of checking polynomiality is clear, if the reader is convinced by the procedure of transformation.\n","date":1678665600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1678665600,"objectID":"50226d4eaf5452ec36764ebdbd6f08e1","permalink":"https://mostafatouny.github.io/odonnell-undergrad-post/pset03/","publishdate":"2023-03-13T00:00:00Z","relpermalink":"/odonnell-undergrad-post/pset03/","section":"odonnell-undergrad-post","summary":"Ex. 1 The proof is already mentioned in sipser. We can easily reprove it using the diagonalization argument.\nEx. 2 Enumerate all the two choices of a node colored in (red or blue), or colored in yellow, on all nodes.","tags":null,"title":"Problem Set 03","type":"odonnell-undergrad-post"},{"authors":null,"categories":null,"content":"Problem. 1 The required conditions follow naturally as:\n$d’(x,x) = \\sqrt{d(x,x)} = \\sqrt{0} = 0$. If $d(x,y) \u0026gt; 0$ then $d’(x,y) \u0026gt; 0$ as the square root of non-zero is non-zero. Otherwise $0^2 = 0$ contradicting the fact $d’(x,y) \u0026gt; 0$. $d’(x,y) = \\sqrt{d(x,y)} = \\sqrt{d(y,x)} = d’(y,x)$. $d’(x,y) = \\sqrt{d(x,y)} \\leq \\sqrt{d(x,r) + d(r,y)} \\leq \\sqrt{d(x,r)} + \\sqrt{d(r,y)} = d’(x,r) + d’(r,y)$. For an arbitrary open-set of $d$, $\\set{ y | d(x,y) \u0026lt; r }$ there is an equivalent open-set of $d’$, $\\set{ y | d’(x,y) \u0026lt; \\sqrt{r} }$. For an arbitrary open-set of $d’$, $\\set{ y | d’(x,y) \u0026lt; r }$, there is an equivalent open-set of $d$, $\\set{ y | d(x,y) \u0026lt; r^2 }$.\nNote. Some good friends assisted in solving this problem.\nProblem. 2 Lemma. For any point $p$ in $R$, There exists a smallest element in the set $\\set{ q \\in E | q \u0026gt; p }$\nAssume to the contrary that no smallest element exists. Then as the set is bounded below, the infimum exists, and is a limit point. That contradicts our hypothesis of no limit points in $E$.\nCorollary. $E \\cap R^+ = E^+$ has a smallest element\nBy the above lemma set $p = 0$.\nCorollarly. Given $x_i \\in E^+$ there exists a smallest element among $E^+ \\cap \\set{y | y \u0026gt; x_i}$\nBy the above lemma set $p = x_i$.\nNow we have a counting scheme on $E^+$. What is remaining now is to prove every element in $E$ will be hit eventually. The following lemma suffices.\nLemma. there are finitely many elements in $E \\cap [- |a| , |a|]$\nAssuming the contrary for the sake of contradiction, We get infinite elements in $E \\cap [ -|a|, |a| ]$. Those are present in both $E$ and $[ -|a|, |a| ]$ by definition. Since $[ -|a|, |a| ]$ is compact we know any infinite subset has a limit point (Theorem 2.41, p. 40 in baby-rudin). But then we get a limit point in E. Contradiction.\nSimilarly we can prove $E \\cap R^- = E^-$ is countable, and hence $E$ is countable also.\nNote. 1 Professor Peng Zhou hinted the solution approach\nNote. 2 Through chatting with good friends a cleaner alternative proof can be made as, \u0026#34;Because E has no limit points it is closed. Assume E is uncountable. Then there is an integer n such that intersection with [n,n+1] is also uncountable. This intersection is closed and bounded, thus compact. So we can take a sequence inside this intersection and it will have a convergent subsequence contradicting the assumption on limit points\u0026#34;\nProblem. 3 Assume for the sake of contradiction that the process does not stop after a finite number of steps. Then the sequence $x_i$ is infinite. Consider the infinite subset $\\set{x_i} = S_\\delta$; By hypothesis it has a limit point in $X$, Call it $p$. So for neighbourhood $N_{\\delta/4}(p)$, some point $q_1 \\neq p$ is in that neighbourhood. Let $r_1 = d(p, q_1)$. Consider neighbourhood $N_{r_1/2}(p)$; Clearly $q_1$ is not in it. So there is a point $q_2 \\neq q_1$ in it. We have now distinct points $q_1,q_2 \\in S$ such that $d(p,q_1) \\leq \\delta/4$ and $d(p,q_2) \\leq \\delta/4$. It follows $d(q_1,q_2) \\leq d(q_1,p) + d(p,q_2) \\leq \\delta/4 + \\delta/4 = \\delta/2$. But the construction of sequence $x_i$ stipulates every pair of points is of distance at least $\\delta$. Contradiction.\nIt follows by the above lemma, that for any point $p$ in $X$, the distance between it and some $x_i$ of $S$ is strictly less than $\\delta$. Therefore $p$ is covered by $N_\\delta{x_i}$.\nNow we prove $X$ is separable. We know for each $\\delta = 1/n$, The corresponding subset $S_{1/n}$ is finite. Clearly $\\cup_n S_{1/n} = S$ is countably infinite. It suffices to show, For a point $p \\in X - S$, it can get arbitrarily close to points of $S$. Consider arbitrary $\\delta \u0026gt; 0$ and its corresponding neighbourhood $N_\\delta(p)$.\nTake $\\delta’ = \\delta/2$, and $n’ \u0026gt; 0$ such that $1/n’ \u0026lt; \\delta’$. Consider $N_{\\delta’}(p)$. There are two cases.\nCase 1: A point $q \\in S_{1/n’}$ is in $N_{\\delta’}(p)$, Then it is also in $N_{\\delta}(p)$.\nCase 2: No point $q \\in S_{1/n’}$ is in $N_{\\delta’}(p)$. Then for any $z \\in N_{\\delta’}(p)$ some point $q \\in S_{1/n’}$ exists such that $d(z,q) \u0026lt; 1/n’$. It follows $\\delta = \\delta/2 + \\delta/2 \u0026gt; \\delta’ + 1/n’ \u0026gt; d(p,z) + d(z,q) \\geq d(p,q)$. In other words, $q \\in N_{\\delta}(p)$.\nProblem. 4 Failed to solve.\nPartial idea: Establish a sequence $x, f^1(x), f^2(x), f^3(x), \\dots$. If I proved it is finite then I am done, as it is necessarily the case $f^k(x) = f^{k+1}(x)$. If it is infinite then a limit point of it exists as $X$ is a compact set.\n","date":1677974400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1677974400,"objectID":"098beef6c50a93dc521f102504e23154","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset03/","publishdate":"2023-03-05T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset03/","section":"mit-analysis1c-post","summary":"Problem. 1 The required conditions follow naturally as:\n$d’(x,x) = \\sqrt{d(x,x)} = \\sqrt{0} = 0$. If $d(x,y) \u003e 0$ then $d’(x,y) \u003e 0$ as the square root of non-zero is non-zero.","tags":null,"title":"Problem Set 03","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"Ex. 2-1 done\nEx. 2-2 For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.\nDouble-degree form\n$A(x) = -10 + x + 0x^2 + 0x^3$\n$B(x) = 3 - 6x + 0x^2 + 0x^3$\nComputing A(x) on sample\nRecursive-FFT(-10, 1, 0, 0) n = 4 w_4 = e^{2 pi i / 4} w = w_4^0 = 1 a[even] = (-10, 0) a[odd] = (1, 0) y[even] = Recursive-FFT(-10, 0) = (-10, -10) y[odd] = Recursive-FFT(1, 0) = (1, 1) for k=0 to 1 k=0 y_0 = (-10) + (1)(1) = -9 y_2 = (-10) - (1)(1) = -11 w = w_4^1 k=1 y_1 = (-10) + (e^{1 2 pi i / 4})(1) = -10+i y_3 = (-10) - (e^{1 2 pi i / 4})(1) = -10-i w = w_4^2 return (-9, -10+i, -11, -10-i) Recursive-FFT(-10, 0) n = 2 w_2 = e^{2 pi i / 2} w = w_2^0 = 1 a[even] = (-10) a[odd] = (0) y[even] = Recursive-FFT(-10) = (-10) // base case y[odd] = Recursive-FFT(0) = (0) for k=0 to 0 k=0 y_0 = (-10) + w (0) = -10 y_1 = (-10) - w (0) = -10 w = w_2^1 return (-10, -10) Recursive-FFT(1, 0) n = 2 w_2 = e^{2 pi i / 2} w = w_2^0 = 1 a[even] = (1) a[odd] = (0) y[even] = Recursive-FFT(1) = (1) // base case y[odd] = Recursive-FFT(0) = (0) for k=0 to 0 k=0 y_0 = 1 + w(0) = 1 y_1 = 1 - w(0) = 1 w = w_2^1 return (1, 1) Computing B(x) on sample\nSimilarly, we get $y=(-3, 3-6i, 9, 3+6i)$\nComputing C(x) on sample, By multiplying corresponding sample points of A and B\n$y = ((-9)(-3), (-10+i)(3-6i), (-11)(9), (-10-i)(3+6i)) = (27, -24+63i, -99, -24-63i)$\nInterpolating C(x) coefficients\nRecursive-IFFT(27, -24+63i, -99, -24-63i) n = 4 w_4^-1 = e^{-1 i 2 pi / 4} w = w_4^0 = 1 y[even] = (27, -99) y[odd] = (-24+63i, -24-63i) a[even] = Recursive-IFFT(27, -99) = (-72, 126) a[odd] = Recursive-IFFT(-24+63i, -24-63i) = (-48, 126i) for k=0 to 1 k=0 y_0 = (-72) + (1)(-48) = -120 y_2 = (-72) - (1)(-48) = -24 w = w_4^-1 k=1 y_1 = (126) + (e^{-1 i 2 pi / 4})(126i) = 252 y_3 = (126) - (e^{-1 i 2 pi / 4})(126i) = 0 w = w_4^-2 return (-120, 252, -24, 0) Recursive-IFFT(27, -99) n = 2 w_2^-1 = e^{-1 i 2 pi / 2} w = w_2^0 = 1 y[even] = (27) y[odd] (-99) a[even] = Recursive-IFFT(27) = (27) // base case a[odd] = Recursive-IFFT(-99) = (-99) for k=0 to 0 k=0 y_0 = 27 + (1)(-99) = -72 y_1 = 27 - (1)(-99) = 126 w = w_2^-1 return (-72, 126) Recursive-IFFT(-24+63i, -24-63i) n = 2 w_2^-1 = e^{-1 i 2 pi /2} w = w_2^0 = 1 y[even] = (-24+63i) y[odd] = (-24-63i) a[even] = Recursive-IFFT(-24+63i) = (-24+63i) a[odd] = Recursive-IFFT(-24-63i) = (-24-63i) for k=0 to 0 k=0 y_0 = (-24+63i) + (1)(-24-63i) = -48 y_1 = (-24+63i) - (1)(-24-63i) = 126i return (-48, 126i) Hence, Final answer is (-120, 252, -24, 0)/4 = (-30, 63, -6, 0), and resulting polynomial is $C(x) = -30 + 63x - 6x^2$.\nEx. 2-3 Modifying Recursive-FFT, by switching $a$ and $y$, replacing $w_n$ by $w_n^{-1}$. Finally, result vector is divided by $n$.\nRecursive-IFFT(y) n = y.length if n == 1 return y w_n^-1 = e^{-1 2 pi i / n} w = 1 y[even] = (y_0, y_2, ..., y_n-2}) y[odd] = (y_1, y_3, ..., y_n-1) a[even] = Recursive-IFFT(y[even]) a[odd] = Recursive-IFFT(y[odd]) for k=0 to n/2 - 1 a_k = a[even]_k + w a[odd]_k a_k+(n/2) = a[even]_k - w a[odd]_k w = w w_n^-1 return a a = a/n Ex. 2-4 done\nEx. 2-5 Create operation accounts for number of pointers filled. Insert operations are modified to allow up to $2t-1$ keys in case of internal node, and up to $(2t-1) + (2t) = 4t-1$ keys in case of leaf node. That, by basically modifying the if condition. Also, insertion in place of pointers happens by checking whether a leaf have $2t-1$ keys.\nNote we haven’t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.\nB-TREE-CREATE(T) x = ALLOCATE-NODE() x.leaf = TRUE x.n = 0 x.n\u0026#39; = 0 // number of pointers to children filled DISK-WRITE(x) T.root = x B-TREE-INSERT(T,k) r = T.root if (r.n == 2t-1 and not r.leaf) or (r.n == 4t-1 and r.leaf) // different cases for internal and leaf nodes s = ALLOCATE-NODE() T.root = s s.leaf = FALSE s.n = 0 s.c1 = r B-TREE-SPLIT-CHILD(s,1) B-TREE-INSERT-NONFULL(s,k) else B-TREE-INSERT-NONFULL(r,k) B-TREE-INSERT-NONFULL(x,k) if x.leaf i = x.n + x.n\u0026#39; // sum of both keys and pointers while i \u0026gt;= x.n + 1 and k \u0026lt; x.c_(i-x.n) x.c_(i-x.n+1) = x.c_(i-x.n) i = i-1 while i \u0026gt;= 1 and k \u0026lt; x.key_i x.key_i+1 = x.key_i i = i-1 if i \u0026gt;= x.n + 1 x.c_i+1 = k x.n\u0026#39; = x.n\u0026#39; + 1 else x.key_i+1 = k x.n = x.n + 1 DISK-WRITE(x) else i = x.n while i\u0026gt;=1 and k\u0026lt;x.key_i i = i-1 i = i+1 DISK-READ(x,c_i) if (x.c_i).n == 2t-1 // note this is an internal node B-TREE-SPLIT-CHILD(x,i) if k \u0026gt; x.key_i i = i+1 B-TREE-INSERT-NONFULL(x.c_i, k) Ex. 3-2 We implement the prescription described in p.500.\nNote we haven’t rigorously proven our modification is correct; We rely on our intuition to write main parts of new the operations.\nB-TREE-DELETE(x, k) // check if k is in node x i = x.n while i\u0026gt;=1 and x.key_i != k i = i-1 // k is found if i\u0026gt;=1 // x is a leaf node if x.leaf key_i = NULL x.n = x.n - 1 x.shiftKeysAndPointers() // for brevity we ignore implementing this subroutine // x is an internal node else y = x.c_i // child preceeding k z = x.c_i+1 // child …","date":1677369600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1677369600,"objectID":"51fa5db15e829fb93ba198c6c6243bb7","permalink":"https://mostafatouny.github.io/erik-alg-post/pset02/","publishdate":"2023-02-26T00:00:00Z","relpermalink":"/erik-alg-post/pset02/","section":"erik-alg-post","summary":"Ex. 2-1 done\nEx. 2-2 For our own convenience of avoiding tedious computations, we multiply $A(x) = -10 + x$ with $B(x) = 3 - 6x$.\nDouble-degree form\n$A(x) = -10 + x + 0x^2 + 0x^3$","tags":null,"title":"Problem Set 02","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Ex. 1 The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn’t recognizable by any turing machine.\nLet’s prove uncountability of unary languages. Observe the set $\\Sigma^*$ equals \\begin{align*} \u0026amp;\\epsilon \\quad \u0026amp;s_1\\\\ \u0026amp;1 \\quad \u0026amp;s_2\\\\ \u0026amp;11 \\quad \u0026amp;s_3\\\\ \u0026amp;111 \\quad \u0026amp;s_4\\\\ \u0026amp;.. \\quad \u0026amp;..\\\\ \\end{align*} Any unary language is a subset of $\\Sigma^*$, and can be re-interpreted as an infinite binary sequence, where string $s_i$ is in the language if and only if sequence bit $b_i$ is 1. Clearly, there is bijective map from unary languages to infinite binary sequences. But the set of infinite binary sequences is uncountably infinite.\nEx. 2 a Assume the input is conveniently given as *w#, and machine’s tape-1 is on first character of w (or on # if $w$ is $\\epsilon$). Assume also tape-2 is given with * character at its beginning, and tape-2 head is one-step right to it. For brevity we ignore such implementation details.\nInitial state is $q_{\\text{rightDouble1}}$. We assume characters of the alphabet have corresponding other marked characters. e.g 1 has 1’. We indicate by saying marking a character, replacing it with its corresponding marked one.\n$q_{\\text{leftUntill*}}:$ move tape-1 left untill * is read, Then move right and $q_{\\text{rightDouble1}}$.\n$q_{\\text{rightDouble1}}:$ sequentially, move tape-1 right once, write 1 in tape-2 twice in two sequential slots, untill # is read by tape-1 then move left and $q_{\\text{isAllMarked}}$.\n$q_{\\text{isAllMarked}}:$ if a marked character or * is read by tape-1, then $q_{\\text{unmarkInput}}$. if a non-marked character is read, then $q_{\\text{leftUntill*}}$.\n$q_{\\text{unmarkInput}}:$ move tape-1 left replacing marked characters by their unmarked counterparts untill * is read, then move right and $q_{\\text{lefttape2}}$.\n$q_{\\text{lefttape2}}:$ move tape-2 left untill * is read, then move right.\nIt is easy to transform tape-1 to be exactly w and tape-2 to be popped out of * at its left-most. We ignore these implementation details.\nb From a, We know there’s a 2-tape turing machine $T$ that can prepare tape-2 with string $1^{2|w|^2}$. We wish to think of this string as a counter of number of steps taken by the machine. It is possible for it to be augmented, to simulate machine $M$, while ticking tape-2, Accepting if $M$ accepts and tape-2 isn’t completely ticked, and rejecting otherwise. The 1-tape turing machine $M$ can be constructed by simulating $T$.\n$T$ runs in polynomial time, since preparing tape-2 is upperbounded by $n^2$, and ticking tape-2 while simulating $M$ doesn’t cost any more steps. The simulation of $T$ by $M’$ is polynomially overheaded by $T$, and hence $M’$ is polynomially upperbounded.\nEx. 3 a Let $T$ be the turing machine recognizing $L$. It is possible to construct another turing machine $T’$ whose accept and reject states are swapped. So, $w \\in L$ iff $T$ accepts $w$ iff $T’$ rejects $w$ iff $w \\not\\in L^c$.\nThe number of steps made by $T’$ is exactly the same as $T$, and hence of a polynomial complexity.\nb Let $T_1$ and $T_2$ be two turing machines recognizing $L_1$ and $L_2$ respectively. It is possible to construct a new turing machine $T$ that simulates $T_1$ and memorizes its result, Then instead of termination, simulates $T_2$ on the same input and memorizes its result also. It is easy for $T$ to be designed such that it accepts input $w$ if and only if either the simulation of $T_1$ or $T_1$ accepted.\nThe complexity of $T$ is $\\mathcal{O}(poly(n)) + \\mathcal{O}(poly(n)) + C = \\mathcal{O}(poly(n))$\nc Similarly to b, but $T$ accepts input $w$ if and only if both the simulations of $T_1$ and $T_2$ are accepted.\nd Similarly to b, but $T$ accepts input $w$ if and only if at least two out of the three simulations of $T_1$, $T_2$, and $T_3$ accepts.\ne Let $T$ be the turing machine recognizing $L$. For any $m \\in \\mathcal{N}$, It is possible to construct a m-tape turing machine $T_m$, that simulates $T$ on $w_i$ on the ith tape. Hence, complexity of $T_m$ is $\\sum_{i=0}^m \\mathcal{O}(poly(|w_i|)) = \\mathcal{O}(poly(|w|))$. Clearly the processing required to copy substrings $w_i$ on ith tapes is polynomial also, Hence $T_m$’s established upperbound remains the same.\nEx. 4 Any turing machine needs at least a linear scan of cost $n$, to behave in number of steps, as a function of $n$. In other words, number of steps $T$, must be $T(n) \\geq n$, so that $T = f(n)$ for some function $f$. Since $T$ is upperbounded by $\\sqrt{n} = \\mathcal{o}(n)$, $T(n) \\neq f(n)$ for any $f$. In other words, $T$ isn’t based on input size $n$. Therefore, must be a constant.\nThe intuition is very strong that a turing machine cannot behave in relation to $n$ if its memory doesn’t contain $n$’s value; I am not aware of a more rigorous proof.\nAs final note, For any constant $C$, we can always find some $n$, such that $C \\sqrt{n} \u0026lt; n$. Hence, always guaranteeing the turing machine can’t read its whole …","date":1676851200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1676851200,"objectID":"754bd20c5dc7d340eb26578bb1a93534","permalink":"https://mostafatouny.github.io/odonnell-undergrad-post/pset02/","publishdate":"2023-02-20T00:00:00Z","relpermalink":"/odonnell-undergrad-post/pset02/","section":"odonnell-undergrad-post","summary":"Ex. 1 The set of all unary languages is uncountably infinite but the set of all Turing machines is countably infinite, Hence some unary language isn’t recognizable by any turing machine.","tags":null,"title":"Problem Set 02","type":"odonnell-undergrad-post"},{"authors":null,"categories":null,"content":"Problem. 1 We prove each axiom as listed by Rudin in page 5.\nA1 $(a_0+a_1) + \\sqrt{2} (b_0+b_1) \\in \\mathcal{Q}(\\sqrt{2})$, As $(a_0+a_1), (b_0+b_1) \\in \\mathcal{Q}$.\nA2 Follows immediately by properties of $\\mathcal{Q}$.\nA3 Follows immediately by properties of $\\mathcal{Q}$.\nA4 $0_{\\mathcal{Q}(2)}$ here is the number $0 + \\sqrt{2} ; 0 = 0_{\\mathcal{R}}$.\nA5 For an $x_{\\mathcal{Q}(2)}$, $-x_{\\mathcal{Q}(2)} = -a + \\sqrt{2} (-b)$.\nM1 The product is $(a_0a_1 + 2b_0 b_1) + \\sqrt{2} (a_0 b_1 + a_1 b_0)$, Where the formed $a$ and $b$ are in $\\mathcal{Q}$.\nM2 Following properties of $\\mathcal{Q}$, The product we formed in M1 is the same in cases of $xy$ and $yx$.\nM3 Following properties of $\\mathcal{Q}$, The product we formed in M1 is the same in cases of $(xy)z$ and $x(yz)$.\nM4 $1_{\\mathcal{Q}(\\sqrt{2})}$ here is $1_{\\mathcal{R}} \\neq 0_{\\mathcal{R}} = 0_{\\mathcal{Q}(2)}$.\nM5 If $x_{\\mathcal{Q}(\\sqrt{2})} \\neq 0_{\\mathcal{Q}(2)} = 0 + \\sqrt{2} \\cdot 0$, Then we know either $a \\neq 0$ or $b \\neq 0$, and hence $x_{\\mathcal{Q}(\\sqrt{2})} = a + b \\sqrt{2} \\neq 0$. Define $x_{\\mathcal{Q}(\\sqrt{2})}^{-1} = \\frac{\\displaystyle{1}}{\\displaystyle{a + b \\sqrt{2}}}$. What is remaining is to show $\\frac{\\displaystyle{1}}{\\displaystyle{a + b \\sqrt{2}}} \\in \\mathcal{Q}(2)$ by a multiplication by its conjugate. Observe: $$ \\begin{aligned} \u0026amp;\\frac{\\displaystyle{1}}{\\displaystyle{a + b \\sqrt{2}}} \\\\ = \u0026amp;\\frac{\\displaystyle{1}}{\\displaystyle{a + b \\sqrt{2}}} \\cdot \\frac{\\displaystyle{a - b \\sqrt{2}}}{\\displaystyle{a - b \\sqrt{2}}} \\\\ = \u0026amp;\\frac{\\displaystyle{a - b \\sqrt{2}}}{\\displaystyle{a^2 + 2 b^2}} = (\\frac{\\displaystyle{a}}{\\displaystyle{a^2 + 2b^2}}) + (\\frac{\\displaystyle{-b}}{\\displaystyle{a^2 + 2b^2}}) \\sqrt{2} \\end{aligned} $$ And clearly $(\\frac{\\displaystyle{a}}{\\displaystyle{a^2 + 2b^2}}), (\\frac{\\displaystyle{-b}}{\\displaystyle{a^2 + 2b^2}}) \\in \\mathcal{Q}$.\nD Follows by a trivial algebra.\nProblem. 2 Let’s look at the special case of $z = (x, 0)$. Then for any $r \u0026gt; 0$, there exists a complex number $w = (x/r, 0)$, such that $rw = z$.\nFrom now on we focus on $z = (x, y)$ assuming $y \\neq 0$. Before proceeding, we develop a central lemma.\nLemma. For any complex number $w = (a, b)$, $|w| = 1 \\leftrightarrow a^2 + b^2 = 1$.\nFollows immediately by setting $w \\cdot \\overline{w} = 1$ and multiplying.\nLemma. Given any $x$ and $y \\neq 0$, Finding reals $r, a, b$ such that $r \\cdot a = x$, $r \\cdot b = y$ satisfies $z = (x, y) = r \\cdot (a, b) = rw$\nFollows immediately by a trivial algebra.\nTheorem. Main Problem\nNow we combine Lemma 1 and Lemma 2 to satisfy both requirements by forming a combined system of equations, Given any $z = (x, y)$ where $y \\neq 0$. $$ \\begin{aligned} r \\cdot a \u0026amp;= x \\\\ r \\cdot b \u0026amp;= y \\\\ a^2 + b^2 \u0026amp;= 1 \\end{aligned} $$ It can be solved by substitution where: $$ \\begin{aligned} a \u0026amp;= \\sqrt{1 - b^2} \\\\ r \u0026amp;= y/b ;;; \\text{valid as b isn’t zero} \\\\ 3/b \\cdot \\sqrt{1-b^2} \u0026amp;= x \\end{aligned} $$ Note $b \\neq 0$ lest $r \\cdot b = r \\cdot 0 = 0 = y$, Contradicting our assumption.\nThe system uniquely determines the values $$ \\begin{aligned} b \u0026amp;= \\frac{\\displaystyle{3}}{\\displaystyle{\\sqrt{x^2 + 9}}} \\\\ r \u0026amp;= \\frac{\\displaystyle{y}}{\\displaystyle{3}} \\cdot \\sqrt{x^2 + 9} \\\\ a \u0026amp;= \\sqrt{1 - \\frac{\\displaystyle{9}}{\\displaystyle{x^2+9}}} \\end{aligned} $$\nProblem. 3 a We show if arbitrary $p \\in E^o$ then $p$ is an interior of $E^o$. By definition $p$ is an interior of $E$. So $N_{r_0}(p) \\subset E$ for some $r_0 \u0026gt; 0$. Let $r_1 = r_0/2$ and $h = r_0 - r_1$. It suffices to show $N_{r_1}(p) \\subset E^o$.\nConsider $N_h(p’)$ for any $p’ \\in N_{r_1}(p)$. Through the picture it is clear this new neighbourhood shall be bounded by $N_{r_0}(p)$ and hence falls completely within $E$. That shows $p’ \\in E^o$ and in turn completes our proof.\nIn greater details, Observe $\\forall q \\in N_h(p’)$, $d(q, p) \\leq d(q, p’) + d(p’, p) \u0026lt; h + r_1 = (r_0 - r_1) + r_1 = r_0$, and hence $q \\in N_{r_0}(p) \\subset E$.\nb $(\\leftarrow)$ Trivial by a.\n$(\\rightarrow)$ Trivially $E^o \\subset E$. By hypothesis, The definition of open $E$ immediately concludes $E \\subset E^o$.\nc Any $p \\in G$ is an interior point of $G$ by definition. So there is a neighbourhood $N_{r_0}(p) \\subset G$ for some $r_0 \u0026gt; 0$. But we know $G \\subset E$, So $N_{r_0}(p) \\subset E$, $p$ is an interior point of $E$.\ne I guess Yes. We struggled with a formal proof though.\nProblem. 4 Definition. Given a point $p \\in X$, Define $V_p = { x \u0026gt; p ; | ; [p,x] \\subset X } \\cup { x \u0026lt; p ; | ; [x, p] \\subset X }$.\\\nRemark. $V_p$ constitutes a largest segment $(a,b)$, Given $X$ is an open-set.\nAssuming $V_p = (a, b]$ derives an immediate contradiction as $b$ won’t be an interior point of $X$.\nA more rigorous argument for showing $V_p$ is a segment can be made by constructing a segment $(inf , V_p, sup , V_p)$ but for brevity we ignore it.\nLemma. Given an open-set $X$ and some $V_p \\subset X$, For any $q \\neq p$, Either $V_p = V_q$ or $V_p \\cap V_q = \\phi$.\nEasily proven by considering the …","date":1676160000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1676160000,"objectID":"2b17daf2afb6f78559f45f47343728a0","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset02/","publishdate":"2023-02-12T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset02/","section":"mit-analysis1c-post","summary":"Problem. 1 We prove each axiom as listed by Rudin in page 5.\nA1 $(a_0+a_1) + \\sqrt{2} (b_0+b_1) \\in \\mathcal{Q}(\\sqrt{2})$, As $(a_0+a_1), (b_0+b_1) \\in \\mathcal{Q}$.\nA2 Follows immediately by properties of $\\mathcal{Q}$.","tags":null,"title":"Problem Set 02","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"Problem 1 a Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges ${v_1,v_2}, {v_2, v_3}$.\nThe optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.\nb Since the graph is given to be acyclic, Each neighbour of the graph’s root, Constitutes a root of a subtree of its own, with no vertex being shared among any two subtrees.\nWe design a divide and conquer algorithm where solutions to smaller subtrees can be merged for a larger subtree.\nThe base case is when the tree has only one vertex, where optimal subset contains only that vertex.\nAssuming we know solutions of subtrees, How can we merge? Observe the optimal subset of the whole tree either\n(1) Contains the root (2) Does not contain the root For (2), The optimal solution of the whole tree is the sum of all subtrees’ optimal profits. Assume for the sake of contradiction that is not the case. Then there are different selections of vertices with overall greater profit. Since by definition we are assuming whole tree’s root to be excluded, We know the different selection is in one of the subtrees. We know also that subtree’s new total profit is greater, But that contradicts the fact subtree is given optimal in the first place to us.\nFor (1), The tricky part comes into play. If we restricted our scope only on a subtree, Then It is possible to choose a non-optimal subset, As it shall be better integrated with the bigger subtree, Yielding a greater profit for the bigger subtree. Particularly, That happens if we had to include the new root in the subset and exclude the subtree’s root.\nThe key is to have this information given to us by the main algorithm. So we let it compute also optimal possible profit under the assumption root is excluded. With that in our pocket we can compute the whole big tree’s optimal subset profit assuming it contains the root.\nSpecifically, we loop on each given subtree and check whether root is included in optimal solution. If not, we add subtree’s optimal profit. If yes we add subtree’s optimal profit under the assumption subtree’s root is excluded.\nFinally we select the maximum of case (1) and case (2) and return it as the optimal solution.\nObserve we have covered all possible cases by such a simple trick!\nExample\nBlack number indicates profit of a single vertex, and red is the optimal profit of the vertice’s subtree.\nFor the first tree, Case (1) is maximum, and for the second tree, Case (2) is maximum.\nPsuedo Code\noptimalSubsetProfit(tree G, tree root v_r) if (verticesNumber(G) == 1) return (True, profit(v_r), profit(v_r)) subtreesOptimalData = () for v_neig in neighbours(v_r) out = (optimalProfit, isRootIncluded, profitRootExcluded) = optimalSubsetProfit(subtree(v_neig), v_neih) subtreesOptimalData.append(out) profitRootExcluded = 0 for subtree in subtreesOptimalData profitRootExluded += subtree.optimalProfit profitRootIncluded = 0 for subtree in subtreesOptimalData if subtree.isRootIncluded == False profitRootIncluded += subtree.optimalProfit else profitRootIncluded += subtree.profitRootExcluded optimalProfit = max{profitRootExcluded, profitRootIncluded} if optimalProfit == profitRootExcluded isRootIncluded = False else isRootIncluded = True return optimalProfit, isRootIncluded, profitRootExcluded c Remark Stacks’ Vertices Number\nThink of the given graph as levels of stacks from bottom to top as shown below\nObserve the number of vertices in a stack must be equal or greater than the number of its preceeding stack. So, final stack of leafs is the greatest.\nAlgorithm Description\nInclude the bottom most stack in solution subset. Ignore the preceeding stack, As every vertex in it is adjacent to some selected vertex. Include the preceeding stack in solution subset. Continue similarly untill the whole graph is covered By alternatively toggling between stacks, We ensure no adjacent vertices are selected, and we greedily select stacks of greatest number of vertices.\nPsuedo-code\noptimalProfit(tree G, tree\u0026#39;s root v_r) if G contains one vertex return (True, 1) someChildIncluded = False count = 0 for each child v_chi of root v_r (isChildIncluded, childCount) = optimalProfit(G, v_chi) if isChildIncluded == True someChildIncluded = True increase count by childCount if someChildIncluded == True return (False, count) else return (True, count+1) Complexity $\\log(n)$\nProof\nTheorem. 1 If the given graph contains only vertices with at most 1 child branch, Then the algorithm selects maximum number of valid vertices.\nNote the graph in this case is basically a linear path of vertices. Note also the number of vertices selected by our algorithm is $\\lceil \\frac{n}{2} \\rceil$, where $n$ is the number of graph’s vertices.\nIt sufficies to show if there is any selection subset $U$ whose number of vertices is more than $\\lceil \\frac{n}{2} \\rceil$, Then $U$ contains two adjacent vertices. The proof is by induction on $n$.\nThe base case of $n = …","date":1675555200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1675555200,"objectID":"64ed70fd0d18eaf8d350adbb935302a0","permalink":"https://mostafatouny.github.io/erik-alg-post/pset01/","publishdate":"2023-02-05T00:00:00Z","relpermalink":"/erik-alg-post/pset01/","section":"erik-alg-post","summary":"Problem 1 a Consider a graph of vertices $v_1, v_2, v_3$, whose weights are correspondingly $10, 6, 6$, and connected by edges ${v_1,v_2}, {v_2, v_3}$.\nThe optimal subset is $v_2, v_3$ of profit sum equal to $6 + 6 = 12$, But the algorithm picks subset $v_1$ with profit $10$.","tags":null,"title":"Problem Set 01","type":"erik-alg-post"},{"authors":null,"categories":null,"content":"Ex. 1 skipped\nEx. 2 a As the recipe is deterministic, i.e generates only one output given the same input, The assignment is valid and the function is well-defined.\nFor injectivity, we prove the contrapositive; Namely, if $x_0 \\neq x_1 \\rightarrow f(x_0) \\neq f(x_1)$. Since, $x_0 + 1 \\neq x_1 + 1$, Their binary representation differs in either the number of bits or in some bit not matching. That unmatching bit cannot be the most significant bit as it’s always 1. Therefore, resulting strings, $f(x_0)$ and $f(x_1)$ are not the same.\nFor surjectivity, Pick-up any string $w \\in {0, 1}^*$ and reverse the recipe to obtain natural number $x$. Namely, add 1 as the most significant bit, interpret string as a binary number, convert to base 10, and finally subtract 1. Clearly $f(x) = w$.\nb Here’s a very illustrative example that achieves an encoding in $\\lg a + \\lg b$.\n(2, 5), converted to binary, (10, 101); add leading zeros so both have the same number of bits, (010, 101). Finally, Concatenate bit by bit, i.e add the first bit of the first number then first bit of the second then second bit of the first, ..etc, Yielding 011001.\nThe recipe can easily be rolled back.\nEx. 3 a Binary search on range (a, a+1, .., b-1, b), where at each step algorithm $D$ is queries on both the first and second halves of the array, Then recursively call the binary search on both halves.\nprimeFactor( X = array(a, a+1, .., b-1, b) ) if X.length == 1 if D(x) return X[0] return FALSE if X.length == 0 return FALSE halfIndex = floor(X.length/2) firstHalf = X[: halfIndex] secondHalf = X[halfIndex+1 :] if D(firstHalf) return primeFactor(firstHalf) if D(secondHalf) return primeFactor(secondHalf) return FALSE main( X = array (a, a+1, .., b-1, b) ) res = primeFactor(X) if res == FALSE print \u0026#39;no\u0026#39; else print \u0026#39;yes\u0026#39; Since $m \\geq$ length of $X$, Complexity is $O(\\lg m)$.\nb Solving decision $D$ by $f$. Compute $f(x) = y$ and check whether $y_i = b$.\ny = f(x) if y[i] == b return YES return FALSE Computing $f$ by $D$. on each bit $x_i$ of $x$, Call $D$ on string x, bit 0, and position i. if result is YES, let $y_i = 0$; if result is NO, let $y_i = 1$. assign $f(x)$ to $y$.\ny = [] for i in x.length res = D(x, 0, i) if res == YES y[i] = 0 else y[i] = 1 return y Ex. 4 a Trivially we can transform the input to the form *input#.\nInitially the machine is on state $q_0$.\n$q_0:$ move right until # is reached, then $q_1$.\n$q_1:$ move left until a non-# is reached, then $q_2$.\n$q_2:$ if * halt; if 0 print # and $q_3$; if 1 print $ and $q_4$.\n$q_3:$ move right until a blank space is reached, then print 0 and $q_5$.\n$q_4:$ move right until a blank space is reached, then print 1 and $q_5$.\n$q_5:$ move left until # is reached, then $q_1$.\nb skipped\nc Assume andrew id is ac12. f(ac12) = 10000110.\n*10000110# is our assumed input. on step 8, machine is on 0 and state $q_0$. On step 9, machine is on # and state $q_0$. On step 10, machine is on state $q_1$.\n","date":1674950400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1674950400,"objectID":"654741afc1684846096eb9a9065425b1","permalink":"https://mostafatouny.github.io/odonnell-undergrad-post/pset01/","publishdate":"2023-01-29T00:00:00Z","relpermalink":"/odonnell-undergrad-post/pset01/","section":"odonnell-undergrad-post","summary":"Ex. 1 skipped\nEx. 2 a As the recipe is deterministic, i.e generates only one output given the same input, The assignment is valid and the function is well-defined.\nFor injectivity, we prove the contrapositive; Namely, if $x_0 \\neq x_1 \\rightarrow f(x_0) \\neq f(x_1)$.","tags":null,"title":"Problem Set 01","type":"odonnell-undergrad-post"},{"authors":null,"categories":null,"content":"Problem 1 Definition. simplest-fraction\nWe call $\\frac{\\displaystyle{x}}{\\displaystyle{y}}$ a simplest-fraction when it is in its simplest form. i.e cannot be reduced by eliminating a common fraction.\nFact. If there are no common factors between $x$ and $y$, Then $\\frac{\\displaystyle{x}}{\\displaystyle{y}}$ is a simplest-fraction.\nLemma. If $\\frac{\\displaystyle{x}}{\\displaystyle{y}}$ is a simplest-fraction, Then so is $\\frac{\\displaystyle{x^2}}{\\displaystyle{y^2}}$\nObserve any common factor among the numerator and denominator is going to necessarily divide both $x$ and $y$.\nTheorem. Main Problem\nIt’s possible to set $\\sqrt{\\frac{\\displaystyle{m}}{\\displaystyle{n}}} = \\frac{\\displaystyle{a}}{\\displaystyle{b}}$ where $\\frac{\\displaystyle{a}}{\\displaystyle{b}}$ is a simplest-fraction. On $\\frac{\\displaystyle{m}}{\\displaystyle{n}} = \\frac{\\displaystyle{a^2}}{\\displaystyle{b^2}}$ It follows by fact 2 and lemma 3, Both $\\frac{\\displaystyle{m}}{\\displaystyle{n}}$ and $\\frac{\\displaystyle{a^2}}{\\displaystyle{b^2}}$ are simplest-fractions. By uniqueness of such forms, $m = a^2$ and $n = b^2$. QED\nProblem 2 Assume for the sake of contradiction, There’s an order \u0026lt; defined in the complex field, Which turns it into an ordered field.\nBy definition, It’s an ordered set also, and hence the following fact applies to it: For any $s, r \\in F$ exactly one of:\n$(i) , s=r$, $(ii) , s\u0026lt;r$, $(iii) , s\u0026gt;r$ is true. Particularly we have exactly one of the following cases to be true:\n(i) $\\sqrt{-1} = 0$\nThen $-1 = \\sqrt{-1} \\sqrt{-1} = 0 \\cdot 0 = 0$. A contradiction.\n(ii) $\\sqrt{-1} \u0026gt; 0$\nThen $-1 = \\sqrt{-1} \\sqrt{-1} \u0026gt; \\sqrt{-1} \\cdot 0 = 0$. Also $1 \u0026lt; 0$ and $\\sqrt{-1} = \\sqrt{-1} \\cdot 1 \u0026lt; \\sqrt{-1} \\cdot 0 = 0$. A contradiction.\n(iii) $\\sqrt{-1} \u0026lt; 0$\nThen $-1 = \\sqrt{-1} \\sqrt{-1} \u0026gt; \\sqrt{-1} \\cdot 0 = 0$. Also $1 \u0026lt; 0$ and $\\sqrt{-1} = \\sqrt{-1} \\cdot 1 \u0026gt; \\sqrt{-1} \\cdot 0 = 0$. A contradiction.\nProblem 3 The proof of complex numbers being an ordered set follows immediately by the obvious/natural properties of real numbers’ order and enumerating cases.\nA counter-example is given to the claim, that the orderd-set of complex numbers have the least-upper-bound property. Let $E = \\set {(1/x, y) \\mid x\u0026gt;1}$, which is clearly bounded by any element of the set $B = \\set {(1, y) \\mid y \\in \\mathcal{R}}$. But set $B$ has no least element.\nProblem 4 a $f(0) = f(0+0) = f(0) + f(0)$. Then $f(0) - f(0) = f(0) + f(0) - f(0)$, implying $0 = f(0)$.\n$f(1) = f(1 \\cdot 1) = f(1) \\cdot f(1)$. Let $x = f(1)$, Then $x = x^2$ which implies $x(x-1) = 0$, and finally either $x = 0$ or $x = 1$.\nb Lemma. $f(n) = n f(1)$\n$f(n) = f(n-1 + 1) = f(n-1) + f(1)$, implying $f(n) = f(0) + n \\cdot f(1)$.\nLemma. $f(n/m) = (n/m) f(1)$\n$f(n/m) = f(n \\cdot 1/m) = n \\cdot f(1/m) \\cdot f(1)$. But $f(1) = f(1/m + 1/m \\dots + 1/m) = f(1/m) + f(1/m) + \\dots + f(1/m) = m \\cdot f(1/m)$, which leads to $f(1/m) = f(1)/m$. Finally, Multiply both sides by $n$.\nCorollary. Main Problem\nThe final conclusion follows immediately by cases of $f(1)$ being equal to $0$ or $1$.\nc Lemma. $f(x) \\geq 0$ if $x \\geq 0$\nSince $x$ is a non-negative, we know $\\sqrt{n}$ exists. Observe $f(x) = f(\\sqrt{x} \\cdot \\sqrt{x}) = f(\\sqrt{x}) \\cdot f(\\sqrt{x})$. But any square cannot be a negative number.\nTheorem. Main Problem\nIf $x \u0026gt; y$, Then $x-y \u0026gt; 0$. By Lemma. 1, $f(x-y) \\geq 0$. But $f(x-y) = f(x) + f((-1) \\cdot y) = f(x) - f(y)$.\nNote. This problem had been solved by the aid of good friends. My original flawed solution is below.\nc (Flawed) Note. The flaw here is discovered by a good friend.\nIf $x \u0026gt; y$, Then the decimal expansion of\n$$x = \\frac{x_0}{10^0} + \\frac{x_1}{10^1} + \\frac{x_2}{10^2} + \\dots + \\frac{x_k}{10^k}$$ $$y = \\frac{y_0}{10^0} + \\frac{y_1}{10^1} + \\frac{y_2}{10^2} + \\dots + \\frac{y_k}{10^k}$$\nhas some $x_i \u0026gt; y_i$. Assume $i$ is the least such index.\nIt follows by b $$f(x) = f(1) \\left [ f(\\frac{x_0}{10^0}) + f(\\frac{x_1}{10^1}) + f(\\frac{x_2}{10^2}) + \\dots + f(\\frac{x_k}{10^k}) \\right ] = f(1) \\left [ \\frac{x_0}{10^0} + \\frac{x_1}{10^1} + \\frac{x_2}{10^2} + \\dots + \\frac{x_k}{10^k} \\right ]$$ $$f(y) = f(1) \\left [ f(\\frac{y_0}{10^0}) + f(\\frac{y_1}{10^1}) + f(\\frac{y_2}{10^2}) + \\dots + f(\\frac{y_k}{10^k}) \\right ] = f(1) \\left [ \\frac{y_0}{10^0} + \\frac{y_1}{10^1} + \\frac{y_2}{10^2} + \\dots + \\frac{y_k}{10^k} \\right ]$$\nConsidering both cases of $f(1)$ from a, The inequality $f(x) \\geq f(y)$ follows.\nNote even if $x$ or $y$ were periodic, i.e the expansion does not end, some sufficiently large $k$ would still exist fulfilling our construction.\nd Case. $f(1) = 0$\nFor any real number $x$ we can pick-up two rational numbers $q_0$ and $q_1$ such that $q_0 \\leq x \\leq q_1$, But we know $f(q_0) = f(q_1) = 0$ from b, and $f(q_0) \\leq f(x) \\leq f(q_1)$ from c.\nCase. $f(1) = 1$\nFor any real-number $x$, We know there are rational numbers $q_{1a}, q_{2a}, \\dots$ which arbitrarily get closer to $x$ from above, and similarly we know there are rational numbers $q_{1b}, q_{2b}, \\dots$ which …","date":1674172800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1674172800,"objectID":"18063d8abb24fcfb4568e4be09659a94","permalink":"https://mostafatouny.github.io/mit-analysis1c-post/pset01/","publishdate":"2023-01-20T00:00:00Z","relpermalink":"/mit-analysis1c-post/pset01/","section":"mit-analysis1c-post","summary":"Problem 1 Definition. simplest-fraction\nWe call $\\frac{\\displaystyle{x}}{\\displaystyle{y}}$ a simplest-fraction when it is in its simplest form. i.e cannot be reduced by eliminating a common fraction.\nFact. If there are no common factors between $x$ and $y$, Then $\\frac{\\displaystyle{x}}{\\displaystyle{y}}$ is a simplest-fraction.","tags":null,"title":"Problem Set 01","type":"mit-analysis1c-post"},{"authors":null,"categories":null,"content":"Playing The Video At the bottom right of the above picture, There is a hyperlinked caption. Click on it to play the video.\nTalk Abstract If people thought of something fascinating about computers, Then it would usually be about some fancy practical application. In this talk we tackle computers, but their theory or pure-math perspective. A central goal is to show everyone that theory developments are no less exciting and fascinating than practical computing. We hope to expose attendees to wear different shoes for theoretical CS. Particularly, We give an overview of computational complexity theory, which deals with classes of computational problems as a whole, not concrete individual problems like algorithms. The talk assumes no technical background, and is composed mainly of historical developments. The speaker is an undergrad student, and he is in no way an expert or authorized in this field. Rather, We give more personal reflections and hope for the talk to be as interactive as possible.\nYou can see the slides here\nTable of Contents Talk Abstract How it All Started Good Shots How it All Started It all started with a linkedin chat message I sent to Larry, For making an online-based study group with other hobbyists from compsci-subreddit. Unfortuantely, The study group did not sustain. While we were speaking together, I mentioned how cool prof. Steven Skiena is. It turned out he was Larry’s professor back when Larry was an undergrad student at Stony Brook university!. It was very kind of Larry that he wanted to support me by joining me in Stony Brook’s Algorithms seminar.\nThen I sent an email to the seminar’s mailing list, Expressing my wish to give a talk on history of computational complexity, Inspired by Fortnow’s and Homer brief historical survey. prof. Skiena emailed me (yaay!) informing that there is no space for me to give the talk and that even grad students who attend the seminar taking credit for it, Do not usually present anything.\nLuckly, My email sent to Stony Brook’s mailing list, Was received by Bo Li, A previously PhD student at Stony Brook. Then I received an email from him, Where he expressed he wishes me to give the talk for him!. It was very kind and encouraging for me, That he allowed me to give the talk with all his PhD students.\nGood Shots Physicists Success in Popular Science Why Not an Engineer? Theory is No Less Fascinating The Usefulness of Useless Knowledge Shafi and Silvio’s Seminal Paper Interactive Proof System Avi’s Abel Prize 2021 Award ","date":1617840000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1617840000,"objectID":"ae812b5710ff1dd986763fcb51e767d5","permalink":"https://mostafatouny.github.io/post/hobbyist-talk/","publishdate":"2021-04-08T00:00:00Z","relpermalink":"/post/hobbyist-talk/","section":"post","summary":"Playing The Video At the bottom right of the above picture, There is a hyperlinked caption. Click on it to play the video.\nTalk Abstract If people thought of something fascinating about computers, Then it would usually be about some fancy practical application.","tags":null,"title":"A Hobbyist's Dialogue on Theoretical CS and Overview of Computational Complexity","type":"post"},{"authors":null,"categories":null,"content":"Playing The Video At the bottom right of the above picture, There is a hyperlinked caption. Click on it to play the video. (The record generated by zoom is corrupted beginning from 7:30, but luckly we catched a good part).\nIn Brief This is a very nice memory of my enrollment in UCLA’s Math115AH honors linear algebra course, taught by prof. Richard Elman. It all started with TCS’s subreddit where I was very fortunate to meet a wonderful student, Kyle Hess. I was consulting his advices for a while. He even recommended me to prof. R. Elman’s course, So that I get a chance of building up a community and meeting other math enthusiasts. Don’t miss the video, It contains really very kind words by him.\nTable of Contents Playing The Video\nIn Brief\nQuotes\nCourse Work\nPersonal Remarks and Retrospections\nQuotes Kyle Hess\nOver the years it became apparent to me that you, Mostafa, are very dedicated to learn mathematics and I found it tragic you have no resources like a community.\nIt was clear to me how hard you are trying but you don’t have the basic fundamentals, that you needed an extra support in a form of class.\nI was able to have these resources, so I wanted to share that with other people because is such a beautiful thing, and I am glad you were able to have this experience.\nRichard Elman\nWhen we started this class I told you it would be a hard class. So, I did not fool you for sure. Mathematics is always difficult to learn and it takes alot of work.\nLearn things and follow what you like. Don’t let anybody say you should do this for any reason. If you find something you like, Follow it.\nCourse Work Homework My Solution HW-1 sol-1 HW-2 sol-2 HW-3 sol-3 HW-4 sol-4 HW-5 sol-5 Midterm sol-mid HW-6 sol-6 HW-7 sol-7 HW-8 sol-8 HW-9 sol-9 Personal Remarks and Retrospections At the moment of writing these lines, Less than one week separates me from completing my 7th semester, out of a total of 8 semesters of my university’s program. I have been so ambitious to achieve something big during the past years. The conclusion I arrive at now is: I lack undergrad foundational basics, Usually mastered by an average student. I feel really bad.\nI will always be indebted to Kyle for alarming me by a great pitfall I had fallen into. Namely, Approaching inaccessible problems with no good foundational toolboxes.\nIf there is a big lesson that, I learned before, and keep continually learn, It would be:\nI will never be on the right pathway. At best scenarios I learn from mistakes to get nearer of doing things right, but I would never be right 100%. Being a skeptic and continually learning from mistakes is not a temporary phase of a young kid. It is a morale to be reserved for someone’s whole life.\n","date":1615593600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615593600,"objectID":"c901bf1e00874761d477fe8d908b711b","permalink":"https://mostafatouny.github.io/post/math115ah/","publishdate":"2021-03-13T00:00:00Z","relpermalink":"/post/math115ah/","section":"post","summary":"When we started this class I told you it would be a hard class. So, I did not fool you for sure. Mathematics is always difficult to learn and it takes alot of work --prof. R. Elman","tags":null,"title":"Auditing Honors Linear Algebra at UCLA, A Gratitude and Retrospection.","type":"post"},{"authors":null,"categories":null,"content":"Overview In this post we contrive a new kind of Automata, Then prove a space lower-bound on it, for a contrived problem. We begin with an example which shall motivate our whole approach, Then we imagine a thought experiment which is the basis of the proof, Finally we present the formal proof itself. The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth. This is why I wrote a separate section called Thought Experiment. In addition, We strongly recommend the reader not to miss $appendix, fun facts$ section.\nTable of Contents Overview Motivating Example Usual DFA A New Definition For A New Problem First Remark On Solving The New Problem Thought Experiment Information-reserving Definition? Surprise Moment Interpreting Derived Proof Informal Proof Formal Proof Definitions Proof References Appendix Fun Facts Paper Notes of Surprise Moment Motivating Example Usual DFA The problem the above $\\textit{deterministic finite automata}$ ($\\textit{DFA})$ solves is finding whether the number of ones in the input binary string is even or odd. The $\\textit{DFA}$ is defined in the usual straight-forward way.\nA New Definition For A New Problem Now, Let’s think of a different problem for the $\\textit{DFA}$ which shall motivate a different definition. Namely, Finding the length of the longest 1-bit sequence. For instance, the string’s 0111011 longest 1-bit sequence is 3. But the usual $\\textit{DFA}$ outputs either $\\textit{accept}$ or $\\textit{reject}$, So how could it accommodate outputting a number? We tune its construction/definition as follows: We define a labeled set of states $\\textit{F}$ such that if the machine halted on any of them, The output is the label of the state the machine halted on. In our case, We designate a labeled state for each possible longest-length solution.\nFor the above diagram of $\\textit{usual DFA}$ section, We could ignore $q_{even}$ as an $\\textit{acceptance state}$, and think of the labels $\\textit{even}$ and $\\textit{odd}$ as the output of the machine.\nFirst Remark On Solving The New Problem Given $n$ is the length of the input string, An initial thought might be settling states $q_0, q_1, \\dots, q_n$ where state $q_i$ transitions to $q_{i+1}$ if bit 1 is read, and stays the same if bit 0 is read.\nAccordingly, On $w = 10110$, and after reading $10$ the machine is supposed to be at $q_1$ indicating it counted a sequence of length one. But what about counting the other ones? If the machine started counting again, It forgets the sequence of length one it counted before. If it reserved saving the first sequence length, and did not count other sequences, Then certainly the machine fails.\nThis discussion somehow suggests a state must reserve both the count of longest sequence length and the count of the sequence the machine is running on. This is the central key element our space lower-bound proof is based on.\nThought Experiment Information-reserving Definition? Personally, My first reaction was: If I proved a state must reserve two these informations, Then a $\\Omega(n^2)$ lower-bound straight-forwardly follows. That as you need $n+1$ states for each possible 1-bit sequence length, and for each of these states, You need $n+1$ states for counting a sequence the machine is running on. So, $(n+1)(n+1)$ states are needed.\nBut how on earth I shall develop a definition of information reserving? No answer. Also, I did not explore $\\textit{information theory}$ enough to figure a clue. At this point, I was skeptic whether the problem is going to solved at all.\nSurprisingly for me, Eventhough I did not define $\\textit{information-reserving}$, Via the intuition captured from it, I formulated a conjecture which worked at the end!\nSurprise Moment We desginate two strings and conjecture a counter-example yielded from each of both. Namely, Either the machine fails to remember previous counted sequences length, or fails to consider new sequences.\nFor the sake of brevity and this post’s proof readability, We omit the left string 110111. After reading the other string 1101, The machine must yield $q_{2}’$, An output state whose label indicates the automata’s output is $2$, When the machine halts on it.\nBut on the input string 110, The machine outputs also $q_{2}’$. So on input 1101, after reading 110 and while the machine is pointing on last 1 bit, it is on state $q_{2}’$.\nIt is clear now before and after reading the last 1-bit of 1101, The machine is on state $q_{2}’$. As a result, We conclude the machine state’s stays the same if it is on $q_{2}’$ and read 1.\nNow, on string 110111, It is very easy to prove the automata outputs $q_{2}’$ after reading it, and a contradiction occurs as the machine outputs the false answer!\nInterpreting Derived Proof I must admit, For the proof I have just outlined, It was not intuitive for me why does it work! In this section, I try to interpret the …","date":1606694400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606694400,"objectID":"d2306638e5f1eaf03e1aada2489a82df","permalink":"https://mostafatouny.github.io/post/automata-lower-bound/","publishdate":"2020-11-30T00:00:00Z","relpermalink":"/post/automata-lower-bound/","section":"post","summary":"The most beautiful moment I have felt while working on this problem was when a pure deductive reasoning yielded a reasonable approach, which in turn yielded a logic-based established truth","tags":null,"title":"Proving a Space Lower-bound on a Contrived Automata","type":"post"},{"authors":null,"categories":null,"content":"Problems Problem Source Solution 120004 UVa, Bubble Sort Here Here 10940 UVa, Throwing cards away II Here Here 11683 UVa, Laser Sculpture Here Here 573 UVa, The Snail Here Here ","date":1597104000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597104000,"objectID":"432e15a242f7eccc8b3682fe23808813","permalink":"https://mostafatouny.github.io/post/competitive-prog/","publishdate":"2020-08-11T00:00:00Z","relpermalink":"/post/competitive-prog/","section":"post","summary":"My solutions to selected offline problems.","tags":null,"title":"Competitive Programming","type":"post"},{"authors":null,"categories":null,"content":"Preface We prove the graphical steiner tree problem is NP-complete by reducing vertex cover to it. The version of it is taken from our favorite Kleinberg and Tardos’ Algorithm Design book’s exercises. We assume the reader is familiar with vertex cover, what NP-completeness is and the general approach for proving it by reduction.\nGraphical Steiner Tree Definition Here is a clear definition of the problem we prove its NP-completeness, Taken from klienberg and tardos’ exercise 38 of chapter 8, NP and computational intractability. Example and High-Level Overview Before showing a rigour proof, We present a simple example which demonstrates our approach. We begin with a vertix cover example, then accordingly encode it into an instance of the graphical steiner tree problem. We give some insights why finding a solution to the latter accounts for a solution to the former, and Hence argue our claimed proof is correct.\nVertex Cover Let’s consider a simple example of vertex cover problem. A graph $G$ has vertices $G(V) = \\set {1, 2, 3, 4}$ colored in red and purple, and edges $G(E) = \\set {1, 2, 3, 4 }$ colored in green. Finally, Let $k=2$ Clearly, A subset $G(V)_{red} = \\set {1, 2}$ has the minimum possible number of elements which enables covering all edges $G(E)$. Now let’s see how it is going to be encoded into an instance of a graphical steiner tree.\nGraphical Steiner Tree Construct a graph $G’$ whose vertices $G’(V)$ are the unions of,\n$\\set {S}$ a special vertex, $\\set {1, 2, 3, 4} = G’(V)_e$ colored in green corresponding to edges of the vertex cover $G(E)$, $\\set {1’, 2’, 3’, 4’} = G’(V)_v$ colored in red and purple corresponding to vertices of the vertex cover $G(V)$, and $\\set {1_0, 2_0, 3_0, 4_0} = G’(V)_o$ contains an additional vertex colored in white for each element of $G’(V)_v$. Note vertices in $G’(V)_o$ and vertex $S$ are not corresponded to anything in the vertex cover instance.\n$G’$’s edges $G’(E)$ are the unions of,\n$G’(E)_c$ corresponding to edges which connect $G’(V)_v$ with $G’(V)_e$ in case an edge is covered by a vertex in the vertex cover instance, and $G’(E)_S$ contains two edges for each element of $G’(V)_v$ connecting it to the special vertex $S$ via $G’(V)_o$. Note edges in $G’(E)_S$ are not corresponded to anything in the vertex cover instance.\nDefine $X’ = \\set{S} \\cup G’(V)_v \\cup G’(V)_e$\nDefine $k’ = ||G’(V)_e|| + 2(k) + (||G’(V)_v||-(k))$ $=$ $||G’(V)_e|| + 2(2) + (||G’(V)_v||-(2))$ where $k$ is taken from vertex cover instance.\nAccounting a Solution for Vertex Cover Let’s remark how a solution of encoded Graphical Steiner Tree yields a solution to Vertex Cover.\nBy definition of Graphical Steiner Tree, and definition of X, $G’(V)_v$ vertices must be connected to $S$. For each, There are two pathways, Either connecting backward via $G’(V)_o$ with cost of two edges, or connecting forward via $G’(V)_e$. So there is a penalty on connecting backward, and the algorithm is obliged to connect forward as much as possible to reduce the number of edges. In other words, We could reform the algorithm’s goal as, In order to connect $X$ in a single component with least possible edges, What is the minimum number of vertices of $G’(V)_v$ needs to be connected backward;y?\nThe trick here as shown from the example is that we reduced vertices covering edges in vertex cover to vertices connected to other vertices in graphical steiner tree.\nMore Rigour Remarks Now let’s present some more rigour remarks of our reduction. For the sake of readability, We intentionally omit the definition of constructed encoded instance of graphical steiner tree. We believe the above discussion suffices to convince the reader. In addition, We assume on behalf of the reader to see why both theorem 1 and theorem 2 suffices to prove intended NP-completeness.\nTheorem 1 If a vertex cover instance is decided to be covered by at most $k$ vertices, Then the encoded graphical steiner tree is decided to be solved by at most $k’$ edges.\nNote the definition of $k’$ is stated above.\nProof Let $X \\subseteq G(V)$ be the chosen vertices in vertex cover instance which cover all its edges. Let $G’(V)_X \\subseteq G’(V)_v$ containing elements corresponding to $X$.\nConstruct $F \\subseteq G’(E)$ containing,\nOne edge from each element of $G’(V)_e$ to some element in $G’(V)_X$, Two edges from each element of $G’(V)_X$ along the path to $S$, and one edge from each element of to $G’(V)_v - G’(V)_X$ to any remaining $G’(V)_e$.\nClearly, Mentioned edges exist. Also, $X’$ (see its definition above) is a single component in the graph, As all needed vertices are connected to $S$.\nBy definition, The number of elements in $X$ is at most $k$. Clearly, All mentioned edges of $X’$ are distinct from each other. Hence, The number of them is at most $k’$ following $F$’s construction.\nTheorem 2 If the encoded graphical steiner tree is decided to be solved by at most $k’$ edges, Then vertex cover instance is decided to be covered by at most $k$ vertices.\nProof Let …","date":1592524801,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592524801,"objectID":"36617fd98faacbd298f58b56ebda8f27","permalink":"https://mostafatouny.github.io/post/steiner-tree-np-complete/","publishdate":"2020-06-19T00:00:01Z","relpermalink":"/post/steiner-tree-np-complete/","section":"post","summary":"Yet, Another NP-Complete Problem. Kleinberg and Tardos' exercise 38 of their algorithm design book","tags":null,"title":"Proving Graphical Steiner Tree is NP-Complete","type":"post"},{"authors":null,"categories":null,"content":"Hold on your keyboard as a google search on Guarini’s puzzle shall show you not only the problem but also its solution as well. In fact, The solution yielded by google is far more elegant than mine presented here. So, Don’t do it if you wish to appreciate this blog post. Nonethless, I am really proud that I solved the problem on my own. The sole prerequisite to reading this post is how to move a knight in a chess board.\nPuzzle The puzzle basically asks you to interchange the two black knights with the two white knights in a 3x3 board as shown above.\nFor the sake of my own convenience, I am going to illustrate it as 3x3 table where x denotes black knights and o denoted white knights as follows.\nFrom\nx . x . . . o . o To\no . o . . . x . x Simpler Version Let’s consider a simpler problem than the one we are currently solving, Then see whether we could generalize it back to the original one. We have one black knight and wish to move it to the bottom-left cell.\nFrom\n. . x . . . . . . To\n. . . . . . x . . Remark: Interchangeable Positions Wherever our knight’s position is or where it is heading, There are two areas of the board it is interchangeably moving between. Namely,\nplus shape\n. # . # . # . # . x shape\n# . # . . . # . # Note that the center cell is unreachable at all.\nRemark: Unique Path Let’s begin doing some trials. We begin from the initial position stated above. We have two alternative moves\nmove 1\n. . x x . . . . . move 2\n. . x . . . . x . Let’s put move 2 aside now and proceed with move 1. Then we have\nmove 1-1\n. . x x . . . . . move 1-2\n. . . x . . . . x move 1-1 returns us back to a state we already visited. All paths which stem from it are already considered and hence, redundant to us. So, we need to consider only move 1-2.\nmove 1-2-1\n. . . x . . . . x move 1-2-2\n. x . . . . . . x Again, move 1-2-1 returns us to state we already visited. So, We drop it from our considerations. A similar justification shows the next move is\nmove 1-2-2-2\n. x . . . . x . . which reaches us to our desired goal. This discussion clearly shows there is a unique path from move 1 to the goal.\nWhat about move 2? Does it yield a different path than the one we just found? The answer is yes. Nonethless, We are going to drop it as well!\nRemark: Symmetry Here is the state we are in doubt of finding a new path from\nmove 2\n. . x . . . . x . We rotate the board 90 degrees to the right, Then flip it on its x-axis.\nrotation\n. . . x . . . . x flip\n. . x x . . . . . Which is exactly move 1 we considered before! In fact, the whole path which stems from move 2 is exactly the same as move 1 but seen from a different perspective. At this point you might wish to do some trials on your own to see the two equivalent paths from two different perspectives.\nConcluding For a General Approach We focus our attention on the one unique path we found regardless of its different representations/perspectives due to board’s symmetry. Could we move all knights on this path? Could board’s symmetry allow us to re-interpret each knight’s path as the unique path we discussed earlier?\nFor the top-left black knight. If we rotated the board 90 degrees to the right, We could re-interpret it as a top-right black knight which wishes to reach bottom-left cell.\nFor the bottom-left white knight. If we rotated the board 180 degrees to the right, We could re-interpret it as a top-right black knight which wishes to reach bottom-left cell.\nFor the bottom-right white knight. If we rotated the board 270 degrees to the right, Similarly, We could re-interpret it as following the unique path we found.\nNote that for an interation, If we moved each knight one step as we just illustrated, We see the two areas we highlighted in remark: interchangeable positions are fully covered interchangeably.\nSolution As we just noted, Let’s just move each knight one step in the unique path we found for an iteration.\nx . x . . . o . o Iteration: 1\nx . x x . . o . o x . . x . . o x o . . . x . o o x o . o . x . o . x o . o . x . o . x . Iteration: 2\n. o . x . o . x x . o x . . o . x x o o x . . o . . x o o x . . . o . x o . x . . . o . x Iteration: 3\no x x . . . o . x o x x x . . o . . o x . x . . o o . . x . x . o o o . . x . x . o . o . Iteration: 4\n. x . x . o x o . . . . x . o x o x . . o . . o x o x o . o . . o x . x o . o . . . x . x tdaa !!\nConclusion Now I think it is time to google Guarini’s puzzle to see a more elegant solution than the one presented here. By the way, I am not jealous if you liked it more than mine.\n","date":1592438401,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592438401,"objectID":"c568b5b3c164f7ea6726b8d211a6b3f5","permalink":"https://mostafatouny.github.io/post/guarini/","publishdate":"2020-06-18T00:00:01Z","relpermalink":"/post/guarini/","section":"post","summary":"However, It is mine","tags":null,"title":"Guarini's Puzzle, A Less Elegant Solution","type":"post"},{"authors":null,"categories":null,"content":"First Trial At each step we discard a card away, and move the new card at the top to the bottom of the deck. That suggests we eliminate half of the deck for one iteration. Consider the following deck\n1 x 2 -\u0026gt; 3 x 4 -\u0026gt; 5 x 6 -\u0026gt; 7 x 8 -\u0026gt; Here, We have a deck of eight cards whereby card number one is at the top of the deck. x indicates the card is to be thrown away, while -\u0026gt; indicates the card to be moved to the bottom. Note that in this case, None of the -\u0026gt; cards are going to be thrown away due to later x. It is easy to see that the result is as follows\n2 4 6 8 Similarly to the first iteration, the second one would be\n2 x 4 -\u0026gt; 6 x 8 -\u0026gt; yielding\n4 8 Finally, Getting card eight as the answer.\nSo, On each iteration, we divided the dick by half and still got an even number of cards. It is clear that is attributed to the fact that eight is a power of two. Otherwise, On some iteration we would end-up with an odd number of cards. That iteration is not the last one in which we have the last remaining card. You could see if we have a deck whose cards number is some power of two, Then the answer would be the last card at the bottom. In other words, if our cards number is $n = 2^k$ for some k, Then the correct answer of the problem, i.e the last remaining card after discarding cards and moving them to the bottom, is $2^k$.\nMore Justification of First Trial’s Observation Let’s try to take a deeper look at why do we always obtain the last bottom card as the remaining one in case the deck is some power of two, As illustrated earlier. Consider our $2^3 = 8$ deck but represented differently\nOn First Iteration:\n$2^0 \\times 1$ x $2^0 \\times 2$ -\u0026gt; $2^0 \\times 3$ x $2^0 \\times 4$ -\u0026gt; $2^0 \\times 5$ x $2^0 \\times 6$ -\u0026gt; $2^0 \\times 7$ x $2^0 \\times 8$ -\u0026gt; On Second Iteration:\n$2^1 \\times 1$ x $2^1 \\times 2$ -\u0026gt; $2^1 \\times 3$ x $2^1 \\times 4$ -\u0026gt; On Third Iteration:\n$2^2 \\times 1$ x $2^2 \\times 2$ -\u0026gt; Remarkably, Cards multiplied by an odd number gets thrown away, while cards multiplied by an even number gets moved to the bottom and survives to the next iteration. You could also see that $2^{k_0} \\times (2k_1) = 2^{k_0+1}$. The even number increases the power of two by one. That correspoinds with our observation that each iteration’s power is increased by one than its predocessor’s power. Clearly, Continuing in this way ends us up with the greatest power of two in the whole deck, which is also the last bottom card.\nGeneralizing for None Power of Two Our solution for the generalized case is in fact an extension of the special case of deck’s whose number is a power of two. Let’s begin from where we ended up.\nA Deck of Seven Cards On First Iteration:\n1 x 2 -\u0026gt; 3 x 4 -\u0026gt; 5 x 6 -\u0026gt; 7 Note that I intentionally did not mark card seven. Otherwise, The second iteration would have the first card marked as -\u0026gt;, violating consistency of marking among iterations. In case cards number is odd, as in this case, We prefer to avoid marking the last card, and get the second iteration as\n7 x 2 -\u0026gt; 4 x 6 -\u0026gt; We have got here cards of some power of two. Following our illustrated observation in the previous section, We could conclude the last remaining card is card six.\nFor eight cards deck, The second iteration was \u0026lt;2, 4, 6, 8\u0026gt;. Removing card eight from the deck resulted in having card seven as a remainder from the first iteration, and shifting \u0026lt;2, 4, 6, 8\u0026gt; one position to the right. As a result, We have card six as the last one in second iteration\nFor eight cards deck, The last remaining card was eight. For seven cards deck, the last remaining card is six. Removing one card from the eight cards deck yielded the same remaining card but subtracted by two. In other words, $8 - 1$ cards deck yields the last remaining card sevenCardsAnswer = eightCardsAnswer - (2 * removedCards) = 8 - (2 * 1) = 6. Let’s try more trials and see how they relate with the case of eight cards deck\nA Deck of Six Cards On First Iteration:\n1 x 2 -\u0026gt; 3 x 4 -\u0026gt; 5 x 6 -\u0026gt; On Second Iteration:\n2 x 4 -\u0026gt; 6 x So, we end-up with card four. Again, $8 - 2$ cards deck yields the last remaining card sixCardsAnswer = eightCardsAnswer - (2 * removedCards) = 8 - (2 * 2) = 4. Here, unlike the case of seven cards deck, There is no remainder from the first iteration so that we end up with four cards in the second iteration. As two cards are removed from eight cards deck, we have three cards in second iteration rather than four. card six here is in an odd position, so it gets thrown away. The last remaining card is card four. In other words, It seems removing two cards from eight cards deck shifted our \u0026lt;2, 4, 6, 8\u0026gt; a position to the right in addition to removing the last card.\nA Deck of Five Cards On First Iteration:\n1 x 2 -\u0026gt; 3 x 4 -\u0026gt; 5 As in the case of seven cards deck, We do not mark card five in the first iteration. Recall the the last card is not marked whenever we have an odd number of cards in an interation.\nOn Second Iteration:\n5 x 2 -\u0026gt; 4 x Again, $8 - 3$ cards deck yields the last remaining card …","date":1591833601,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591833601,"objectID":"b5dbdef4b2977fa21c50b7d5f13b1905","permalink":"https://mostafatouny.github.io/competitive-prog-post/throwing-cards-away/","publishdate":"2020-06-11T00:00:01Z","relpermalink":"/competitive-prog-post/throwing-cards-away/","section":"competitive-prog-post","summary":"Math is not routine calculations at all.","tags":null,"title":"UVa 10940, Throwing Cards Away II","type":"competitive-prog-post"},{"authors":null,"categories":null,"content":"Restructuring The Problem, More Conveniently Before tackling a solution, We need to reformulate the given problem. You might consider this a reduction to a form which is more convenient to solve. The problem states We are given an array of size n whose elements are {1, 2, .., n} and are distinct. That concludes the given array a is a permutation of {1, 2, .., n}. If we listed all these permuations and computed bubbleCounts on each, Then taken their average, That would be the answer to UVa’s problem. Running findSwaps() infinitely is just a fancy way of describing our\nDefinition: Average bubble counts of all permutations.\nObservations On n = 2,\nbubbleCount 1 2 0 2 1 1 average = $\\frac{0+1}{2}$ = $\\frac{1}{2}$\nOn n = 3,\nbubbleCount 1 2 3 0 1 3 2 1 2 1 3 1 2 3 1 2 3 1 2 2 3 2 1 3 average = $\\frac{0+1+1+2+2+6}{6}$ = 2\nOn n = 4,\nbubbleCount 1 2 3 4 0 1 2 4 3 1 1 3 2 4 1 1 3 4 2 2 1 4 2 3 2 1 4 3 2 3 2 1 3 4 1 2 1 4 3 2 2 3 1 4 2 2 3 4 1 3 2 4 1 3 3 2 4 3 1 4 3 1 2 4 2 3 1 4 2 3 3 2 1 4 3 3 2 4 1 4 3 4 1 2 4 3 4 2 1 5 4 1 2 3 3 4 1 3 2 4 4 2 1 3 4 4 2 3 1 5 4 3 1 2 5 4 3 2 1 6 average = $\\frac{0+1+1+2+2+3+1+2+2+3+3+4+2+3+3+4+4+5+3+4+4+5+5+6}{24}$ = 3\nSymmetry Consider the case of $n=3$. Notice that the least bubbleCount is the first one accounting for zero, and the greatest bubbleCount is the last one accounting for 3. You could see that for each permutation of bubbleCount 1, There is a corresponding permutation of bubbleCount 2. The sum of 1 and 2 is also 3 !\nNote also that the corresponding permutation is exactly like the other one but inversed. For instance permutation \u0026lt;3, 1, 2\u0026gt; is the inversed in order of \u0026lt;2, 1, 3\u0026gt;.\nSo, we could divide our list of permutations into two halves such that a pair’s sum equals $min(bubbleCount) + max(bubbleCount)$. Clearly, There are a total of $n!$ permutations. The number of those pairs is half of total permutations. Hence, total sum of bubble counts is $\\frac{n!}{2} \\times (min(bubbleCount) + max(bubbleCount))$. Now we divide that total sum on total number of permutations to get the average of all bubbleCounts. So, The formula is now $\\frac{(min(bubbleCount) + max(bubbleCount))}{2}$. Clearly, least bubbleCount is always zero, As we have the permutation which is already sorted. What about the greatest one? The worst case is the permutation sorted inversely. In such case, The first iteration, i.e outer loop, accounts for $(n-1)$ bubbles. The second itertaion accounts for $(n-2)$, and so on untill an iteration accounts for exactly one bubble. So, $max(bubbleCount)$ = (n-1) + (n-2) + .. + 1 = $\\frac{n \\times (n-1)}{2}$. Hence, Our conjectured formula is\n$$\\frac{0 + \\frac{n(n-1)}{2} }{2} = \\frac{n(n-1)}{4}$$\nCheck this for more information about gaussian’s famous equation.\nMore Justification on Symmetry We have shown that least bubbleCount and greatest bubbleCount among all permutations are equal to zero and (n-1) + (n-2) + .. + 1, respectively. Let’s take a deeper and more general look on why we could divide our permutations list into two halfs whereby each pair’s sum is equal to greatest bubbleCount. That pair’s permutations are also inverse of each other.\nFor the case of $n=3$, Pick up two permutations which are inverse of each other and try to run bubbleSort algorithm on both of them. You shall find for a permutation, The bubble counted on some pair of numbers, is not counted in the other corresponding permutation. For instance, permutation \u0026lt;1, 3, 2\u0026gt; needs one bubble swap in \u0026lt;3, 2\u0026gt; pair. For the permutation’s inverse \u0026lt;2, 3, 1\u0026gt;, There’s no need to bubble swap \u0026lt;2, 3\u0026gt; pair. That saves us one bubble swap out of three which is the maximum bubbleCount. 3 - 1 = 2, The bubbleCount of \u0026lt;2, 3, 1\u0026gt;. The same applies for any two pairs of permutations which are inverse of each other.\nAccepted Source Code on UVa #include \u0026amp;lt;cstdio\u0026amp;gt; #define ll long long #define ull unsigned ll using namespace std; bool checkIthBit (int n, int i) { if( n \u0026amp;amp; (1 \u0026amp;lt;\u0026amp;lt; i) ) return true; return false; } int main() { int t, cou = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;amp;t); while (cou \u0026amp;lt;= t) { int n; ull numerator; int denominator; scanf(\u0026#34;%d\u0026#34;, \u0026amp;amp;n); numerator = ((ull)n*(ull)(n-1)); denominator = 4; // check if nume is div by 2, and simplify rational form for (int i=0; i\u0026amp;lt;2; ++i) { if (!checkIthBit(numerator, 0)) { numerator = numerator/2; denominator = denominator/2; } } if (denominator == 1) printf(\u0026#34;Case %d: %llu\\n\u0026#34;, cou, numerator); else printf(\u0026#34;Case %d: %llu/%d\\n\u0026#34;, cou, numerator, denominator); cou++; } return 0; } Many of those who do not appreciate math, think of it as a routine where you just follow a systematic order of operations on numbers. If you are one those, I hope this article changed, at least doubted, how you perceive it. There are a whole deep and elegant adventures still awaiting you if you delved more deeply. ","date":1591833601,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591833601,"objectID":"8c10b5862ac504d31904bb7335ea5088","permalink":"https://mostafatouny.github.io/competitive-prog-post/bubble-sort/","publishdate":"2020-06-11T00:00:01Z","relpermalink":"/competitive-prog-post/bubble-sort/","section":"competitive-prog-post","summary":"Math is not routine calculations at all.","tags":null,"title":"UVa 120004, Bubble Sort","type":"competitive-prog-post"},{"authors":null,"categories":null,"content":"Proposed Solution, Intuitively Before delving into mathematical rigour details, Let me give you an intuitive description of the solution and why it works.\nNote that the laser only sculpts a layer of height equal to one while it is still on. If we wish to sculpts a layer of height 2, Then the laser must be toggled on and off twice. That suggests each layer intended to be sculpted counts on the laser to be turned on after being on off state. What if there are more than one sculpture on the same layer, but separated by couple of unsculpted units? then each sculpture on this layer counts per se.\nThink of the following, where b indicates a sculpted unit and x indicates an unsculpted unit. A height equal to three is made here for a simple illustration.\nX_i X_i+1 b b x b x x if $X_i$ here is $X_1$, then certainly the blank unit counts as a laser is turned on. What about $X_1$, Would the two blank units count each on laser? Considering the fact that a laser could move horizontally while it is still being turned on allows two blanks crossing $X_0$ and $X_1$ to be sculpted on one count. What about the second blank of $X_1$? Clearly, The laser must sculp the blank above it first, So the second blank would be an additional count. Seemingly, We came across a condition here. if a blank in $X_i+1$ came after a blank in $X_i$, Then it should not count but if it came after an unsculpted unit, Then it counts.\nThe observation suggests the following. A column which tracks counts on each layer, and the state of the last scanned unit, i.e whether it is sculpted or not. Initially, It would be\ncount unit 0 x 0 x 0 x x units initialized here are on behalf of the left most outer border. We proceed as follows, For a given X_i determine units b sculpted and units x unsculpted. If a unit is x, Then leave count as it is. If a unit is b, Then check the unit before it, If it is b leave count but if it is x increment count by one. Afterward, Update unit column with the new unit. Do these steps on all vertical units. Repeat the procedure on each $X_i$. The correct result is the sum of all counts.\nWe could furtherly improve. Why do we need to track each layer on a separated count for it? Instead, We could define only one variable which gets incremented whenever any layer detects a new laser sculpture. In addition, For the unit column, We do not need to check every unit and compare it with the previous one in order to find blank units preceeded by unsculpted x units. max(0, $X_i$ - $X_{i+1}$) would do the trick of finding blank units b in $X_{i+1}$ preceeded by x unit.\nSource Code #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;algorithm\u0026gt; #define usi unsigned short int int main() { usi h, w; int X_bef, X_cur, cou; while(true) { scanf(\u0026#34;%hu %hu\u0026#34;, \u0026amp;h, \u0026amp;w); if (h == 0) break; cou = 0; X_bef = h; for (usi i=0; i\u0026lt;w; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;X_cur); cou = cou + std::max(0, X_bef-X_cur); X_bef = X_cur; } printf(\u0026#34;%d\\n\u0026#34;, cou); } return 0; } Formal Logic Here comes the formal-logic based proof of our algorithm’s correctness. Kindly, note that it might still be flawed. However, If it is not, Then we guarantee the algorithm to yield the correct answer without any bugs or errors. Anyway, Before getting into the proof, We need to rigoursly model the problem of Laser Sculpture - 11683. Those rigor definitions and constraints are derived from our understanding of the problem.\nDefinitions For the following, We assume $h$, $w$ $\\in \\mathcal{N}$\nBoard: A 2d-array-alike corresponding to overall units. board is $b = (h \\times w)$, units $u_{i,j}$ indexed (labeled) by a cartesian product of board’s height and width.\n$X_0$: We define an imaginary height equal to $h$ of a given board. It serves on behalf the left most outer border for the first iteration of our algorithm.\nSculpture set on board: A family of sets where each set is the set of units sculpted by the laser while it is still on. The sculpture set is $S = ${$ S_1, S_2, .., S_k$} such that $\\cup S \\subseteq b$, $S_i \\cap S_j = \\phi$ for any distinct i and j, $S_i \\neq \\phi$ for any i. That says sculptures are subset of the original board units, no two sculptures are intersecting, and there’s no empty sculpture. That conforms with our understanding that a unit cannot be shot twice by a laser, and a laser is not going to be turned on without sculpting some unit.\nTop-first: That is a condition which ensures no sculpture occurs on some layer before the layer above it is sculptured. For any $S_q \\in S$, $\\forall u_{i,j} \\in S_q( ${$ u_{x,j} \\in b | x \u0026lt; i $}$ \\subseteq S_{q-1} \\cup S_{q-2} \\cup .. \\cup S_{1} )$.\nOne-row: That is a condition which ensures a continuous row of units are sculptured at once, not sculptured on multiple times in which the laser is turned on and off multiple times as well. For any two distinct $S_k$ and $S_q$, $\\neg( \\exists j_0 \\exists j_1, u_{i_0,j_0} \\in S_q \\wedge u_{i_1,j_1} \\in S_k \\wedge j_1=j_0+1)$ for some $u_{i_0,j_0}$ and $u_{i_1,j_1}$.\nUniqueness: It is assumed that there is a unique number of times …","date":1588291201,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588291201,"objectID":"5b75a11537c276a2468fe946341e843d","permalink":"https://mostafatouny.github.io/competitive-prog-post/laser-sclupture/","publishdate":"2020-05-01T00:00:01Z","relpermalink":"/competitive-prog-post/laser-sclupture/","section":"competitive-prog-post","summary":"Challenging my self to prove its correctness via formal logic.","tags":null,"title":"11683 UVa, Laser Sculpture","type":"competitive-prog-post"},{"authors":null,"categories":null,"content":"My Proposed Solution Probably, You thought of the straight forward solution of just simulating the height reached by the snail day by day till some condition applies. So, your computation would look like $$ (u_1 - fatigue_1 - d_1) + (u_2 - fatigue_2 - d_2) + .. + (u_n - fatigue_n - d_n) $$\nIn this solution I claim determining whether the snail succeeded or failed could be done in $O(1)$ !! (that discovery was a surprise for me, as well). In a nutshell, We shall derive a formula which computes the snail’s height on any given day. Then we find the day in which the snail’s height is at its peak. By plugging in that day in the formula, we compute the height peak of the snail. if that height peak is greater than $h$, the weight of the well, then we conclude the snail at some point exceeds the well. If the height peak is equal or less than $h$, Then we conclude the snail shall not exceed the well.\nLet’s begin by finding the formula. I noticed a pattern. That computation you probably first thought of is exactly like $$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - (fatigue_1 + fatigue_2 + .. + fatigue_n) $$ $$ = (u \\times i) - (d \\times i) - (\\text{total fatigue up to day i})$$ So, instead of looping in a complexity of $\\omega(n)$, One equation could achieve the same result in a complexity of $O(1)$. The first and second parts are obvious, but how do we find the third one? First, Assume $f=1$, then $$fatigue_1=0.01 * u * 1, fatigue_2=0.01 * u * 2 , .. , fatigue_n=0.01 * u * i$$ As each day we increase fatigue by $f$, day number $i$ should be equal to $i$ times $f$. $0.01$ and $u$ are common factors, so we could re-write this as $$(0.01*u)(1 + 2 + .. + i)$$ the right part of the equation is where the magic happens. Friedrich Gauss, The legendary mathematician discovered that it is equal to $$\\frac{n(n+1)}{2}$$ He made it when he was a kid as his teacher tried to preoccupy his time with tedious math calculation! read his story here. So, the final pattern looks like this $$ (u_1 + u_2 + .. + u_n) - (d_1 + d_2 + .. + d_n) - \\frac{n(n+1)}{2} $$ So far, that equation applies when $f=1$ but the The Snail - 573 problem asks for a general value of $f$. Let me get you through the proof of Guassian’s equation briefly, and see how could we generalize it to a general value of $f$. Assume we wish to calculate $2 \\times (1+2+ .. + n)$. That could be re-written as $$ 1 + 2 + .. + n $$ $$ + $$ $$ n + (n-1) + .. + 1 $$ Try to interpret both of these equations as $n$ columns of two rows. The first column is $1+n$, second is $2+(n-1)$, .. , nth day is $n+1$. All of the $n$ columns are equal to $n+1$. Therefore $$2 \\times (1+2+ .. + n) = n(n+1)$$ Divide both sides by two, and the proof of Guassian’s equation is done. QED. Now, instead of incrementing by one, the value of %f%, assume %f=x% where x is an arbitrary value. Let’s try to re-apply the proof again. This is time we calculate $2 \\times (x+2x+ .. + nx)$. We re-write it as $$ x + 2x + .. + nx $$ $$ + $$ $$ nx + (n-1)x + .. + x $$ Similarly, $(x+nx) + (2x+(n-1)x) + .. + (nx+x) = n(nx+x)$, As each term of the n terms is equal to $(x+nx)$. Dividing by two yields us the final magical equation as follows $$ (u \\times n) - (d \\times n) - \\frac{n(nx+x)}{2} $$ That justifies totalHeight and fOnDay functions in my source code (see them below). So now, we could find the height of the snail at any day by just plugging-in a formula in a complexity of $O(1)$.\nHow are we going to use the formula we just derived? Are we going to loop on each day, applying the formula then checking for some conditions? That would account for complexity of $\\omega(n)$ which saves us nearly nothing. As I promised you before, We find the day in which the snail reaches its peak. Then we plug-in that day in the formula we just derived to find the greatest possible height the snail ever reached. Finally, we compare that with $h$ to reach our conclusion of whether the snail succeeded.\nTake a look at the following equation. Recall that $u$, $d$ and $f$ are given in The Snail - 573 problem. $$ (i*f)*u = (u-d) $$ So, The only unknown is $i$ which could be easily computed. What we are trying to find out here is the day $i$ for which fatigue is equal to the total increment the snail achieves. in other words, we are looking for the day in which fatigue totally cancels out any upwards increment. The upwards increase of $u-d$ keeps decaying due to fatigue till no possible upwards increment is possible. Hence, day $i$ in the above equation is the day in which the snail reaches its peak! That justifies my function dayOfNonIncrease in the source code below. Now, we could find out the maximum possible height reached by the snail.\nAt this point, I delivered my promise that we could find out whether the snail failed or succeeded in $O(1)$. The Snail problem asks for more than that, namely, the day in which the snail succeeded or failed.\nThere is a catch in our approach. According to The Snail - 573 problem, the fatigue cannot …","date":1587859201,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587859201,"objectID":"1741b271fc260bf6a1c82fe6fedcbcb0","permalink":"https://mostafatouny.github.io/competitive-prog-post/the-snail/","publishdate":"2020-04-26T00:00:01Z","relpermalink":"/competitive-prog-post/the-snail/","section":"competitive-prog-post","summary":"Not based on fancy algorithms or data structures.","tags":null,"title":"573 UVa, The Snail","type":"competitive-prog-post"},{"authors":null,"categories":[],"content":"Intro In this post we analyze and compare metacritic ratings of best 2019 games, Given by both the gaming community and professional journalism. It is divided into three sections, namely, data preprocessing, exploratory analysis, and systematic test. I launched a similar post upto exploratory analysis on this Reddit post. Surprisingly, The community shared with me great insights and feedbacks. If you have already seen my notebook on reddit’s post, Then skip to systematic test. There is a summary of each section if you’re lazy to read the whole kernel. Check summaries out in table of contents below. On the other extreme, If you are willing to read every detail of the kernel, I provided for you the full sourcecode used in this blog post here.\nIn a nutshell, The goal of this blog post is:\nAnalyzing top games got high ratings from professional critics but not from community of users. Analyzing top games got high ratings from community of users but not from progessional critics. Graph of percentage of games whose disparity between critics and users are low, moderate, or high. Do above steps on four platforms, namely, PS4, Xbox One, Switch, and PC. Then we compare them. Apply permutation and p-values systematic test on each platforms pairs distributions. What I Have Learned From Reddit Community In this paragraph I shall highlight and review reddit’s community comments which I found most useful. I am going to just quote the user’s name, and summarize his comment. To see his full comment, just CTRL+F his name on reddit’s page. After each summary, I spot what I learned, and how analysis could be furtherly improved according to it. However, None of these spots are implemented here.\nArtKorvalay A gamer who dislikes a game but finds no outrage from the community does not add up his voice. A gamer who moderates a game but finds an outrage from the community adds up a negative voice\nWe could consider ratings along whether the game is hyped or outraged from the community. In that way, we might reach more accurate analysis.\nArtKorvalay Some games like disco elsiym gets played by only those who like such genre of games. A humble 2d-graphics like this shall not be played by any casual gamer who gets attracted by marketing and high graphics. So, a gamer who chooses to play it must be a fan of that style. As a result, the game got rated only by those who like it. Hence, ratings are biased.\nWe could consider ratings along whether a game’s marketing budget is high or low. In that way, we might reach more accurate analysis.\nEoceneMiacid Terminator Resistance case study is typical for disparity between users and critics. Have a look here how the problem was highlighted by media.\nExploring this case study might reveal new insights as it is typical of the problem of disparity between users and professional critics. We might test our new techniques on this case study and see how our techniques perform up against it. Testing analysis techniques on a case we already know about emphatically shall help us on detecting mistakes in our analysis.\nTable of Contents Preface\nPreface What I Have Learned From Reddit Community Data Preprocessing\nImport Libraries and Local Files Read Data Data Cleansing Data Preprocessing Summary Exploratory Analysis\nCompute Disparity (Difference) Between Users and Critics Discretize Disparity Computed Earlier Into Categories Sort According to Disparity Between Users and Critics Basic Stats on Disparity Between Users and Critics Graphing Disparity Between Users and Critics Maximum Disparity Between Users and Critics Ratings Minimum Disparity Between Users and Critics Games Which Got Higher Ratings From Users Than From Critics Exploratoy Analysis Summary Systematic Test\nA Single Permutation Shuffle Based Trial With Histogram \u0026amp; Probability Density Function Permutation Test and P-Value Based Statistical Significance Systematic Test Summary Import Libraries and Local Files # 3rd-party libraries import numpy as np import pandas as pd import matplotlib.pyplot as plt # local-files import jsonRW as jsRW import graphs.pie as pieGraph import graphs.categoricalHeatmap as categoricalHeatmapGraph import graphs.groupedBars as groupedBarsGraph import graphs.histogramPdf as histogramPdfGraph import transformations.transformations as transform import transformations.discretizeIntoCategories as discIntCat import statTests.permutationTest as permTest Read Data Read Local JSON Data Into a Pandas Dataframe # a map from each platform to its corresponding dataframe platform_df = {} # platform names and their corresonding data file names platformsNames = [\u0026#39;ps4\u0026#39;, \u0026#39;xbox\u0026#39;, \u0026#39;switch\u0026#39;, \u0026#39;pc\u0026#39;] filesNames = [\u0026#39;ps4.csv\u0026#39;, \u0026#39;xbox.csv\u0026#39;, \u0026#39;switch.csv\u0026#39;, \u0026#39;pc.csv\u0026#39;] # for each platform, then for name in platformsNames: # read its local json file metacritic_list = jsRW.readJson(name) # parse it as pandas dataframe, then map platform name to it platform_df[name] = pd.DataFrame(metacritic_list) # take a look at a dataframe platform_df[\u0026#39;ps4\u0026#39;] critic_rating id …","date":1583452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583452800,"objectID":"bb8a161a328bc042dada561b0c159847","permalink":"https://mostafatouny.github.io/post/permutation-test/","publishdate":"2020-03-06T00:00:00Z","relpermalink":"/post/permutation-test/","section":"post","summary":"Randomized Shuffling As My First Systematic Analysis","tags":[],"title":"Analyzing Disparity Between Users and Journalists Ratings","type":"post"},{"authors":null,"categories":[],"content":"Introduction The post you are currently reading shall demonstrate how far our data published on social media is being heavily gathered for data analysis. The demonstration holds as a beginner kid like me is going to scrape data, i.e store data on a file, after only two weeks of learning. Not only the code I built works solely on the website I shall be presenting but rather on any website! However, It is not robust enough to rely upon except for simple cases.\nContents Introduction Motivation Code on Github How The Code Works? Motivation Machine learning, The prettiest-looking AI nowadays, does not work without data. In fact, one of the fundamental pillars of AI’s success is the availability of right data. Unfortunately, industries do not like to share them. Most probably, due to the sensitivity of competition, as rivals would always favor to stay ahead of their competitors. So, what do you do if you needed data for research, business, or even for a hobbyist-project but could not find it? Buying data costs you too much, and not everyone has tight relationships with industries whose platforms generate desired data. Scraping websites, i.e gathering data on web into a readable format by the computer, is a highly recommended skill for data analysts.\nCode on Github Here is the scraper I built. Even-though its design is not restricted to a specific website, I only test it on metacritic. The code contains an example on scraping metacritic’s 2019 best PS4 games.\nHow The Code Works? The following is a brief illustration of metacritic’s example on github’s repo. If you checked out metacritic’s link, you would see a list of games, each with its own score and release date. First, Let’s take a look on what your machine actually reads in order to render that page.\n\u0026lt;ol class=\u0026#34;list_products list_product_condensed\u0026#34; \u0026lt;li class=\u0026#34;product game_product\u0026#34;\u0026gt; ... \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;product game_product\u0026#34;\u0026gt; ... \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;product game_product\u0026#34;\u0026gt; .. \u0026lt;/ol\u0026gt; each li tag corresponds to some game on the list. While ol tag corresponds to a wrapper of all games on the list. Here is a sample of what is inside each game’s tag.\n\u0026lt;li class=\u0026#34;product game_product\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;product_wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;basic_stat product_title\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/game/playstation-4/nier-automata---game-of-the-yorha-edition\u0026#34; NieR: Automata - Game of the YoRHa Edition \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; Now, How does the program scrapes data of websites? There are three steps to get the code working, (I) enter the link which contains data intended to be scraped,\nmainURL = \u0026#34;https://www.metacritic.com\u0026#34; subURL = \u0026#34;/browse/games/score/metascore/year/ps4/filtered?year_selected=2019\u0026#34; (II) specify the tags’ path from root up to the tag which wraps all games list,\nlistNodeSequence = tagSequence.tagSequence([(\u0026#39;ol\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;list_products list_product_condensed\u0026#34;}), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_condensed\u0026#34;}), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;: \u0026#34;body_wrap\u0026#34; .. then (III) for each data desired to be scraped, alike game name, game score, game release date, specify the path from the game’s tag up to that data. make sure not to type any game-specific data like the href of nier: automata\ncolumns_paths = tagsPaths.tagsPaths( [ (\u0026#39;title\u0026#39;, [(\u0026#39;a\u0026#39;,), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;basic_stat product_title\u0026#34;}), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_wrap\u0026#34;})], -1), (\u0026#39;critic_rating\u0026#39;, [(\u0026#39;div\u0026#39;,), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_score\u0026#34;}), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_wrap\u0026#34;})], -1), (\u0026#39;user_rating\u0026#39;, [(\u0026#39;span\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;textscore\u0026#34;}), (\u0026#39;li\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_avguserscore\u0026#34;}), (\u0026#39;ul\u0026#39;,), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;condensed_stats\u0026#34;}), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_wrap\u0026#34;})], -1), (\u0026#39;release_date\u0026#39;, [(\u0026#39;span\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;data\u0026#34;}), (\u0026#39;li\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;release_date\u0026#34;}), (\u0026#39;ul\u0026#39;,), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;condensed_stats\u0026#34;}), (\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;:\u0026#34;product_wrap\u0026#34;})], -1) ] ) after running the program, you should obtain a list of containing all games, not just one of them.\n[ { \u0026#34;critic_rating\u0026#34;: \u0026#34;91\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;Jul 2, 2019\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Final Fantasy XIV: Shadowbringers\u0026#34;, \u0026#34;user_rating\u0026#34;: \u0026#34;8.3\u0026#34; }, { \u0026#34;critic_rating\u0026#34;: \u0026#34;91\u0026#34;, \u0026#34;release_date\u0026#34;: \u0026#34;Feb 26, 2019\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;NieR: Automata - Game of the YoRHa Edition\u0026#34;, \u0026#34;user_rating\u0026#34;: \u0026#34;8.4\u0026#34; }, ... The remaining of the code sample are available in the github’s repo. They are named metacritic2019_main.py, metacritic2019_functions.py. and metacritic2019_data.json\nthat’s it! for any website, just provide the link which contains data, and the two paths, one from root up to wrapper tag, and the other from each record’s tag up to desired data.\n","date":1580516220,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580516220,"objectID":"805fdd09e2d7e8b2f4fafdab12e71711","permalink":"https://mostafatouny.github.io/post/scraping-metacritic/","publishdate":"2020-02-01T00:17:00Z","relpermalink":"/post/scraping-metacritic/","section":"post","summary":"Mining the new oil","tags":[],"title":"Scraping Data of 2019 Best PS4 Games on Metacritic","type":"post"},{"authors":null,"categories":null,"content":" It had been my pleasure to participate in global AI bootcamp 2019. It was targeted at non-technology experts where it aims to raise the awareness about AI’s significant role in nearly every field. It aims as well to network technology experts with industry practitioners hoping for fruitful collaboration. We had Ahmed Bahaa, Microsoft’s regional director of the Middle-East, as a keynote speaker. Learn more about this great man at Microsoft’s regional directors profiles\nIt was a great opportunity for me to share my vision of the intersection of science and art. I talked about Netflix one-million dollars prize. The story is well-known and I see no reason to repeat it here. See IEEE’s spectrum news for more information. Anyway, My session highlighted two folds. First, how do machines’ algorithms intrude art realm where they model and compute people’s tastes. Second, How could artists delve into computer scientists realm where their aesthetic viewpoints are fruitful for interpreting data and algorithm design. I am planning to blog a survey about the intersection of AI and media/arts. Stay tuned!\nDr. Islam El-Shaarawy introduced me to A. Bahaa who in turn provided me with this opportunity. Originally, I was asked to speak about Microsoft’s azure cloud service. However, At the end we agreed upon both telling the story of Netflix and giving a brief azure demo. Literally, This is the first time I could present and do a work dervied purely by my vision, while satisfying someone else’s requirements. I always face a dilemma between what I believe and envision to achieve and what real-life constraints impose upon me. Luckily, Mass-communication faculty members attended at first seats. They were responsive and asked RD A. Bahaa for a meeting for further collaboration. Their positive feedback had been inspiring for me. It is really a great experience to spot a problem from different perspectives, and try to think in a wonderful way which no one had ever though of before. As a science/tech guy, working with artists shall certainly polish my skill of tackling problems from novel perspecitves. Probably, you know where to look now for a tech/math enthusiasit’s journey with art.\n","date":1576713600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576713600,"objectID":"ebebb631142fcad09dc4f8a1902588e9","permalink":"https://mostafatouny.github.io/post/global-ai-bootcamp/","publishdate":"2019-12-19T00:00:00Z","relpermalink":"/post/global-ai-bootcamp/","section":"post","summary":"Not such a bad beginning at all","tags":null,"title":"Global AI Bootcamp: My First Public Speak","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://mostafatouny.github.io/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"","type":"widget_page"}]